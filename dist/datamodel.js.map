{"version":3,"sources":["webpack://DataModel/webpack/universalModuleDefinition","webpack://DataModel/webpack/bootstrap","webpack://DataModel/./node_modules/d3-dsv/src/csv.js","webpack://DataModel/./node_modules/d3-dsv/src/dsv.js","webpack://DataModel/./node_modules/d3-dsv/src/index.js","webpack://DataModel/./node_modules/d3-dsv/src/tsv.js","webpack://DataModel/./src/constants/index.js","webpack://DataModel/./src/converter/auto-resolver.js","webpack://DataModel/./src/converter/dsv-arr.js","webpack://DataModel/./src/converter/dsv-str.js","webpack://DataModel/./src/converter/flat-json.js","webpack://DataModel/./src/converter/index.js","webpack://DataModel/./src/datamodel.js","webpack://DataModel/./src/default-config.js","webpack://DataModel/./src/enums/data-format.js","webpack://DataModel/./src/enums/dimension-subtype.js","webpack://DataModel/./src/enums/field-type.js","webpack://DataModel/./src/enums/filtering-mode.js","webpack://DataModel/./src/enums/group-by-functions.js","webpack://DataModel/./src/enums/index.js","webpack://DataModel/./src/enums/measure-subtype.js","webpack://DataModel/./src/export.js","webpack://DataModel/./src/field-creator.js","webpack://DataModel/./src/field-store.js","webpack://DataModel/./src/fields/binned/index.js","webpack://DataModel/./src/fields/categorical/index.js","webpack://DataModel/./src/fields/continuous/index.js","webpack://DataModel/./src/fields/dimension/index.js","webpack://DataModel/./src/fields/field/index.js","webpack://DataModel/./src/fields/index.js","webpack://DataModel/./src/fields/measure/index.js","webpack://DataModel/./src/fields/parsers/binned-parser/index.js","webpack://DataModel/./src/fields/parsers/categorical-parser/index.js","webpack://DataModel/./src/fields/parsers/continuous-parser/index.js","webpack://DataModel/./src/fields/parsers/field-parser/index.js","webpack://DataModel/./src/fields/parsers/temporal-parser/index.js","webpack://DataModel/./src/fields/partial-field/index.js","webpack://DataModel/./src/fields/temporal/index.js","webpack://DataModel/./src/helper.js","webpack://DataModel/./src/index.js","webpack://DataModel/./src/invalid-aware-types.js","webpack://DataModel/./src/operator/bucket-creator.js","webpack://DataModel/./src/operator/compose.js","webpack://DataModel/./src/operator/cross-product.js","webpack://DataModel/./src/operator/data-builder.js","webpack://DataModel/./src/operator/difference.js","webpack://DataModel/./src/operator/get-common-schema.js","webpack://DataModel/./src/operator/group-by-function.js","webpack://DataModel/./src/operator/group-by.js","webpack://DataModel/./src/operator/index.js","webpack://DataModel/./src/operator/merge-sort.js","webpack://DataModel/./src/operator/natural-join-filter-function.js","webpack://DataModel/./src/operator/natural-join.js","webpack://DataModel/./src/operator/outer-join.js","webpack://DataModel/./src/operator/pure-operators.js","webpack://DataModel/./src/operator/row-diffset-iterator.js","webpack://DataModel/./src/operator/union.js","webpack://DataModel/./src/relation.js","webpack://DataModel/./src/stats/index.js","webpack://DataModel/./src/utils/column-major.js","webpack://DataModel/./src/utils/date-time-formatter.js","webpack://DataModel/./src/utils/domain-generator.js","webpack://DataModel/./src/utils/extend2.js","webpack://DataModel/./src/utils/helper.js","webpack://DataModel/./src/utils/index.js","webpack://DataModel/./src/utils/reducer-store.js","webpack://DataModel/./src/value.js"],"names":["csv","dsv","csvParse","parse","csvParseRows","parseRows","csvFormat","format","csvFormatRows","formatRows","EOL","EOF","QUOTE","NEWLINE","RETURN","objectConverter","columns","Function","map","name","i","JSON","stringify","join","customConverter","f","object","row","inferColumns","rows","columnSet","Object","create","forEach","column","push","delimiter","reFormat","RegExp","DELIMITER","charCodeAt","text","convert","N","length","I","n","t","eof","eol","token","j","c","slice","replace","formatValue","concat","formatRow","test","tsv","tsvParse","tsvParseRows","tsvFormat","tsvFormatRows","PROPAGATION","ROW_ID","DM_DERIVATIVES","SELECT","PROJECT","GROUPBY","COMPOSE","CAL_VAR","BIN","SORT","JOINS","CROSS","LEFTOUTER","RIGHTOUTER","NATURAL","FULLOUTER","LOGICAL_OPERATORS","AND","OR","Auto","data","options","converters","FlatJSON","DSVStr","DSVArr","dataFormat","detectDataFormat","Error","arr","defaultOption","firstRowHeader","assign","header","columnMajor","splice","field","str","fieldSeparator","d3Dsv","insertionIndex","item","fields","key","keys","DataModel","args","_onPropagation","defOptions","order","formatter","withUid","getAllFields","sort","getPartialFieldspace","dataGenerated","dataBuilder","call","_rowDiffset","d","_colIdentifier","columnWise","addUid","schema","uids","fieldNames","e","fmtFieldNames","fmtFieldIdx","reduce","acc","next","idx","indexOf","elem","fIdx","fmtFn","datum","datumIdx","undefined","rowDiffset","ids","diffSets","split","set","Number","start","end","Array","fill","_","fieldsArr","reducers","config","saveChild","groupByString","params","newDataModel","groupBy","persistDerivations","defaultReducer","reducerStore","setParent","sortingDetails","rawData","getData","dataInCSVArr","sortedDm","constructor","type","_dataFormat","getFieldspace","colData","formattedData","rowsCount","serializedData","rowIdx","colIdx","DataFormat","FLAT_JSON","DSV_STR","DSV_ARR","fieldName","partialFieldspace","_partialFieldspace","cachedValueObjects","_cachedValueObjects","fieldsObj","obj","partialField","fieldIndex","findIndex","fieldinst","_cachedFieldsObj","_cachedDimension","_cachedMeasure","__calculateFieldspace","calculateFieldsConfig","dependency","sanitizeUnitSchema","replaceVar","fieldsConfig","getFieldsConfig","depVars","retrieveFn","depFieldIndices","fieldSpec","index","clone","fs","suppliedFields","cachedStore","cloneProvider","detachedRoot","computedValues","rowDiffsetIterator","fieldsData","createFields","addField","identifiers","addToNameSpace","propConfig","isMutableAction","propagationSourceId","sourceId","payload","rootModel","getRootDataModel","propagationNameSpace","_propagationNameSpace","rootGroupByModel","getRootGroupByModel","rootModels","groupByModel","model","addToPropNamespace","propagateToAllDataModels","propagateImmutableActions","eventName","callback","propModel","propListeners","fn","measureFieldName","binFieldName","measureField","createBinnedFieldData","binnedData","bins","binField","FieldType","DIMENSION","subtype","DimensionSubtype","BINNED","serialize","getSchema","InvalidAwareTypes","invalidAwareVals","AUTO","CATEGORICAL","TEMPORAL","GEO","MEASURE","FilteringMode","NORMAL","INVERSE","ALL","GROUP_BY_FUNCTIONS","SUM","AVG","MIN","MAX","FIRST","LAST","COUNT","STD","MeasureSubtype","CONTINUOUS","Operators","compose","bin","select","project","calculateVariable","crossProduct","difference","naturalJoin","leftOuterJoin","rightOuterJoin","fullOuterJoin","union","version","pkg","Stats","DateTimeFormatter","createUnitField","createUnitFieldFromPartial","dataColumn","headers","headersObj","fieldStore","createNamespace","fieldArr","dataId","getUniqueId","getMeasure","measureFields","getDimension","dimensionFields","Binned","binsArr","Categorical","hash","Set","domain","has","add","Continuous","min","POSITIVE_INFINITY","max","NEGATIVE_INFINITY","Dimension","_cachedDomain","calculateDataDomain","Field","description","displayName","Measure","unit","defAggFn","numberFormat","BinnedParser","val","regex","String","result","isInvalid","matched","match","parseFloat","NA","getInvalidType","CategoricalParser","trim","ContinuousParser","parsedVal","isNaN","FieldParser","TemporalParser","_dtf","nativeDate","getNativeDate","getTime","PartialField","parser","_sanitize","Temporal","_cachedMinDiff","sortedData","filter","a","b","arrLn","minDiff","prevDatum","nextDatum","processedCount","Math","formatAs","prepareSelectionData","resp","prepareJoinData","updateFields","fieldStoreName","colIdentifier","collID","partialFieldMap","newFields","coll","persistCurrentDerivation","operation","criteriaFn","_derivation","op","meta","criteria","persistAncestorDerivation","sourceDm","newDm","_ancestorDerivation","generateRowDiffset","lastInsertedValue","li","selectHelper","selectFn","newRowDiffSet","rejRowDiffSet","lastInsertedValueRej","mode","selectorHelperFn","checker","passFn","cloneWithAllFields","clonedDm","getKey","len","filterPropagationModel","propModels","fns","filterByMeasure","clonedModel","modelFieldsConfig","dataModel","keyFn","dataObj","dimensions","dLen","indices","measures","fieldsSpace","v","valuesMap","value","present","every","filteredModel","some","cloneWithSelect","selectConfig","cloneConfig","cloned","oDm","rejCloned","cloneWithProject","projField","allFields","projectionSet","actualProjField","unitSchema","extend2","validateUnitSchema","supportedMeasureSubTypes","supportedDimSubTypes","sanitizeAndValidateSchema","resolveFieldName","dataHeader","fieldNameAs","as","updateData","relation","converterFn","converter","nameSpace","valueObjects","fieldInSchema","getDerivationArguments","derivation","applyExistingOperationOnModel","derivations","getDerivations","selectionModel","getFilteredModel","path","propagateIdentifiers","propModelInf","nonTraversingModel","excludeModels","propagate","handlePropagation","children","_children","child","_parent","find","getPathToRootModel","propagationInf","propagateToSource","propagateInterpolatedValues","filterFn","entry","criterias","persistent","actionCriterias","values","mutableActions","filteredCriteria","action","sourceActionCriterias","actionInf","actionConf","applyOnSource","models","sourceIdentifiers","inf","propagationModel","reverse","immutableActions","filterImmutableAction","criteriaModel","sourceNamespace","require","module","exports","default","_invalidAwareValsMap","_value","NULL","NIL","invalid","nil","null","generateBuckets","binSize","buckets","findBucketRange","bucketRanges","leftIdx","rightIdx","midIdx","range","floor","binsCount","dMin","dMax","ceil","abs","unshift","dm","operations","currentDM","firstChild","dispose","defaultFilterFn","dm1","dm2","replaceCommonSchema","jointype","applicableFilterFn","dm1FieldStore","dm2FieldStore","dm1FieldStoreName","dm2FieldStoreName","commonSchemaList","getCommonSchema","tmpSchema","rowAdded","rowPosition","ii","tuple","userArg","cloneProvider1","cloneProvider2","dm1Fields","dm2Fields","tupleObj","cellVal","iii","getSortFn","dataType","sortType","retFunc","a1","b1","groupData","hashMap","Map","groupedData","fieldVal","get","createSortingFnArg","groupedDatum","targetFields","targetFieldDetails","arg","label","sortData","sortMeta","fDetails","isCallable","mergeSort","isArray","sortingFn","m","toLowerCase","pop","retObj","reqSorting","tmpDataArr","colIArr","colName","insertInd","tmpData","hashTable","schemaNameArr","dm1FieldStoreFieldObj","dm2FieldStoreFieldObj","isArrEqual","prepareDataHelper","addData","hashData","schemaName","fs1","fs2","retArr","fs1Arr","getFilteredValues","sum","filteredNumber","totalSum","curr","avg","filteredValues","first","last","count","variance","mean","num","std","sqrt","fnList","defaultReducerName","getFieldArr","entries","getReducerObj","defReducer","measureName","reducerFn","resolve","existingDataModel","sFieldArr","reducerObj","fieldStoreObj","dbName","dimensionArr","measureArr","rowCount","defSortFn","merge","lo","mid","hi","sortFn","mainArr","auxArr","naturalJoinFilter","commonSchemaArr","retainTuple","dataModel1","dataModel2","rowDiffArr","diffStr","diffStsArr","Relation","source","_fieldStoreName","_fieldspace","joinWith","unionWith","differenceWith","defConfig","fieldConfig","normalizedProjField","search","from","projectionClone","rejectionClone","_fieldConfig","fieldObj","def","removeChild","sibling","parent","sd","store","convertToNativeDate","date","Date","pad","escape","dtParams","TOKEN_PREFIX","DATETIME_PARAM_SEQUENCE","YEAR","MONTH","DAY","HOUR","MINUTE","SECOND","MILLISECOND","defaultNumberParser","defVal","isFinite","parseInt","defaultRangeParser","l","nVal","getTokenDefinitions","daysDef","short","long","monthsDef","definitions","H","extract","getHours","toString","hours","p","P","M","mins","getMinutes","S","seconds","getSeconds","K","ms","getMilliseconds","day","getDay","A","getDate","month","getMonth","B","y","substring","presentDate","presentYear","trunc","getFullYear","year","Y","getTokenFormalNames","HOUR_12","AMPM_UPPERCASE","AMPM_LOWERCASE","SHORT_DAY","LONG_DAY","DAY_OF_MONTH","DAY_OF_MONTH_CONSTANT_WIDTH","SHORT_MONTH","LONG_MONTH","MONTH_OF_YEAR","SHORT_YEAR","LONG_YEAR","tokenResolver","defaultResolver","targetParam","hourFormat24","hourFormat12","ampmLower","ampmUpper","amOrpm","isPM","findTokens","tokenPrefix","tokenLiterals","occurrence","forwardChar","nDate","formattedStr","formattedVal","prototype","dateTimeStamp","extractTokenValue","dtParamSeq","noBreak","dtParamArr","resolverKey","resolverParams","resolverFn","param","resolvedVal","hasOwnProperty","apply","checkIfOnlyYear","tokenObj","lastOccurrenceIndex","occObj","occIndex","targetText","regexFormat","tokenArr","occurrenceLength","extractValues","shift","OBJECTSTRING","objectToStrFn","objectToStr","arrayToStr","checkCyclicRef","parentArr","bIndex","obj1","obj2","skipUndef","tgtArr","srcArr","srcVal","tgtVal","cRef","isObject","isString","uniqueValues","round","random","arr1","arr2","formatNumber","ReducerStore","reducer","__unregister","delete","getStore","Value","defineProperty","enumerable","configurable","writable"],"mappings":"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","file":"datamodel.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"DataModel\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"DataModel\"] = factory();\n\telse\n\t\troot[\"DataModel\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","import dsv from \"./dsv\";\n\nvar csv = dsv(\",\");\n\nexport var csvParse = csv.parse;\nexport var csvParseRows = csv.parseRows;\nexport var csvFormat = csv.format;\nexport var csvFormatRows = csv.formatRows;\n","var EOL = {},\n    EOF = {},\n    QUOTE = 34,\n    NEWLINE = 10,\n    RETURN = 13;\n\nfunction objectConverter(columns) {\n  return new Function(\"d\", \"return {\" + columns.map(function(name, i) {\n    return JSON.stringify(name) + \": d[\" + i + \"]\";\n  }).join(\",\") + \"}\");\n}\n\nfunction customConverter(columns, f) {\n  var object = objectConverter(columns);\n  return function(row, i) {\n    return f(object(row), i, columns);\n  };\n}\n\n// Compute unique columns in order of discovery.\nfunction inferColumns(rows) {\n  var columnSet = Object.create(null),\n      columns = [];\n\n  rows.forEach(function(row) {\n    for (var column in row) {\n      if (!(column in columnSet)) {\n        columns.push(columnSet[column] = column);\n      }\n    }\n  });\n\n  return columns;\n}\n\nexport default function(delimiter) {\n  var reFormat = new RegExp(\"[\\\"\" + delimiter + \"\\n\\r]\"),\n      DELIMITER = delimiter.charCodeAt(0);\n\n  function parse(text, f) {\n    var convert, columns, rows = parseRows(text, function(row, i) {\n      if (convert) return convert(row, i - 1);\n      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);\n    });\n    rows.columns = columns || [];\n    return rows;\n  }\n\n  function parseRows(text, f) {\n    var rows = [], // output rows\n        N = text.length,\n        I = 0, // current character index\n        n = 0, // current line number\n        t, // current token\n        eof = N <= 0, // current token followed by EOF?\n        eol = false; // current token followed by EOL?\n\n    // Strip the trailing newline.\n    if (text.charCodeAt(N - 1) === NEWLINE) --N;\n    if (text.charCodeAt(N - 1) === RETURN) --N;\n\n    function token() {\n      if (eof) return EOF;\n      if (eol) return eol = false, EOL;\n\n      // Unescape quotes.\n      var i, j = I, c;\n      if (text.charCodeAt(j) === QUOTE) {\n        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);\n        if ((i = I) >= N) eof = true;\n        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;\n        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }\n        return text.slice(j + 1, i - 1).replace(/\"\"/g, \"\\\"\");\n      }\n\n      // Find next delimiter or newline.\n      while (I < N) {\n        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;\n        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }\n        else if (c !== DELIMITER) continue;\n        return text.slice(j, i);\n      }\n\n      // Return last token before EOF.\n      return eof = true, text.slice(j, N);\n    }\n\n    while ((t = token()) !== EOF) {\n      var row = [];\n      while (t !== EOL && t !== EOF) row.push(t), t = token();\n      if (f && (row = f(row, n++)) == null) continue;\n      rows.push(row);\n    }\n\n    return rows;\n  }\n\n  function format(rows, columns) {\n    if (columns == null) columns = inferColumns(rows);\n    return [columns.map(formatValue).join(delimiter)].concat(rows.map(function(row) {\n      return columns.map(function(column) {\n        return formatValue(row[column]);\n      }).join(delimiter);\n    })).join(\"\\n\");\n  }\n\n  function formatRows(rows) {\n    return rows.map(formatRow).join(\"\\n\");\n  }\n\n  function formatRow(row) {\n    return row.map(formatValue).join(delimiter);\n  }\n\n  function formatValue(text) {\n    return text == null ? \"\"\n        : reFormat.test(text += \"\") ? \"\\\"\" + text.replace(/\"/g, \"\\\"\\\"\") + \"\\\"\"\n        : text;\n  }\n\n  return {\n    parse: parse,\n    parseRows: parseRows,\n    format: format,\n    formatRows: formatRows\n  };\n}\n","export {default as dsvFormat} from \"./dsv\";\nexport {csvParse, csvParseRows, csvFormat, csvFormatRows} from \"./csv\";\nexport {tsvParse, tsvParseRows, tsvFormat, tsvFormatRows} from \"./tsv\";\n","import dsv from \"./dsv\";\n\nvar tsv = dsv(\"\\t\");\n\nexport var tsvParse = tsv.parse;\nexport var tsvParseRows = tsv.parseRows;\nexport var tsvFormat = tsv.format;\nexport var tsvFormatRows = tsv.formatRows;\n","export { DataFormat, FilteringMode } from '../enums';\n/**\n * The event name for data propagation.\n */\nexport const PROPAGATION = 'propagation';\n\n/**\n * The name of the unique row id column in DataModel.\n */\nexport const ROW_ID = '__id__';\n\n/**\n * The enums for operation names performed on DataModel.\n */\nexport const DM_DERIVATIVES = {\n    SELECT: 'select',\n    PROJECT: 'project',\n    GROUPBY: 'group',\n    COMPOSE: 'compose',\n    CAL_VAR: 'calculatedVariable',\n    BIN: 'bin',\n    SORT: 'sort'\n};\n\nexport const JOINS = {\n    CROSS: 'cross',\n    LEFTOUTER: 'leftOuter',\n    RIGHTOUTER: 'rightOuter',\n    NATURAL: 'natural',\n    FULLOUTER: 'fullOuter'\n};\n\nexport const LOGICAL_OPERATORS = {\n    AND: 'and',\n    OR: 'or'\n};\n","import FlatJSON from './flat-json';\nimport DSVArr from './dsv-arr';\nimport DSVStr from './dsv-str';\nimport { detectDataFormat } from '../utils';\n\n/**\n * Parses the input data and detect the format automatically.\n *\n * @param {string|Array} data - The input data.\n * @param {Object} options - An optional config specific to data format.\n * @return {Array.<Object>} Returns an array of headers and column major data.\n */\nfunction Auto (data, options) {\n    const converters = { FlatJSON, DSVStr, DSVArr };\n    const dataFormat = detectDataFormat(data);\n\n    if (!dataFormat) {\n        throw new Error('Couldn\\'t detect the data format');\n    }\n\n    return converters[dataFormat](data, options);\n}\n\nexport default Auto;\n","import { columnMajor } from '../utils';\n\n/**\n * Parses and converts data formatted in DSV array to a manageable internal format.\n *\n * @param {Array.<Array>} arr - A 2D array containing of the DSV data.\n * @param {Object} options - Option to control the behaviour of the parsing.\n * @param {boolean} [options.firstRowHeader=true] - Whether the first row of the dsv data is header or not.\n * @return {Array} Returns an array of headers and column major data.\n * @example\n *\n * // Sample input data:\n * const data = [\n *    [\"a\", \"b\", \"c\"],\n *    [1, 2, 3],\n *    [4, 5, 6],\n *    [7, 8, 9]\n * ];\n */\nfunction DSVArr (arr, options) {\n    const defaultOption = {\n        firstRowHeader: true,\n    };\n    options = Object.assign({}, defaultOption, options);\n\n    let header;\n    const columns = [];\n    const push = columnMajor(columns);\n\n    if (options.firstRowHeader) {\n        // If header present then mutate the array.\n        // Do in-place mutation to save space.\n        header = arr.splice(0, 1)[0];\n    } else {\n        header = [];\n    }\n\n    arr.forEach(field => push(...field));\n\n    return [header, columns];\n}\n\nexport default DSVArr;\n","import { dsvFormat as d3Dsv } from 'd3-dsv';\nimport DSVArr from './dsv-arr';\n\n/**\n * Parses and converts data formatted in DSV string to a manageable internal format.\n *\n * @todo Support to be given for https://tools.ietf.org/html/rfc4180.\n * @todo Sample implementation https://github.com/knrz/CSV.js/.\n *\n * @param {string} str - The input DSV string.\n * @param {Object} options - Option to control the behaviour of the parsing.\n * @param {boolean} [options.firstRowHeader=true] - Whether the first row of the dsv string data is header or not.\n * @param {string} [options.fieldSeparator=\",\"] - The separator of two consecutive field.\n * @return {Array} Returns an array of headers and column major data.\n * @example\n *\n * // Sample input data:\n * const data = `\n * a,b,c\n * 1,2,3\n * 4,5,6\n * 7,8,9\n * `\n */\nfunction DSVStr (str, options) {\n    const defaultOption = {\n        firstRowHeader: true,\n        fieldSeparator: ','\n    };\n    options = Object.assign({}, defaultOption, options);\n\n    const dsv = d3Dsv(options.fieldSeparator);\n    return DSVArr(dsv.parseRows(str), options);\n}\n\nexport default DSVStr;\n","import { columnMajor } from '../utils';\n\n/**\n * Parses and converts data formatted in JSON to a manageable internal format.\n *\n * @param {Array.<Object>} arr - The input data formatted in JSON.\n * @return {Array.<Object>} Returns an array of headers and column major data.\n * @example\n *\n * // Sample input data:\n * const data = [\n *    {\n *      \"a\": 1,\n *      \"b\": 2,\n *      \"c\": 3\n *    },\n *    {\n *      \"a\": 4,\n *      \"b\": 5,\n *      \"c\": 6\n *    },\n *    {\n *      \"a\": 7,\n *      \"b\": 8,\n *      \"c\": 9\n *    }\n * ];\n */\nfunction FlatJSON (arr) {\n    const header = {};\n    let i = 0;\n    let insertionIndex;\n    const columns = [];\n    const push = columnMajor(columns);\n\n    arr.forEach((item) => {\n        const fields = [];\n        for (let key in item) {\n            if (key in header) {\n                insertionIndex = header[key];\n            } else {\n                header[key] = i++;\n                insertionIndex = i - 1;\n            }\n            fields[insertionIndex] = item[key];\n        }\n        push(...fields);\n    });\n\n    return [Object.keys(header), columns];\n}\n\nexport default FlatJSON;\n","export { default as DSVArr } from './dsv-arr';\nexport { default as DSVStr } from './dsv-str';\nexport { default as FlatJSON } from './flat-json';\nexport { default as Auto } from './auto-resolver';\n","/* eslint-disable default-case */\n\nimport { FieldType, DimensionSubtype, DataFormat } from './enums';\nimport {\n    persistDerivations,\n    getRootGroupByModel,\n    propagateToAllDataModels,\n    getRootDataModel,\n    propagateImmutableActions,\n    addToPropNamespace,\n    sanitizeUnitSchema\n} from './helper';\nimport { DM_DERIVATIVES, PROPAGATION } from './constants';\nimport {\n    dataBuilder,\n    rowDiffsetIterator,\n    groupBy\n} from './operator';\nimport { createBinnedFieldData } from './operator/bucket-creator';\nimport Relation from './relation';\nimport reducerStore from './utils/reducer-store';\nimport { createFields } from './field-creator';\nimport InvalidAwareTypes from './invalid-aware-types';\nimport Value from './value';\n\n/**\n * DataModel is an in-browser representation of tabular data. It supports\n * {@link https://en.wikipedia.org/wiki/Relational_algebra | relational algebra} operators as well as generic data\n * processing opearators.\n * DataModel extends {@link Relation} class which defines all the relational algebra opreators. DataModel gives\n * definition of generic data processing operators which are not relational algebra complient.\n *\n * @public\n * @class\n * @extends Relation\n * @memberof Datamodel\n */\nclass DataModel extends Relation {\n    /**\n     * Creates a new DataModel instance by providing data and schema. Data could be in the form of\n     * - Flat JSON\n     * - DSV String\n     * - 2D Array\n     *\n     * By default DataModel finds suitable adapter to serialize the data. DataModel also expects a\n     * {@link Schema | schema} for identifying the variables present in data.\n     *\n     * @constructor\n     * @example\n     * const data = loadData('cars.csv');\n     * const schema = [\n     *      { name: 'Name', type: 'dimension' },\n     *      { name: 'Miles_per_Gallon', type: 'measure', unit : 'cm', scale: '1000', numberformat: val => `${val}G`},\n     *      { name: 'Cylinders', type: 'dimension' },\n     *      { name: 'Displacement', type: 'measure' },\n     *      { name: 'Horsepower', type: 'measure' },\n     *      { name: 'Weight_in_lbs', type: 'measure' },\n     *      { name: 'Acceleration', type: 'measure' },\n     *      { name: 'Year', type: 'dimension', subtype: 'datetime', format: '%Y' },\n     *      { name: 'Origin', type: 'dimension' }\n     * ];\n     * const dm = new DataModel(data, schema, { name: 'Cars' });\n     * table(dm);\n     *\n     * @public\n     *\n     * @param {Array.<Object> | string | Array.<Array>} data Input data in any of the mentioned formats\n     * @param {Array.<Schema>} schema Defination of the variables. Order of the variables in data and order of the\n     *      variables in schema has to be same.\n     * @param {object} [options] Optional arguments to specify more settings regarding the creation part\n     * @param {string} [options.name] Name of the datamodel instance. If no name is given an auto generated name is\n     *      assigned to the instance.\n     * @param {string} [options.fieldSeparator=','] specify field separator type if the data is of type dsv string.\n     */\n    constructor (...args) {\n        super(...args);\n\n        this._onPropagation = [];\n    }\n\n    /**\n     * Reducers are simple functions which reduces an array of numbers to a representative number of the set.\n     * Like an array of numbers `[10, 20, 5, 15]` can be reduced to `12.5` if average / mean reducer function is\n     * applied. All the measure fields in datamodel (variables in data) needs a reducer to handle aggregation.\n     *\n     * @public\n     *\n     * @return {ReducerStore} Singleton instance of {@link ReducerStore}.\n     */\n    static get Reducers () {\n        return reducerStore;\n    }\n\n    /**\n     * Configure null, undefined, invalid values in the source data\n     *\n     * @public\n     *\n     * @param {Object} [config] - Configuration to control how null, undefined and non-parsable values are\n     * represented in DataModel.\n     * @param {string} [config.undefined] - Define how an undefined value will be represented.\n     * @param {string} [config.null] - Define how a null value will be represented.\n     * @param {string} [config.invalid] - Define how a non-parsable value will be represented.\n     */\n    static configureInvalidAwareTypes (config) {\n        return InvalidAwareTypes.invalidAwareVals(config);\n    }\n\n    /**\n     * Retrieve the data attached to an instance in JSON format.\n     *\n     * @example\n     * // DataModel instance is already prepared and assigned to dm variable\n     *  const data = dm.getData({\n     *      order: 'column',\n     *      formatter: {\n     *          origin: (val) => val === 'European Union' ? 'EU' : val;\n     *      }\n     *  });\n     *  console.log(data);\n     *\n     * @public\n     *\n     * @param {Object} [options] Options to control how the raw data is to be returned.\n     * @param {string} [options.order='row'] Defines if data is retieved in row order or column order. Possible values\n     *      are `'rows'` and `'columns'`\n     * @param {Function} [options.formatter=null] Formats the output data. This expects an object, where the keys are\n     *      the name of the variable needs to be formatted. The formatter function is called for each row passing the\n     *      value of the cell for a particular row as arguments. The formatter is a function in the form of\n     *      `function (value, rowId, schema) => { ... }`\n     *      Know more about {@link Fomatter}.\n     *\n     * @return {Array} Returns a multidimensional array of the data with schema. The return format looks like\n     *      ```\n     *          {\n     *              data,\n     *              schema\n     *          }\n     *      ```\n     */\n    getData (options) {\n        const defOptions = {\n            order: 'row',\n            formatter: null,\n            withUid: false,\n            getAllFields: false,\n            sort: []\n        };\n        options = Object.assign({}, defOptions, options);\n        const fields = this.getPartialFieldspace().fields;\n\n        const dataGenerated = dataBuilder.call(\n            this,\n            this.getPartialFieldspace().fields,\n            this._rowDiffset,\n            options.getAllFields ? fields.map(d => d.name()).join() : this._colIdentifier,\n            options.sort,\n            {\n                columnWise: options.order === 'column',\n                addUid: !!options.withUid\n            }\n        );\n\n        if (!options.formatter) {\n            return dataGenerated;\n        }\n\n        const { formatter } = options;\n        const { data, schema, uids } = dataGenerated;\n        const fieldNames = schema.map((e => e.name));\n        const fmtFieldNames = Object.keys(formatter);\n        const fmtFieldIdx = fmtFieldNames.reduce((acc, next) => {\n            const idx = fieldNames.indexOf(next);\n            if (idx !== -1) {\n                acc.push([idx, formatter[next]]);\n            }\n            return acc;\n        }, []);\n\n        if (options.order === 'column') {\n            fmtFieldIdx.forEach((elem) => {\n                const fIdx = elem[0];\n                const fmtFn = elem[1];\n\n                data[fIdx].forEach((datum, datumIdx) => {\n                    data[fIdx][datumIdx] = fmtFn.call(\n                        undefined,\n                        datum,\n                        uids[datumIdx],\n                        schema[fIdx]\n                    );\n                });\n            });\n        } else {\n            data.forEach((datum, datumIdx) => {\n                fmtFieldIdx.forEach((elem) => {\n                    const fIdx = elem[0];\n                    const fmtFn = elem[1];\n\n                    datum[fIdx] = fmtFn.call(\n                        undefined,\n                        datum[fIdx],\n                        uids[datumIdx],\n                        schema[fIdx]\n                    );\n                });\n            });\n        }\n\n        return dataGenerated;\n    }\n\n    /**\n     * Returns the unique ids in an array.\n     *\n     * @return {Array} Returns an array of ids.\n     */\n    getUids () {\n        const rowDiffset = this._rowDiffset;\n        const ids = [];\n\n        if (rowDiffset.length) {\n            const diffSets = rowDiffset.split(',');\n\n            diffSets.forEach((set) => {\n                let [start, end] = set.split('-').map(Number);\n\n                end = end !== undefined ? end : start;\n                ids.push(...Array(end - start + 1).fill().map((_, idx) => start + idx));\n            });\n        }\n\n        return ids;\n    }\n    /**\n     * Groups the data using particular dimensions and by reducing measures. It expects a list of dimensions using which\n     * it projects the datamodel and perform aggregations to reduce the duplicate tuples. Refer this\n     * {@link link_to_one_example_with_group_by | document} to know the intuition behind groupBy.\n     *\n     * DataModel by default provides definition of few {@link reducer | Reducers}.\n     * {@link ReducerStore | User defined reducers} can also be registered.\n     *\n     * This is the chained implementation of `groupBy`.\n     * `groupBy` also supports {@link link_to_compose_groupBy | composability}\n     *\n     * @example\n     * const groupedDM = dm.groupBy(['Year'], { horsepower: 'max' } );\n     * console.log(groupedDm);\n     *\n     * @public\n     *\n     * @param {Array.<string>} fieldsArr - Array containing the name of dimensions\n     * @param {Object} [reducers={}] - A map whose key is the variable name and value is the name of the reducer. If its\n     *      not passed, or any variable is ommitted from the object, default aggregation function is used from the\n     *      schema of the variable.\n     *\n     * @return {DataModel} Returns a new DataModel instance after performing the groupby.\n     */\n    groupBy (fieldsArr, reducers = {}, config = { saveChild: true }) {\n        const groupByString = `${fieldsArr.join()}`;\n        let params = [this, fieldsArr, reducers];\n        const newDataModel = groupBy(...params);\n\n        persistDerivations(\n            this,\n            newDataModel,\n            DM_DERIVATIVES.GROUPBY,\n            { fieldsArr, groupByString, defaultReducer: reducerStore.defaultReducer() },\n            reducers\n        );\n\n        if (config.saveChild) {\n            newDataModel.setParent(this);\n        } else {\n            newDataModel.setParent(null);\n        }\n\n        return newDataModel;\n    }\n\n    /**\n     * Performs sorting operation on the current {@link DataModel} instance according to the specified sorting details.\n     * Like every other operator it doesn't mutate the current DataModel instance on which it was called, instead\n     * returns a new DataModel instance containing the sorted data.\n     *\n     * DataModel support multi level sorting by listing the variables using which sorting needs to be performed and\n     * the type of sorting `ASC` or `DESC`.\n     *\n     * In the following example, data is sorted by `Origin` field in `DESC` order in first level followed by another\n     * level of sorting by `Acceleration` in `ASC` order.\n     *\n     * @example\n     * // here dm is the pre-declared DataModel instance containing the data of 'cars.json' file\n     * let sortedDm = dm.sort([\n     *    [\"Origin\", \"DESC\"]\n     *    [\"Acceleration\"] // Default value is ASC\n     * ]);\n     *\n     * console.log(dm.getData());\n     * console.log(sortedDm.getData());\n     *\n     * // Sort with a custom sorting function\n     * sortedDm = dm.sort([\n     *    [\"Origin\", \"DESC\"]\n     *    [\"Acceleration\", (a, b) => a - b] // Custom sorting function\n     * ]);\n     *\n     * console.log(dm.getData());\n     * console.log(sortedDm.getData());\n     *\n     * @text\n     * DataModel also provides another sorting mechanism out of the box where sort is applied to a variable using\n     * another variable which determines the order.\n     * Like the above DataModel contains three fields `Origin`, `Name` and `Acceleration`. Now, the data in this\n     * model can be sorted by `Origin` field according to the average value of all `Acceleration` for a\n     * particular `Origin` value.\n     *\n     * @example\n     * // here dm is the pre-declared DataModel instance containing the data of 'cars.json' file\n     * const sortedDm = dm.sort([\n     *     ['Origin', ['Acceleration', (a, b) => avg(...a.Acceleration) - avg(...b.Acceleration)]]\n     * ]);\n     *\n     * console.log(dm.getData());\n     * console.log(sortedDm.getData());\n     *\n     * @public\n     *\n     * @param {Array.<Array>} sortingDetails - Sorting details based on which the sorting will be performed.\n     * @return {DataModel} Returns a new instance of DataModel with sorted data.\n     */\n    sort (sortingDetails, config = { saveChild: false }) {\n        const rawData = this.getData({\n            order: 'row',\n            sort: sortingDetails\n        });\n        const header = rawData.schema.map(field => field.name);\n        const dataInCSVArr = [header].concat(rawData.data);\n\n        const sortedDm = new this.constructor(dataInCSVArr, rawData.schema, { dataFormat: 'DSVArr' });\n\n        persistDerivations(\n            this,\n            sortedDm,\n            DM_DERIVATIVES.SORT,\n            config,\n            sortingDetails\n        );\n\n        if (config.saveChild) {\n            sortedDm.setParent(this);\n        } else {\n            sortedDm.setParent(null);\n        }\n\n        return sortedDm;\n    }\n\n    /**\n     * Performs the serialization operation on the current {@link DataModel} instance according to the specified data\n     * type. When an {@link DataModel} instance is created, it de-serializes the input data into its internal format,\n     * and during its serialization process, it converts its internal data format to the specified data type and returns\n     * that data regardless what type of data is used during the {@link DataModel} initialization.\n     *\n     * @example\n     * // here dm is the pre-declared DataModel instance.\n     * const csvData = dm.serialize(DataModel.DataFormat.DSV_STR, { fieldSeparator: \",\" });\n     * console.log(csvData); // The csv formatted data.\n     *\n     * const jsonData = dm.serialize(DataModel.DataFormat.FLAT_JSON);\n     * console.log(jsonData); // The json data.\n     *\n     * @public\n     *\n     * @param {string} type - The data type name for serialization.\n     * @param {Object} options - The optional option object.\n     * @param {string} options.fieldSeparator - The field separator character for DSV data type.\n     * @return {Array|string} Returns the serialized data.\n     */\n    serialize (type, options) {\n        type = type || this._dataFormat;\n        options = Object.assign({}, { fieldSeparator: ',' }, options);\n\n        const fields = this.getFieldspace().fields;\n        const colData = fields.map(f => f.formattedData());\n        const rowsCount = colData[0].length;\n        let serializedData;\n        let rowIdx;\n        let colIdx;\n\n        if (type === DataFormat.FLAT_JSON) {\n            serializedData = [];\n            for (rowIdx = 0; rowIdx < rowsCount; rowIdx++) {\n                const row = {};\n                for (colIdx = 0; colIdx < fields.length; colIdx++) {\n                    row[fields[colIdx].name()] = colData[colIdx][rowIdx];\n                }\n                serializedData.push(row);\n            }\n        } else if (type === DataFormat.DSV_STR) {\n            serializedData = [fields.map(f => f.name()).join(options.fieldSeparator)];\n            for (rowIdx = 0; rowIdx < rowsCount; rowIdx++) {\n                const row = [];\n                for (colIdx = 0; colIdx < fields.length; colIdx++) {\n                    row.push(colData[colIdx][rowIdx]);\n                }\n                serializedData.push(row.join(options.fieldSeparator));\n            }\n            serializedData = serializedData.join('\\n');\n        } else if (type === DataFormat.DSV_ARR) {\n            serializedData = [fields.map(f => f.name())];\n            for (rowIdx = 0; rowIdx < rowsCount; rowIdx++) {\n                const row = [];\n                for (colIdx = 0; colIdx < fields.length; colIdx++) {\n                    row.push(colData[colIdx][rowIdx]);\n                }\n                serializedData.push(row);\n            }\n        } else {\n            throw new Error(`Data type ${type} is not supported`);\n        }\n\n        return serializedData;\n    }\n\n    addField (field) {\n        const fieldName = field.name();\n        this._colIdentifier += `,${fieldName}`;\n        const partialFieldspace = this._partialFieldspace;\n        const cachedValueObjects = partialFieldspace._cachedValueObjects;\n\n        if (!partialFieldspace.fieldsObj()[field.name()]) {\n            partialFieldspace.fields.push(field);\n            cachedValueObjects.forEach((obj, i) => {\n                obj[field.name()] = new Value(field.partialField.data[i], field);\n            });\n        } else {\n            const fieldIndex = partialFieldspace.fields.findIndex(fieldinst => fieldinst.name() === fieldName);\n            fieldIndex >= 0 && (partialFieldspace.fields[fieldIndex] = field);\n        }\n\n        // flush out cached namespace values on addition of new fields\n        partialFieldspace._cachedFieldsObj = null;\n        partialFieldspace._cachedDimension = null;\n        partialFieldspace._cachedMeasure = null;\n\n        this.__calculateFieldspace().calculateFieldsConfig();\n        return this;\n    }\n\n    /**\n    * Creates a new variable calculated from existing variables. This method expects the definition of the newly created\n    * variable and a function which resolves the value of the new variable from existing variables.\n    *\n    * Can create a new measure based on existing variables:\n    * @example\n    *  // DataModel already prepared and assigned to dm variable;\n    *  const newDm = dataModel.calculateVariable({\n    *      name: 'powerToWeight',\n    *      type: 'measure'\n    *  }, ['horsepower', 'weight_in_lbs', (hp, weight) => hp / weight ]);\n    *\n    *\n    * Can create a new dimension based on existing variables:\n    * @example\n    *  // DataModel already prepared and assigned to dm variable;\n    *  const child = dataModel.calculateVariable(\n    *     {\n    *       name: 'Efficiency',\n    *       type: 'dimension'\n    *     }, ['horsepower', (hp) => {\n    *      if (hp < 80) { return 'low'; },\n    *      else if (hp < 120) { return 'moderate'; }\n    *      else { return 'high' }\n    *  }]);\n    *\n    * @public\n    *\n    * @param {Object} schema - The schema of newly defined variable.\n    * @param {Array.<string|function>} dependency - An array containing the dependency variable names and a resolver\n    * function as the last element.\n    * @param {Object} config - An optional config object.\n    * @param {boolean} [config.saveChild] - Whether the newly created DataModel will be a child.\n    * @param {boolean} [config.replaceVar] - Whether the newly created variable will replace the existing variable.\n    * @return {DataModel} Returns an instance of DataModel with the new field.\n    */\n    calculateVariable (schema, dependency, config) {\n        schema = sanitizeUnitSchema(schema);\n        config = Object.assign({}, { saveChild: true, replaceVar: false }, config);\n\n        const fieldsConfig = this.getFieldsConfig();\n        const depVars = dependency.slice(0, dependency.length - 1);\n        const retrieveFn = dependency[dependency.length - 1];\n\n        if (fieldsConfig[schema.name] && !config.replaceVar) {\n            throw new Error(`${schema.name} field already exists in datamodel`);\n        }\n\n        const depFieldIndices = depVars.map((field) => {\n            const fieldSpec = fieldsConfig[field];\n            if (!fieldSpec) {\n                // @todo dont throw error here, use warning in production mode\n                throw new Error(`${field} is not a valid column name.`);\n            }\n            return fieldSpec.index;\n        });\n\n        const clone = this.clone(config.saveChild);\n\n        const fs = clone.getFieldspace().fields;\n        const suppliedFields = depFieldIndices.map(idx => fs[idx]);\n\n        let cachedStore = {};\n        let cloneProvider = () => this.detachedRoot();\n\n        const computedValues = [];\n        rowDiffsetIterator(clone._rowDiffset, (i) => {\n            const fieldsData = suppliedFields.map(field => field.partialField.data[i]);\n            computedValues[i] = retrieveFn(...fieldsData, i, cloneProvider, cachedStore);\n        });\n        const [field] = createFields([computedValues], [schema], [schema.name]);\n        clone.addField(field);\n\n        persistDerivations(\n            this,\n            clone,\n            DM_DERIVATIVES.CAL_VAR,\n            { config: schema, fields: depVars },\n            retrieveFn\n        );\n\n        return clone;\n    }\n\n    /**\n     * Propagates changes across all the connected DataModel instances.\n     *\n     * @param {Array} identifiers - A list of identifiers that were interacted with.\n     * @param {Object} payload - The interaction specific details.\n     *\n     * @return {DataModel} DataModel instance.\n     */\n    propagate (identifiers, config = {}, addToNameSpace, propConfig = {}) {\n        const isMutableAction = config.isMutableAction;\n        const propagationSourceId = config.sourceId;\n        const payload = config.payload;\n        const rootModel = getRootDataModel(this);\n        const propagationNameSpace = rootModel._propagationNameSpace;\n        const rootGroupByModel = getRootGroupByModel(this);\n        const rootModels = {\n            groupByModel: rootGroupByModel,\n            model: rootModel\n        };\n\n        addToNameSpace && addToPropNamespace(propagationNameSpace, config, this);\n        propagateToAllDataModels(identifiers, rootModels, { propagationNameSpace, sourceId: propagationSourceId },\n            Object.assign({\n                payload\n            }, config));\n\n        if (isMutableAction) {\n            propagateImmutableActions(propagationNameSpace, rootModels, {\n                config,\n                propConfig\n            }, this);\n        }\n\n        return this;\n    }\n\n    /**\n     * Associates a callback with an event name.\n     *\n     * @param {string} eventName - The name of the event.\n     * @param {Function} callback - The callback to invoke.\n     * @return {DataModel} Returns this current DataModel instance itself.\n     */\n    on (eventName, callback) {\n        switch (eventName) {\n        case PROPAGATION:\n            this._onPropagation.push(callback);\n            break;\n        }\n        return this;\n    }\n\n    /**\n     * Unsubscribes the callbacks for the provided event name.\n     *\n     * @param {string} eventName - The name of the event to unsubscribe.\n     * @return {DataModel} Returns the current DataModel instance itself.\n     */\n    unsubscribe (eventName) {\n        switch (eventName) {\n        case PROPAGATION:\n            this._onPropagation = [];\n            break;\n\n        }\n        return this;\n    }\n\n    /**\n     * This method is used to invoke the method associated with propagation.\n     *\n     * @param {Object} payload The interaction payload.\n     * @param {DataModel} identifiers The propagated DataModel.\n     * @memberof DataModel\n     */\n    handlePropagation (propModel, payload) {\n        let propListeners = this._onPropagation;\n        propListeners.forEach(fn => fn.call(this, propModel, payload));\n    }\n\n    /**\n     * Performs the binning operation on a measure field based on the binning configuration. Binning means discretizing\n     * values of a measure. Binning configuration contains an array; subsequent values from the array marks the boundary\n     * of buckets in [inclusive, exclusive) range format. This operation does not mutate the subject measure field,\n     * instead, it creates a new field (variable) of type dimension and subtype binned.\n     *\n     * Binning can be configured by\n     * - providing custom bin configuration with non-uniform buckets,\n     * - providing bins count,\n     * - providing each bin size,\n     *\n     * When custom `buckets` are provided as part of binning configuration:\n     * @example\n     *  // DataModel already prepared and assigned to dm variable\n     *  const config = { name: 'binnedHP', buckets: [30, 80, 100, 110] }\n     *  const binnedDM = dataModel.bin('horsepower', config);\n     *\n     * @text\n     * When `binsCount` is defined as part of binning configuration:\n     * @example\n     *  // DataModel already prepared and assigned to dm variable\n     *  const config = { name: 'binnedHP', binsCount: 5, start: 0, end: 100 }\n     *  const binDM = dataModel.bin('horsepower', config);\n     *\n     * @text\n     * When `binSize` is defined as part of binning configuration:\n     * @example\n     *  // DataModel already prepared and assigned to dm variable\n     *  const config = { name: 'binnedHorsepower', binSize: 20, start: 5}\n     *  const binDM = dataModel.bin('horsepower', config);\n     *\n     * @public\n     *\n     * @param {string} measureFieldName - The name of the target measure field.\n     * @param {Object} config - The config object.\n     * @param {string} [config.name] - The name of the new field which will be created.\n     * @param {string} [config.buckets] - An array containing the bucket ranges.\n     * @param {string} [config.binSize] - The size of each bin. It is ignored when buckets are given.\n     * @param {string} [config.binsCount] - The total number of bins to generate. It is ignored when buckets are given.\n     * @param {string} [config.start] - The start value of the bucket ranges. It is ignored when buckets are given.\n     * @param {string} [config.end] - The end value of the bucket ranges. It is ignored when buckets are given.\n     * @return {DataModel} Returns a new {@link DataModel} instance with the new field.\n     */\n    bin (measureFieldName, config) {\n        const fieldsConfig = this.getFieldsConfig();\n\n        if (!fieldsConfig[measureFieldName]) {\n            throw new Error(`Field ${measureFieldName} doesn't exist`);\n        }\n\n        const binFieldName = config.name || `${measureFieldName}_binned`;\n\n        if (fieldsConfig[binFieldName]) {\n            throw new Error(`Field ${binFieldName} already exists`);\n        }\n\n        const measureField = this.getFieldspace().fieldsObj()[measureFieldName];\n        const { binnedData, bins } = createBinnedFieldData(measureField, this._rowDiffset, config);\n\n        const binField = createFields([binnedData], [\n            {\n                name: binFieldName,\n                type: FieldType.DIMENSION,\n                subtype: DimensionSubtype.BINNED,\n                bins\n            }], [binFieldName])[0];\n\n        const clone = this.clone(config.saveChild);\n        clone.addField(binField);\n\n        persistDerivations(\n            this,\n            clone,\n            DM_DERIVATIVES.BIN,\n             { measureFieldName, config, binFieldName },\n             null\n        );\n\n        return clone;\n    }\n\n    /**\n     * Creates a new {@link DataModel} instance with completely detached root from current {@link DataModel} instance,\n     * the new {@link DataModel} instance has no parent-children relationship with the current one, but has same data as\n     * the current one.\n     * This API is useful when a completely different {@link DataModel} but with same data as the current instance is\n     * needed.\n     *\n     * @example\n     *  const dm = new DataModel(data, schema);\n     *  const detachedDm = dm.detachedRoot();\n     *\n     * // has different namespace\n     * console.log(dm.getPartialFieldspace().name);\n     * console.log(detachedDm.getPartialFieldspace().name);\n     *\n     * // has same data\n     * console.log(dm.getData());\n     * console.log(detachedDm.getData());\n     *\n     * @public\n     *\n     * @return {DataModel} Returns a detached {@link DataModel} instance.\n     */\n    detachedRoot () {\n        const data = this.serialize(DataFormat.FLAT_JSON);\n        const schema = this.getSchema();\n\n        return new DataModel(data, schema);\n    }\n}\n\nexport default DataModel;\n","import { DataFormat } from './enums';\n\nexport default {\n    dataFormat: DataFormat.AUTO\n};\n","/**\n * DataFormat Enum defines the format of the input data.\n * Based on the format of the data the respective adapter is loaded.\n *\n * @readonly\n * @enum {string}\n */\nconst DataFormat = {\n    FLAT_JSON: 'FlatJSON',\n    DSV_STR: 'DSVStr',\n    DSV_ARR: 'DSVArr',\n    AUTO: 'Auto'\n};\n\nexport default DataFormat;\n","/**\n * DimensionSubtype enum defines the sub types of the Dimensional Field.\n *\n * @readonly\n * @enum {string}\n */\nconst DimensionSubtype = {\n    CATEGORICAL: 'categorical',\n    TEMPORAL: 'temporal',\n    GEO: 'geo',\n    BINNED: 'binned'\n};\n\nexport default DimensionSubtype;\n","/**\n * FieldType enum defines the high level field based on which visuals are controlled.\n * Measure in a high level is numeric field and Dimension in a high level is string field.\n *\n * @readonly\n * @enum {string}\n */\nconst FieldType = {\n    MEASURE: 'measure',\n    DIMENSION: 'dimension'\n};\n\nexport default FieldType;\n","/**\n * Filtering mode enum defines the filering modes of DataModel.\n *\n * @readonly\n * @enum {string}\n */\nconst FilteringMode = {\n    NORMAL: 'normal',\n    INVERSE: 'inverse',\n    ALL: 'all'\n};\n\nexport default FilteringMode;\n","/**\n * Group by function names\n *\n * @readonly\n * @enum {string}\n */\nconst GROUP_BY_FUNCTIONS = {\n    SUM: 'sum',\n    AVG: 'avg',\n    MIN: 'min',\n    MAX: 'max',\n    FIRST: 'first',\n    LAST: 'last',\n    COUNT: 'count',\n    STD: 'std'\n};\n\nexport default GROUP_BY_FUNCTIONS;\n","/**\n * FilteringMode determines if resultant DataModel should be created from selection set or rejection set.\n *\n * The following modes are available\n * - `NORMAL`: Only entries from selection set are included in the resulatant DataModel instance\n * - `INVERSE`: Only entries from rejection set are included in the resulatant DataModel instance\n * - ALL: Both the entries from selection and rejection set are returned in two different DataModel instance\n */\n\nexport { default as DataFormat } from './data-format';\nexport { default as DimensionSubtype } from './dimension-subtype';\nexport { default as MeasureSubtype } from './measure-subtype';\nexport { default as FieldType } from './field-type';\nexport { default as FilteringMode } from './filtering-mode';\nexport { default as GROUP_BY_FUNCTIONS } from './group-by-functions';\n","/**\n * MeasureSubtype enum defines the sub types of the Measure Field.\n *\n * @readonly\n * @enum {string}\n */\nconst MeasureSubtype = {\n    CONTINUOUS: 'continuous'\n};\n\nexport default MeasureSubtype;\n","import DataModel from './datamodel';\nimport {\n  compose,\n  bin,\n  select,\n  project,\n  groupby as groupBy,\n  calculateVariable,\n  sort,\n  crossProduct,\n  difference,\n  naturalJoin,\n  leftOuterJoin,\n  rightOuterJoin,\n  fullOuterJoin,\n  union\n} from './operator';\nimport * as Stats from './stats';\nimport * as enums from './enums';\nimport { DateTimeFormatter } from './utils';\nimport { DataFormat, FilteringMode, DM_DERIVATIVES } from './constants';\nimport InvalidAwareTypes from './invalid-aware-types';\nimport pkg from '../package.json';\n\nconst Operators = {\n    compose,\n    bin,\n    select,\n    project,\n    groupBy,\n    calculateVariable,\n    sort,\n    crossProduct,\n    difference,\n    naturalJoin,\n    leftOuterJoin,\n    rightOuterJoin,\n    fullOuterJoin,\n    union\n};\n\nconst version = pkg.version;\nObject.assign(DataModel, {\n    Operators,\n    Stats,\n    DM_DERIVATIVES,\n    DateTimeFormatter,\n    DataFormat,\n    FilteringMode,\n    InvalidAwareTypes,\n    version\n}, enums);\n\nexport default DataModel;\n","import { FieldType, DimensionSubtype, MeasureSubtype } from './enums';\nimport {\n    Categorical,\n    Temporal,\n    Binned,\n    Continuous,\n    CategoricalParser,\n    TemporalParser,\n    BinnedParser,\n    ContinuousParser,\n    PartialField\n} from './fields';\n\n/**\n * Creates a field instance according to the provided data and schema.\n *\n * @param {Array} data - The field data array.\n * @param {Object} schema - The field schema object.\n * @return {Field} Returns the newly created field instance.\n */\nfunction createUnitField(data, schema) {\n    data = data || [];\n    let partialField;\n\n    switch (schema.type) {\n    case FieldType.MEASURE:\n        switch (schema.subtype) {\n        case MeasureSubtype.CONTINUOUS:\n            partialField = new PartialField(schema.name, data, schema, new ContinuousParser());\n            return new Continuous(partialField, `0-${data.length - 1}`);\n        default:\n            partialField = new PartialField(schema.name, data, schema, new ContinuousParser());\n            return new Continuous(partialField, `0-${data.length - 1}`);\n        }\n    case FieldType.DIMENSION:\n        switch (schema.subtype) {\n        case DimensionSubtype.CATEGORICAL:\n            partialField = new PartialField(schema.name, data, schema, new CategoricalParser());\n            return new Categorical(partialField, `0-${data.length - 1}`);\n        case DimensionSubtype.TEMPORAL:\n            partialField = new PartialField(schema.name, data, schema, new TemporalParser(schema));\n            return new Temporal(partialField, `0-${data.length - 1}`);\n        case DimensionSubtype.BINNED:\n            partialField = new PartialField(schema.name, data, schema, new BinnedParser());\n            return new Binned(partialField, `0-${data.length - 1}`);\n        default:\n            partialField = new PartialField(schema.name, data, schema, new CategoricalParser());\n            return new Categorical(partialField, `0-${data.length - 1}`);\n        }\n    default:\n        partialField = new PartialField(schema.name, data, schema, new CategoricalParser());\n        return new Categorical(partialField, `0-${data.length - 1}`);\n    }\n}\n\n\n/**\n * Creates a field instance from partialField and rowDiffset.\n *\n * @param {PartialField} partialField - The corresponding partial field.\n * @param {string} rowDiffset - The data subset config.\n * @return {Field} Returns the newly created field instance.\n */\nexport function createUnitFieldFromPartial(partialField, rowDiffset) {\n    const { schema } = partialField;\n\n    switch (schema.type) {\n    case FieldType.MEASURE:\n        switch (schema.subtype) {\n        case MeasureSubtype.CONTINUOUS:\n            return new Continuous(partialField, rowDiffset);\n        default:\n            return new Continuous(partialField, rowDiffset);\n        }\n    case FieldType.DIMENSION:\n        switch (schema.subtype) {\n        case DimensionSubtype.CATEGORICAL:\n            return new Categorical(partialField, rowDiffset);\n        case DimensionSubtype.TEMPORAL:\n            return new Temporal(partialField, rowDiffset);\n        case DimensionSubtype.BINNED:\n            return new Binned(partialField, rowDiffset);\n        default:\n            return new Categorical(partialField, rowDiffset);\n        }\n    default:\n        return new Categorical(partialField, rowDiffset);\n    }\n}\n\n/**\n * Creates the field instances with input data and schema.\n *\n * @param {Array} dataColumn - The data array for fields.\n * @param {Array} schema - The schema array for fields.\n * @param {Array} headers - The array of header names.\n * @return {Array.<Field>} Returns an array of newly created field instances.\n */\nexport function createFields(dataColumn, schema, headers) {\n    const headersObj = {};\n\n    if (!(headers && headers.length)) {\n        headers = schema.map(item => item.name);\n    }\n\n    headers.forEach((header, i) => {\n        headersObj[header] = i;\n    });\n\n    return schema.map(item => createUnitField(dataColumn[headersObj[item.name]], item));\n}\n","import { FieldType } from './enums';\nimport { getUniqueId } from './utils';\n\nconst fieldStore = {\n    data: {},\n\n    createNamespace (fieldArr, name) {\n        const dataId = name || getUniqueId();\n\n        this.data[dataId] = {\n            name: dataId,\n            fields: fieldArr,\n\n            fieldsObj () {\n                let fieldsObj = this._cachedFieldsObj;\n\n                if (!fieldsObj) {\n                    fieldsObj = this._cachedFieldsObj = {};\n                    this.fields.forEach((field) => {\n                        fieldsObj[field.name()] = field;\n                    });\n                }\n                return fieldsObj;\n            },\n            getMeasure () {\n                let measureFields = this._cachedMeasure;\n\n                if (!measureFields) {\n                    measureFields = this._cachedMeasure = {};\n                    this.fields.forEach((field) => {\n                        if (field.schema().type === FieldType.MEASURE) {\n                            measureFields[field.name()] = field;\n                        }\n                    });\n                }\n                return measureFields;\n            },\n            getDimension () {\n                let dimensionFields = this._cachedDimension;\n\n                if (!this._cachedDimension) {\n                    dimensionFields = this._cachedDimension = {};\n                    this.fields.forEach((field) => {\n                        if (field.schema().type === FieldType.DIMENSION) {\n                            dimensionFields[field.name()] = field;\n                        }\n                    });\n                }\n                return dimensionFields;\n            },\n        };\n        return this.data[dataId];\n    },\n};\n\nexport default fieldStore;\n","import Dimension from '../dimension';\n\n/**\n * Represents binned field subtype.\n *\n * @public\n * @class\n * @extends Dimension\n */\nexport default class Binned extends Dimension {\n    /**\n     * Calculates the corresponding field domain.\n     *\n     * @public\n     * @override\n     * @return {Array} Returns the last and first values of bins config array.\n     */\n    calculateDataDomain () {\n        const binsArr = this.partialField.schema.bins;\n        return [binsArr[0], binsArr[binsArr.length - 1]];\n    }\n\n    /**\n     * Returns the bins config provided while creating the field instance.\n     *\n     * @public\n     * @return {Array} Returns the bins array config.\n     */\n    bins () {\n        return this.partialField.schema.bins;\n    }\n}\n","import { rowDiffsetIterator } from '../../operator/row-diffset-iterator';\nimport { DimensionSubtype } from '../../enums';\nimport Dimension from '../dimension';\n/**\n * Represents categorical field subtype.\n *\n * @public\n * @class\n * @extends Dimension\n */\nexport default class Categorical extends Dimension {\n    /**\n     * Returns the subtype of the field.\n     *\n     * @public\n     * @override\n     * @return {string} Returns the subtype of the field.\n     */\n    subtype () {\n        return DimensionSubtype.CATEGORICAL;\n    }\n\n    /**\n     * Calculates the corresponding field domain.\n     *\n     * @public\n     * @override\n     * @return {Array} Returns the unique values.\n     */\n    calculateDataDomain () {\n        const hash = new Set();\n        const domain = [];\n\n        // here don't use this.data() as the iteration will be occurred two times on same data.\n        rowDiffsetIterator(this.rowDiffset, (i) => {\n            const datum = this.partialField.data[i];\n            if (!hash.has(datum)) {\n                hash.add(datum);\n                domain.push(datum);\n            }\n        });\n        return domain;\n    }\n}\n","import { rowDiffsetIterator } from '../../operator/row-diffset-iterator';\nimport { MeasureSubtype } from '../../enums';\nimport Measure from '../measure';\nimport InvalidAwareTypes from '../../invalid-aware-types';\n\n/**\n * Represents continuous field subtype.\n *\n * @public\n * @class\n * @extends Measure\n */\nexport default class Continuous extends Measure {\n    /**\n     * Returns the subtype of the field.\n     *\n     * @public\n     * @override\n     * @return {string} Returns the subtype of the field.\n     */\n    subtype () {\n        return MeasureSubtype.CONTINUOUS;\n    }\n\n    /**\n     * Calculates the corresponding field domain.\n     *\n     * @public\n     * @override\n     * @return {Array} Returns the min and max values.\n     */\n    calculateDataDomain () {\n        let min = Number.POSITIVE_INFINITY;\n        let max = Number.NEGATIVE_INFINITY;\n\n        // here don't use this.data() as the iteration will be occurred two times on same data.\n        rowDiffsetIterator(this.rowDiffset, (i) => {\n            const datum = this.partialField.data[i];\n            if (datum instanceof InvalidAwareTypes) {\n                return;\n            }\n\n            if (datum < min) {\n                min = datum;\n            }\n            if (datum > max) {\n                max = datum;\n            }\n        });\n\n        return [min, max];\n    }\n}\n","import Field from '../field';\n\n/**\n * Represents dimension field type.\n *\n * @public\n * @class\n * @extends Field\n */\nexport default class Dimension extends Field {\n    /**\n     * Returns the domain for the dimension field.\n     *\n     * @override\n     * @public\n     * @return {any} Returns the calculated domain.\n     */\n    domain () {\n        if (!this._cachedDomain) {\n            this._cachedDomain = this.calculateDataDomain();\n        }\n        return this._cachedDomain;\n    }\n\n    /**\n     * Calculates the corresponding field domain.\n     *\n     * @public\n     * @abstract\n     */\n    calculateDataDomain () {\n        throw new Error('Not yet implemented');\n    }\n\n     /**\n     * Returns the formatted version of the underlying field data.\n     *\n     * @public\n     * @override\n     * @return {Array} Returns the formatted data.\n     */\n    formattedData () {\n        return this.data();\n    }\n}\n","import { rowDiffsetIterator } from '../../operator/row-diffset-iterator';\n\n/**\n * In {@link DataModel}, every tabular data consists of column, a column is stored as field.\n * Field contains all the data for a given column in an array.\n *\n * Each record consists of several fields; the fields of all records form the columns.\n * Examples of fields: name, gender, sex etc.\n *\n * In DataModel, each field can have multiple attributes which describes its data and behaviour.\n * A field can have two types of data: Measure and Dimension.\n *\n * A Dimension Field is the context on which a data is categorized and the measure is the numerical values that\n * quantify the data set.\n * In short a dimension is the lens through which you are looking at your measure data.\n *\n * Refer to {@link Schema} to get info about possible field attributes.\n *\n * @public\n * @class\n */\nexport default class Field {\n    /**\n     * Initialize a new instance.\n     *\n     * @public\n     * @param {PartialField} partialField - The partialField instance which holds the whole data.\n     * @param {string} rowDiffset - The data subset definition.\n     */\n    constructor (partialField, rowDiffset) {\n        this.partialField = partialField;\n        this.rowDiffset = rowDiffset;\n    }\n\n    /**\n     * Generates the field type specific domain.\n     *\n     * @public\n     * @abstract\n     */\n    domain () {\n        throw new Error('Not yet implemented');\n    }\n\n    /**\n     * Returns the the field schema.\n     *\n     * @public\n     * @return {string} Returns the field schema.\n     */\n    schema () {\n        return this.partialField.schema;\n    }\n\n    /**\n     * Returns the name of the field.\n     *\n     * @public\n     * @return {string} Returns the name of the field.\n     */\n    name () {\n        return this.partialField.name;\n    }\n\n    /**\n     * Returns the type of the field.\n     *\n     * @public\n     * @return {string} Returns the type of the field.\n     */\n    type () {\n        return this.partialField.schema.type;\n    }\n\n    /**\n     * Returns the subtype of the field.\n     *\n     * @public\n     * @return {string} Returns the subtype of the field.\n     */\n    subtype () {\n        return this.partialField.schema.subtype;\n    }\n\n    /**\n     * Returns the description of the field.\n     *\n     * @public\n     * @return {string} Returns the description of the field.\n     */\n    description () {\n        return this.partialField.schema.description;\n    }\n\n    /**\n     * Returns the display name of the field.\n     *\n     * @public\n     * @return {string} Returns the display name of the field.\n     */\n    displayName () {\n        return this.partialField.schema.displayName || this.partialField.schema.name;\n    }\n\n    /**\n     * Returns the data associated with the field.\n     *\n     * @public\n     * @return {Array} Returns the data.\n     */\n    data () {\n        const data = [];\n        rowDiffsetIterator(this.rowDiffset, (i) => {\n            data.push(this.partialField.data[i]);\n        });\n        return data;\n    }\n\n    /**\n     * Returns the formatted version of the underlying field data.\n     *\n     * @public\n     * @abstract\n     */\n    formattedData () {\n        throw new Error('Not yet implemented');\n    }\n}\n","export { default as Field } from './field';\nexport { default as Dimension } from './dimension';\nexport { default as Categorical } from './categorical';\nexport { default as Temporal } from './temporal';\nexport { default as Binned } from './binned';\nexport { default as Measure } from './measure';\nexport { default as Continuous } from './continuous';\nexport { default as FieldParser } from './parsers/field-parser';\nexport { default as CategoricalParser } from './parsers/categorical-parser';\nexport { default as TemporalParser } from './parsers/temporal-parser';\nexport { default as BinnedParser } from './parsers/binned-parser';\nexport { default as ContinuousParser } from './parsers/continuous-parser';\nexport { default as PartialField } from './partial-field';\n","import { formatNumber } from '../../utils';\nimport { defaultReducerName } from '../../operator/group-by-function';\nimport Field from '../field';\n\n/**\n * Represents measure field type.\n *\n * @public\n * @class\n * @extends Field\n */\nexport default class Measure extends Field {\n  /**\n   * Returns the domain for the measure field.\n   *\n   * @override\n   * @public\n   * @return {any} Returns the calculated domain.\n   */\n    domain () {\n        if (!this._cachedDomain) {\n            this._cachedDomain = this.calculateDataDomain();\n        }\n        return this._cachedDomain;\n    }\n\n  /**\n   * Returns the unit of the measure field.\n   *\n   * @public\n   * @return {string} Returns unit of the field.\n   */\n    unit () {\n        return this.partialField.schema.unit;\n    }\n\n  /**\n   * Returns the aggregation function name of the measure field.\n   *\n   * @public\n   * @return {string} Returns aggregation function name of the field.\n   */\n    defAggFn () {\n        return this.partialField.schema.defAggFn || defaultReducerName;\n    }\n\n  /**\n   * Returns the number format of the measure field.\n   *\n   * @public\n   * @return {Function} Returns number format of the field.\n   */\n    numberFormat () {\n        const { numberFormat } = this.partialField.schema;\n        return numberFormat instanceof Function ? numberFormat : formatNumber;\n    }\n\n  /**\n   * Calculates the corresponding field domain.\n   *\n   * @public\n   * @abstract\n   */\n    calculateDataDomain () {\n        throw new Error('Not yet implemented');\n    }\n\n    /**\n     * Returns the formatted version of the underlying field data.\n     *\n     * @public\n     * @override\n     * @return {Array} Returns the formatted data.\n     */\n    formattedData () {\n        return this.data();\n    }\n}\n","import FieldParser from '../field-parser';\nimport InvalidAwareTypes from '../../../invalid-aware-types';\n\n/**\n * A FieldParser which parses the binned values.\n *\n * @public\n * @class\n * @implements {FieldParser}\n */\nexport default class BinnedParser extends FieldParser {\n  /**\n   * Parses a single binned value of a field and returns the sanitized value.\n   *\n   * @public\n   * @param {string} val - The value of the field.\n   * @return {string} Returns the sanitized value.\n   */\n    parse (val) {\n        const regex = /^\\s*([+-]?\\d+(?:\\.\\d+)?)\\s*-\\s*([+-]?\\d+(?:\\.\\d+)?)\\s*$/;\n        val = String(val);\n        let result;\n        // check if invalid date value\n        if (!InvalidAwareTypes.isInvalid(val)) {\n            let matched = val.match(regex);\n            result = matched ? `${Number.parseFloat(matched[1])}-${Number.parseFloat(matched[2])}`\n                             : InvalidAwareTypes.NA;\n        } else {\n            result = InvalidAwareTypes.getInvalidType(val);\n        }\n        return result;\n    }\n}\n","import FieldParser from '../field-parser';\nimport InvalidAwareTypes from '../../../invalid-aware-types';\n\n/**\n * A FieldParser which parses the categorical values.\n *\n * @public\n * @class\n * @implements {FieldParser}\n */\nexport default class CategoricalParser extends FieldParser {\n  /**\n   * Parses a single value of a field and returns the stringified form.\n   *\n   * @public\n   * @param {string|number} val - The value of the field.\n   * @return {string} Returns the stringified value.\n   */\n    parse (val) {\n        let result;\n        // check if invalid date value\n        if (!InvalidAwareTypes.isInvalid(val)) {\n            result = String(val).trim();\n        } else {\n            result = InvalidAwareTypes.getInvalidType(val);\n        }\n        return result;\n    }\n}\n","import FieldParser from '../field-parser';\nimport InvalidAwareTypes from '../../../invalid-aware-types';\n\n/**\n * A FieldParser which parses the continuous values.\n *\n * @public\n * @class\n * @implements {FieldParser}\n */\nexport default class ContinuousParser extends FieldParser {\n  /**\n   * Parses a single value of a field and returns the number form.\n   *\n   * @public\n   * @param {string|number} val - The value of the field.\n   * @return {string} Returns the number value.\n   */\n    parse (val) {\n        let result;\n        // check if invalid date value\n        if (!InvalidAwareTypes.isInvalid(val)) {\n            let parsedVal = parseFloat(val, 10);\n            result = Number.isNaN(parsedVal) ? InvalidAwareTypes.NA : parsedVal;\n        } else {\n            result = InvalidAwareTypes.getInvalidType(val);\n        }\n        return result;\n    }\n}\n","/**\n * A interface to represent a parser which is responsible to parse the field.\n *\n * @public\n * @interface\n */\nexport default class FieldParser {\n    /**\n     * Parses a single value of a field and return the sanitized form.\n     *\n     * @public\n     * @abstract\n     */\n    parse () {\n        throw new Error('Not yet implemented');\n    }\n}\n","import { DateTimeFormatter } from '../../../utils';\nimport FieldParser from '../field-parser';\nimport InvalidAwareTypes from '../../../invalid-aware-types';\n\n/**\n * A FieldParser which parses the temporal values.\n *\n * @public\n * @class\n * @implements {FieldParser}\n */\nexport default class TemporalParser extends FieldParser {\n    /**\n     * Initialize a new instance.\n     *\n     * @public\n     * @param {Object} schema - The schema object for the corresponding field.\n     */\n    constructor (schema) {\n        super();\n        this.schema = schema;\n        this._dtf = new DateTimeFormatter(this.schema.format);\n    }\n\n    /**\n     * Parses a single value of a field and returns the millisecond value.\n     *\n     * @public\n     * @param {string|number} val - The value of the field.\n     * @return {number} Returns the millisecond value.\n     */\n    parse (val) {\n        let result;\n        // check if invalid date value\n        if (!InvalidAwareTypes.isInvalid(val)) {\n            let nativeDate = this._dtf.getNativeDate(val);\n            result = nativeDate ? nativeDate.getTime() : InvalidAwareTypes.NA;\n        } else {\n            result = InvalidAwareTypes.getInvalidType(val);\n        }\n        return result;\n    }\n}\n","/**\n * Stores the full data and the metadata of a field. It provides\n * a single source of data from which the future Field\n * instance can get a subset of it with a rowDiffset config.\n *\n * @class\n * @public\n */\nexport default class PartialField {\n    /**\n     * Initialize a new instance.\n     *\n     * @public\n     * @param {string} name - The name of the field.\n     * @param {Array} data - The data array.\n     * @param {Object} schema - The schema object of the corresponding field.\n     * @param {FieldParser} parser - The parser instance corresponding to that field.\n     */\n    constructor (name, data, schema, parser) {\n        this.name = name;\n        this.schema = schema;\n        this.parser = parser;\n        this.data = this._sanitize(data);\n    }\n\n    /**\n     * Sanitizes the field data.\n     *\n     * @private\n     * @param {Array} data - The actual input data.\n     * @return {Array} Returns the sanitized data.\n     */\n    _sanitize (data) {\n        return data.map(datum => this.parser.parse(datum));\n    }\n}\n","import { rowDiffsetIterator } from '../../operator/row-diffset-iterator';\nimport Dimension from '../dimension';\nimport { DateTimeFormatter } from '../../utils';\nimport InvalidAwareTypes from '../../invalid-aware-types';\n\n/**\n * Represents temporal field subtype.\n *\n * @public\n * @class\n * @extends Dimension\n */\nexport default class Temporal extends Dimension {\n     /**\n     * Initialize a new instance.\n     *\n     * @public\n     * @param {PartialField} partialField - The partialField instance which holds the whole data.\n     * @param {string} rowDiffset - The data subset definition.\n     */\n    constructor (partialField, rowDiffset) {\n        super(partialField, rowDiffset);\n\n        this._cachedMinDiff = null;\n    }\n\n     /**\n     * Calculates the corresponding field domain.\n     *\n     * @public\n     * @override\n     * @return {Array} Returns the unique values.\n     */\n    calculateDataDomain () {\n        const hash = new Set();\n        const domain = [];\n\n        // here don't use this.data() as the iteration will be\n        // occurred two times on same data.\n        rowDiffsetIterator(this.rowDiffset, (i) => {\n            const datum = this.partialField.data[i];\n            if (!hash.has(datum)) {\n                hash.add(datum);\n                domain.push(datum);\n            }\n        });\n\n        return domain;\n    }\n\n\n    /**\n     * Calculates the minimum consecutive difference from the associated field data.\n     *\n     * @public\n     * @return {number} Returns the minimum consecutive diff in milliseconds.\n     */\n    minimumConsecutiveDifference () {\n        if (this._cachedMinDiff) {\n            return this._cachedMinDiff;\n        }\n\n        const sortedData = this.data().filter(item => !(item instanceof InvalidAwareTypes)).sort((a, b) => a - b);\n        const arrLn = sortedData.length;\n        let minDiff = Number.POSITIVE_INFINITY;\n        let prevDatum;\n        let nextDatum;\n        let processedCount = 0;\n\n        for (let i = 1; i < arrLn; i++) {\n            prevDatum = sortedData[i - 1];\n            nextDatum = sortedData[i];\n\n            if (nextDatum === prevDatum) {\n                continue;\n            }\n\n            minDiff = Math.min(minDiff, nextDatum - sortedData[i - 1]);\n            processedCount++;\n        }\n\n        if (!processedCount) {\n            minDiff = null;\n        }\n        this._cachedMinDiff = minDiff;\n\n        return this._cachedMinDiff;\n    }\n\n    /**\n     * Returns the format specified in the input schema while creating field.\n     *\n     * @public\n     * @return {string} Returns the datetime format.\n     */\n    format () {\n        return this.partialField.schema.format;\n    }\n\n    /**\n     * Returns the formatted version of the underlying field data.\n     *\n     * @public\n     * @override\n     * @return {Array} Returns the formatted data.\n     */\n    formattedData () {\n        const data = [];\n        rowDiffsetIterator(this.rowDiffset, (i) => {\n            const datum = this.partialField.data[i];\n            if (datum instanceof InvalidAwareTypes) {\n                data.push(datum);\n            } else {\n                data.push(DateTimeFormatter.formatAs(datum, this.format()));\n            }\n        });\n        return data;\n    }\n}\n\n","import { FieldType, FilteringMode, DimensionSubtype, MeasureSubtype, DataFormat } from './enums';\nimport fieldStore from './field-store';\nimport Value from './value';\nimport {\n    rowDiffsetIterator\n} from './operator';\nimport { DM_DERIVATIVES, LOGICAL_OPERATORS } from './constants';\nimport { createFields, createUnitFieldFromPartial } from './field-creator';\nimport defaultConfig from './default-config';\nimport * as converter from './converter';\nimport { extend2, detectDataFormat } from './utils';\n\n/**\n * Prepares the selection data.\n */\nfunction prepareSelectionData (fields, i) {\n    const resp = {};\n    for (let field of fields) {\n        resp[field.name()] = new Value(field.partialField.data[i], field);\n    }\n    return resp;\n}\n\nexport function prepareJoinData (fields) {\n    const resp = {};\n    Object.keys(fields).forEach((key) => { resp[key] = new Value(fields[key], key); });\n    return resp;\n}\n\nexport const updateFields = ([rowDiffset, colIdentifier], partialFieldspace, fieldStoreName) => {\n    let collID = colIdentifier.length ? colIdentifier.split(',') : [];\n    let partialFieldMap = partialFieldspace.fieldsObj();\n    let newFields = collID.map(coll => createUnitFieldFromPartial(partialFieldMap[coll].partialField, rowDiffset));\n    return fieldStore.createNamespace(newFields, fieldStoreName);\n};\n\nexport const persistCurrentDerivation = (model, operation, config = {}, criteriaFn) => {\n    if (operation === DM_DERIVATIVES.COMPOSE) {\n        model._derivation.length = 0;\n        model._derivation.push(...criteriaFn);\n    } else {\n        model._derivation.push({\n            op: operation,\n            meta: config,\n            criteria: criteriaFn\n        });\n    }\n};\n\nexport const persistAncestorDerivation = (sourceDm, newDm) => {\n    newDm._ancestorDerivation.push(...sourceDm._ancestorDerivation, ...sourceDm._derivation);\n};\n\nexport const persistDerivations = (sourceDm, model, operation, config = {}, criteriaFn) => {\n    persistCurrentDerivation(model, operation, config, criteriaFn);\n    persistAncestorDerivation(sourceDm, model);\n};\n\nconst generateRowDiffset = (rowDiffset, i, lastInsertedValue) => {\n    if (lastInsertedValue !== -1 && i === (lastInsertedValue + 1)) {\n        const li = rowDiffset.length - 1;\n\n        rowDiffset[li] = `${rowDiffset[li].split('-')[0]}-${i}`;\n    } else {\n        rowDiffset.push(`${i}`);\n    }\n};\n\nexport const selectHelper = (rowDiffset, fields, selectFn, config, sourceDm) => {\n    let newRowDiffSet = [];\n    const rejRowDiffSet = [];\n    let lastInsertedValue = -1;\n    let lastInsertedValueRej = -1;\n    let { mode } = config;\n    let cachedStore = {};\n    let cloneProvider = () => sourceDm.detachedRoot();\n    const selectorHelperFn = index => selectFn(\n        fields[index],\n        index,\n        cloneProvider,\n        cachedStore\n    );\n\n    const checker = mode === FilteringMode.INVERSE ? index => !selectorHelperFn(index) :\n        index => selectorHelperFn(index);\n\n    const passFn = (i) => {\n        if (checker(i)) {\n            generateRowDiffset(newRowDiffSet, i, lastInsertedValue);\n            lastInsertedValue = i;\n            return true;\n        }\n        return false;\n    };\n\n    if (mode === FilteringMode.ALL) {\n        rowDiffsetIterator(rowDiffset, (i) => {\n            if (!passFn(i)) {\n                generateRowDiffset(rejRowDiffSet, i, lastInsertedValueRej);\n                lastInsertedValueRej = i;\n            }\n        });\n        return [newRowDiffSet.join(','), rejRowDiffSet.join(',')];\n    }\n\n    rowDiffsetIterator(rowDiffset, passFn);\n    return [newRowDiffSet.join(',')];\n};\n\nexport const cloneWithAllFields = (model) => {\n    const clonedDm = model.clone(false);\n    const partialFieldspace = model.getPartialFieldspace();\n    clonedDm._colIdentifier = partialFieldspace.fields.map(f => f.name()).join(',');\n\n    // flush out cached namespace values on addition of new fields\n    partialFieldspace._cachedFieldsObj = null;\n    partialFieldspace._cachedDimension = null;\n    partialFieldspace._cachedMeasure = null;\n    clonedDm.__calculateFieldspace().calculateFieldsConfig();\n\n    return clonedDm;\n};\n\nconst getKey = (arr, data, fn) => {\n    let key = fn(arr, data, 0);\n\n    for (let i = 1, len = arr.length; i < len; i++) {\n        key = `${key},${fn(arr, data, i)}`;\n    }\n    return key;\n};\n\nexport const filterPropagationModel = (model, propModels, config = {}) => {\n    let fns = [];\n    const operation = config.operation || LOGICAL_OPERATORS.AND;\n    const filterByMeasure = config.filterByMeasure || false;\n    const clonedModel = cloneWithAllFields(model);\n    const modelFieldsConfig = clonedModel.getFieldsConfig();\n\n    if (!propModels.length) {\n        fns = [() => false];\n    } else {\n        fns = propModels.map(propModel => ((dataModel) => {\n            let keyFn;\n            const dataObj = dataModel.getData();\n            const fieldsConfig = dataModel.getFieldsConfig();\n            const dimensions = Object.keys(dataModel.getFieldspace().getDimension())\n                .filter(d => d in modelFieldsConfig);\n            const dLen = dimensions.length;\n            const indices = dimensions.map(d =>\n                fieldsConfig[d].index);\n            const measures = Object.keys(dataModel.getFieldspace().getMeasure())\n                .filter(d => d in modelFieldsConfig);\n            const fieldsSpace = dataModel.getFieldspace().fieldsObj();\n            const data = dataObj.data;\n            const domain = measures.reduce((acc, v) => {\n                acc[v] = fieldsSpace[v].domain();\n                return acc;\n            }, {});\n            const valuesMap = {};\n\n            keyFn = (arr, row, idx) => row[arr[idx]];\n            if (dLen) {\n                data.forEach((row) => {\n                    const key = getKey(indices, row, keyFn);\n                    valuesMap[key] = 1;\n                });\n            }\n\n            keyFn = (arr, fields, idx) => fields[arr[idx]].value;\n            return data.length ? (fields) => {\n                const present = dLen ? valuesMap[getKey(dimensions, fields, keyFn)] : true;\n\n                if (filterByMeasure) {\n                    return measures.every(field => fields[field].value >= domain[field][0] &&\n                        fields[field].value <= domain[field][1]) && present;\n                }\n                return present;\n            } : () => false;\n        })(propModel));\n    }\n\n    let filteredModel;\n    if (operation === LOGICAL_OPERATORS.AND) {\n        filteredModel = clonedModel.select(fields => fns.every(fn => fn(fields)), {\n            saveChild: false\n        });\n    } else {\n        filteredModel = clonedModel.select(fields => fns.some(fn => fn(fields)), {\n            saveChild: false\n        });\n    }\n\n    return filteredModel;\n};\n\nexport const cloneWithSelect = (sourceDm, selectFn, selectConfig, cloneConfig) => {\n    const cloned = sourceDm.clone(cloneConfig.saveChild);\n    const [rowDiffset, rejRowDiffSet] = selectHelper(\n        cloned._rowDiffset,\n        cloned.getPartialFieldspace()._cachedValueObjects,\n        selectFn,\n        selectConfig,\n        sourceDm\n    );\n    cloned._rowDiffset = rowDiffset;\n    cloned.__calculateFieldspace().calculateFieldsConfig();\n    let oDm = cloned;\n    if (selectConfig.mode === FilteringMode.ALL) {\n        const rejCloned = sourceDm.clone(cloneConfig.saveChild);\n\n        rejCloned._rowDiffset = rejRowDiffSet;\n        rejCloned.__calculateFieldspace().calculateFieldsConfig();\n        persistDerivations(\n            sourceDm,\n            rejCloned,\n            DM_DERIVATIVES.SELECT,\n             { config: selectConfig },\n              selectFn\n        );\n        oDm = [cloned, rejCloned];\n    }\n    persistDerivations(\n        sourceDm,\n        cloned,\n        DM_DERIVATIVES.SELECT,\n         { config: selectConfig },\n          selectFn\n    );\n\n    return oDm;\n};\n\nexport const cloneWithProject = (sourceDm, projField, config, allFields) => {\n    const cloned = sourceDm.clone(config.saveChild);\n    let projectionSet = projField;\n    if (config.mode === FilteringMode.INVERSE) {\n        projectionSet = allFields.filter(fieldName => projField.indexOf(fieldName) === -1);\n    }\n    // cloned._colIdentifier = sourceDm._colIdentifier.split(',')\n    //                         .filter(coll => projectionSet.indexOf(coll) !== -1).join();\n    cloned._colIdentifier = projectionSet.join(',');\n    cloned.__calculateFieldspace().calculateFieldsConfig();\n\n    persistDerivations(\n        sourceDm,\n        cloned,\n        DM_DERIVATIVES.PROJECT,\n        { projField, config, actualProjField: projectionSet },\n        null\n    );\n\n    return cloned;\n};\n\nexport const sanitizeUnitSchema = (unitSchema) => {\n    // Do deep clone of the unit schema as the user might change it later.\n    unitSchema = extend2({}, unitSchema);\n    if (!unitSchema.type) {\n        unitSchema.type = FieldType.DIMENSION;\n    }\n\n    if (!unitSchema.subtype) {\n        switch (unitSchema.type) {\n        case FieldType.MEASURE:\n            unitSchema.subtype = MeasureSubtype.CONTINUOUS;\n            break;\n        default:\n        case FieldType.DIMENSION:\n            unitSchema.subtype = DimensionSubtype.CATEGORICAL;\n            break;\n        }\n    }\n\n    return unitSchema;\n};\n\nexport const validateUnitSchema = (unitSchema) => {\n    const supportedMeasureSubTypes = [MeasureSubtype.CONTINUOUS];\n    const supportedDimSubTypes = [\n        DimensionSubtype.CATEGORICAL,\n        DimensionSubtype.BINNED,\n        DimensionSubtype.TEMPORAL,\n        DimensionSubtype.GEO\n    ];\n    const { type, subtype, name } = unitSchema;\n\n    switch (type) {\n    case FieldType.DIMENSION:\n        if (supportedDimSubTypes.indexOf(subtype) === -1) {\n            throw new Error(`DataModel doesn't support dimension field subtype ${subtype} used for ${name} field`);\n        }\n        break;\n    case FieldType.MEASURE:\n        if (supportedMeasureSubTypes.indexOf(subtype) === -1) {\n            throw new Error(`DataModel doesn't support measure field subtype ${subtype} used for ${name} field`);\n        }\n        break;\n    default:\n        throw new Error(`DataModel doesn't support field type ${type} used for ${name} field`);\n    }\n};\n\nexport const sanitizeAndValidateSchema = schema => schema.map((unitSchema) => {\n    unitSchema = sanitizeUnitSchema(unitSchema);\n    validateUnitSchema(unitSchema);\n    return unitSchema;\n});\n\nexport const resolveFieldName = (schema, dataHeader) => {\n    schema.forEach((unitSchema) => {\n        const fieldNameAs = unitSchema.as;\n        if (!fieldNameAs) { return; }\n\n        const idx = dataHeader.indexOf(unitSchema.name);\n        dataHeader[idx] = fieldNameAs;\n        unitSchema.name = fieldNameAs;\n        delete unitSchema.as;\n    });\n};\n\nexport const updateData = (relation, data, schema, options) => {\n    schema = sanitizeAndValidateSchema(schema);\n    options = Object.assign(Object.assign({}, defaultConfig), options);\n    const converterFn = converter[options.dataFormat];\n\n    if (!(converterFn && typeof converterFn === 'function')) {\n        throw new Error(`No converter function found for ${options.dataFormat} format`);\n    }\n\n    const [header, formattedData] = converterFn(data, options);\n    resolveFieldName(schema, header);\n    const fieldArr = createFields(formattedData, schema, header);\n\n    // This will create a new fieldStore with the fields\n    const nameSpace = fieldStore.createNamespace(fieldArr, options.name);\n    relation._partialFieldspace = nameSpace;\n\n    // If data is provided create the default colIdentifier and rowDiffset\n    relation._rowDiffset = formattedData.length && formattedData[0].length ? `0-${formattedData[0].length - 1}` : '';\n\n    // This stores the value objects which is passed to the filter method when selection operation is done.\n    const valueObjects = [];\n    rowDiffsetIterator(relation._rowDiffset, (i) => {\n        valueObjects[i] = prepareSelectionData(nameSpace.fields, i);\n    });\n    nameSpace._cachedValueObjects = valueObjects;\n\n    relation._colIdentifier = (schema.map(_ => _.name)).join();\n    relation._dataFormat = options.dataFormat === DataFormat.AUTO ? detectDataFormat(data) : options.dataFormat;\n    return relation;\n};\n\nexport const fieldInSchema = (schema, field) => {\n    let i = 0;\n\n    for (; i < schema.length; ++i) {\n        if (field === schema[i].name) {\n            return {\n                type: schema[i].subtype || schema[i].type,\n                index: i\n            };\n        }\n    }\n    return null;\n};\n\n\nexport const getDerivationArguments = (derivation) => {\n    let params = [];\n    let operation;\n    operation = derivation.op;\n    switch (operation) {\n    case DM_DERIVATIVES.SELECT:\n        params = [derivation.criteria];\n        break;\n    case DM_DERIVATIVES.PROJECT:\n        params = [derivation.meta.actualProjField];\n        break;\n    case DM_DERIVATIVES.GROUPBY:\n        operation = 'groupBy';\n        params = [derivation.meta.groupByString.split(','), derivation.criteria];\n        break;\n    default:\n        operation = null;\n    }\n\n    return {\n        operation,\n        params\n    };\n};\n\nconst applyExistingOperationOnModel = (propModel, dataModel) => {\n    const derivations = dataModel.getDerivations();\n    let selectionModel = propModel;\n\n    derivations.forEach((derivation) => {\n        if (!derivation) {\n            return;\n        }\n\n        const { operation, params } = getDerivationArguments(derivation);\n        if (operation) {\n            selectionModel = selectionModel[operation](...params, {\n                saveChild: false\n            });\n        }\n    });\n\n    return selectionModel;\n};\n\nconst getFilteredModel = (propModel, path) => {\n    for (let i = 0, len = path.length; i < len; i++) {\n        const model = path[i];\n        propModel = applyExistingOperationOnModel(propModel, model);\n    }\n    return propModel;\n};\n\nconst propagateIdentifiers = (dataModel, propModel, config = {}, propModelInf = {}) => {\n    const nonTraversingModel = propModelInf.nonTraversingModel;\n    const excludeModels = propModelInf.excludeModels || [];\n\n    if (dataModel === nonTraversingModel) {\n        return;\n    }\n\n    const propagate = excludeModels.length ? excludeModels.indexOf(dataModel) === -1 : true;\n\n    propagate && dataModel.handlePropagation(propModel, config);\n\n    const children = dataModel._children;\n    children.forEach((child) => {\n        const selectionModel = applyExistingOperationOnModel(propModel, child);\n        propagateIdentifiers(child, selectionModel, config, propModelInf);\n    });\n};\n\nexport const getRootGroupByModel = (model) => {\n    while (model._parent && model._derivation.find(d => d.op !== DM_DERIVATIVES.GROUPBY)) {\n        model = model._parent;\n    }\n    return model;\n};\n\nexport const getRootDataModel = (model) => {\n    while (model._parent) {\n        model = model._parent;\n    }\n    return model;\n};\n\nexport const getPathToRootModel = (model, path = []) => {\n    while (model._parent) {\n        path.push(model);\n        model = model._parent;\n    }\n    return path;\n};\n\nexport const propagateToAllDataModels = (identifiers, rootModels, propagationInf, config) => {\n    let criteria;\n    let propModel;\n    const { propagationNameSpace, propagateToSource } = propagationInf;\n    const propagationSourceId = propagationInf.sourceId;\n    const propagateInterpolatedValues = config.propagateInterpolatedValues;\n    const filterFn = (entry) => {\n        const filter = config.filterFn || (() => true);\n        return filter(entry, config);\n    };\n\n    let criterias = [];\n\n    if (identifiers === null && config.persistent !== true) {\n        criterias = [{\n            criteria: []\n        }];\n        criteria = [];\n    } else {\n        let actionCriterias = Object.values(propagationNameSpace.mutableActions);\n        if (propagateToSource !== false) {\n            actionCriterias = actionCriterias.filter(d => d.config.sourceId !== propagationSourceId);\n        }\n\n        const filteredCriteria = actionCriterias.filter(filterFn).map(action => action.config.criteria);\n\n        const excludeModels = [];\n\n        if (propagateToSource !== false) {\n            const sourceActionCriterias = Object.values(propagationNameSpace.mutableActions);\n\n            sourceActionCriterias.forEach((actionInf) => {\n                const actionConf = actionInf.config;\n                if (actionConf.applyOnSource === false && actionConf.action === config.action &&\n                        actionConf.sourceId !== propagationSourceId) {\n                    excludeModels.push(actionInf.model);\n                    criteria = sourceActionCriterias.filter(d => d !== actionInf).map(d => d.config.criteria);\n                    criteria.length && criterias.push({\n                        criteria,\n                        models: actionInf.model,\n                        path: getPathToRootModel(actionInf.model)\n                    });\n                }\n            });\n        }\n\n\n        criteria = [].concat(...[...filteredCriteria, identifiers]).filter(d => d !== null);\n        criterias.push({\n            criteria,\n            excludeModels: [...excludeModels, ...config.excludeModels || []]\n        });\n    }\n\n    const rootModel = rootModels.model;\n\n    const propConfig = Object.assign({\n        sourceIdentifiers: identifiers,\n        propagationSourceId\n    }, config);\n\n    const rootGroupByModel = rootModels.groupByModel;\n    if (propagateInterpolatedValues && rootGroupByModel) {\n        propModel = filterPropagationModel(rootGroupByModel, criteria, {\n            filterByMeasure: propagateInterpolatedValues\n        });\n        propagateIdentifiers(rootGroupByModel, propModel, propConfig);\n    }\n\n    criterias.forEach((inf) => {\n        const propagationModel = filterPropagationModel(rootModel, inf.criteria);\n        const path = inf.path;\n\n        if (path) {\n            const filteredModel = getFilteredModel(propagationModel, path.reverse());\n            inf.models.handlePropagation(filteredModel, propConfig);\n        } else {\n            propagateIdentifiers(rootModel, propagationModel, propConfig, {\n                excludeModels: inf.excludeModels,\n                nonTraversingModel: propagateInterpolatedValues && rootGroupByModel\n            });\n        }\n    });\n};\n\nexport const propagateImmutableActions = (propagationNameSpace, rootModels, propagationInf) => {\n    const immutableActions = propagationNameSpace.immutableActions;\n\n    for (const action in immutableActions) {\n        const actionInf = immutableActions[action];\n        const actionConf = actionInf.config;\n        const propagationSourceId = propagationInf.config.sourceId;\n        const filterImmutableAction = propagationInf.propConfig.filterImmutableAction ?\n            propagationInf.propConfig.filterImmutableAction(actionConf, propagationInf.config) : true;\n        if (actionConf.sourceId !== propagationSourceId && filterImmutableAction) {\n            const criteriaModel = actionConf.criteria;\n            propagateToAllDataModels(criteriaModel, rootModels, {\n                propagationNameSpace,\n                propagateToSource: false,\n                sourceId: propagationSourceId\n            }, actionConf);\n        }\n    }\n};\n\nexport const addToPropNamespace = (propagationNameSpace, config = {}, model) => {\n    let sourceNamespace;\n    const isMutableAction = config.isMutableAction;\n    const criteria = config.criteria;\n    const key = `${config.action}-${config.sourceId}`;\n\n    if (isMutableAction) {\n        sourceNamespace = propagationNameSpace.mutableActions;\n    } else {\n        sourceNamespace = propagationNameSpace.immutableActions;\n    }\n\n    if (criteria === null) {\n        delete sourceNamespace[key];\n    } else {\n        sourceNamespace[key] = {\n            model,\n            config\n        };\n    }\n\n    return this;\n};\n","const DataModel = require('./export');\n\nmodule.exports = DataModel.default ? DataModel.default : DataModel;\n","/**\n * A parser to parser null, undefined, invalid and NIL values.\n *\n * @public\n * @class\n */\nclass InvalidAwareTypes {\n    /**\n     * Static method which gets/sets the invalid value registry.\n     *\n     * @public\n     * @param {Object} config - The custom configuration supplied by user.\n     * @return {Object} Returns the invalid values registry.\n     */\n    static invalidAwareVals (config) {\n        if (!config) {\n            return InvalidAwareTypes._invalidAwareValsMap;\n        }\n        return Object.assign(InvalidAwareTypes._invalidAwareValsMap, config);\n    }\n\n    /**\n     * Initialize a new instance.\n     *\n     * @public\n     * @param {string} value - The value of the invalid data type.\n     */\n    constructor (value) {\n        this._value = value;\n    }\n\n    /**\n     * Returns the current value of the instance.\n     *\n     * @public\n     * @return {string} Returns the value of the invalid data type.\n     */\n    value () {\n        return this._value;\n    }\n\n    /**\n     * Returns the current value of the instance in string format.\n     *\n     * @public\n     * @return {string} Returns the value of the invalid data type.\n     */\n    toString () {\n        return String(this._value);\n    }\n\n    static isInvalid(val) {\n        return (val instanceof InvalidAwareTypes) || !!InvalidAwareTypes.invalidAwareVals()[val];\n    }\n\n    static getInvalidType(val) {\n        return val instanceof InvalidAwareTypes ? val : InvalidAwareTypes.invalidAwareVals()[val];\n    }\n}\n\n/**\n * Enums for Invalid types.\n */\nInvalidAwareTypes.NULL = new InvalidAwareTypes('null');\nInvalidAwareTypes.NA = new InvalidAwareTypes('na');\nInvalidAwareTypes.NIL = new InvalidAwareTypes('nil');\n\n/**\n * Default Registry for mapping the invalid values.\n *\n * @private\n */\nInvalidAwareTypes._invalidAwareValsMap = {\n    invalid: InvalidAwareTypes.NA,\n    nil: InvalidAwareTypes.NIL,\n    null: InvalidAwareTypes.NULL,\n    undefined: InvalidAwareTypes.NA\n};\n\nexport default InvalidAwareTypes;\n","import { rowDiffsetIterator } from './row-diffset-iterator';\nimport InvalidAwareTypes from '../invalid-aware-types';\n\nconst generateBuckets = (binSize, start, end) => {\n    const buckets = [];\n    let next = start;\n\n    while (next < end) {\n        buckets.push(next);\n        next += binSize;\n    }\n    buckets.push(next);\n\n    return buckets;\n};\n\nconst findBucketRange = (bucketRanges, value) => {\n    let leftIdx = 0;\n    let rightIdx = bucketRanges.length - 1;\n    let midIdx;\n    let range;\n\n    // Here use binary search as the bucketRanges is a sorted array\n    while (leftIdx <= rightIdx) {\n        midIdx = leftIdx + Math.floor((rightIdx - leftIdx) / 2);\n        range = bucketRanges[midIdx];\n\n        if (value >= range.start && value < range.end) {\n            return range;\n        } else if (value >= range.end) {\n            leftIdx = midIdx + 1;\n        } else if (value < range.start) {\n            rightIdx = midIdx - 1;\n        }\n    }\n\n    return null;\n};\n\n /**\n  * Creates the bin data from input measure field and supplied configs.\n  *\n  * @param {Measure} measureField - The Measure field instance.\n  * @param {string} rowDiffset - The datamodel rowDiffset values.\n  * @param {Object} config - The config object.\n  * @return {Object} Returns the binned data and the corresponding bins.\n  */\nexport function createBinnedFieldData (measureField, rowDiffset, config) {\n    let { buckets, binsCount, binSize, start, end } = config;\n    const [dMin, dMax] = measureField.domain();\n\n    if (!buckets) {\n        start = (start !== 0 && (!start || start > dMin)) ? dMin : start;\n        end = (end !== 0 && (!end || end < dMax)) ? (dMax + 1) : end;\n\n        if (binsCount) {\n            binSize = Math.ceil(Math.abs(end - start) / binsCount);\n        }\n\n        buckets = generateBuckets(binSize, start, end);\n    }\n\n    if (buckets[0] > dMin) {\n        buckets.unshift(dMin);\n    }\n    if (buckets[buckets.length - 1] <= dMax) {\n        buckets.push(dMax + 1);\n    }\n\n    const bucketRanges = [];\n    for (let i = 0; i < buckets.length - 1; i++) {\n        bucketRanges.push({\n            start: buckets[i],\n            end: buckets[i + 1]\n        });\n    }\n\n    const binnedData = [];\n    rowDiffsetIterator(rowDiffset, (i) => {\n        const datum = measureField.partialField.data[i];\n        if (datum instanceof InvalidAwareTypes) {\n            binnedData.push(datum);\n            return;\n        }\n\n        const range = findBucketRange(bucketRanges, datum);\n        binnedData.push(`${range.start}-${range.end}`);\n    });\n\n    return { binnedData, bins: buckets };\n}\n","import { persistDerivations } from '../helper';\nimport { DM_DERIVATIVES } from '../constants';\n\n/**\n * DataModel's opearators are exposed as composable functional operators as well as chainable operators. Chainable\n * operators are called on the instances of {@link Datamodel} and {@link Relation} class.\n *\n * Those same operators can be used as composable operators from `DataModel.Operators` namespace.\n *\n * All these operators have similar behaviour. All these operators when called with the argument returns a function\n * which expects a DataModel instance.\n *\n * @public\n * @module Operators\n * @namespace DataModel\n */\n\n/**\n * This is functional version of selection operator. {@link link_to_selection | Selection} is a row filtering operation.\n * It takes {@link SelectionPredicate | predicate} for filtering criteria and returns a function.\n * The returned function is called with the DataModel instance on which the action needs to be performed.\n *\n * {@link SelectionPredicate} is a function which returns a boolean value. For selection opearation the selection\n * function is called for each row of DataModel instance with the current row passed as argument.\n *\n * After executing {@link SelectionPredicate} the rows are labeled as either an entry of selection set or an entry\n * of rejection set.\n *\n * {@link FilteringMode} operates on the selection and rejection set to determine which one would reflect in the\n * resulatant datamodel.\n *\n * @warning\n * [Warn] Selection and rejection set is only a logical idea for concept explanation purpose.\n *\n * @error\n * [Error] `FilteringMode.ALL` is not a valid working mode for functional version of `select`. Its only avialable on the\n * chained version.\n *\n * @example\n * const select = DataModel.Operators.select;\n * usaCarsFn = select(fields => fields.Origin.value === 'USA');\n * usaCarsDm = usaCarsFn(dm);\n * console.log(usaCarsDm);\n *\n * @public\n * @namespace DataModel\n * @module Operators\n *\n * @param {SelectionPredicate} selectFn - Predicate funciton which is called for each row with the current row\n *      ```\n *          function (row, i)  { ... }\n *      ```\n * @param {Object} [config] - The configuration object to control the inclusion exclusion of a row in resultant\n *      DataModel instance\n * @param {FilteringMode} [config.mode=FilteringMode.NORMAL] - The mode of the selection\n *\n * @return {PreparatorFunction} Function which expects an instance of DataModel on which the operator needs to be\n *      applied.\n */\nexport const select = (...args) => dm => dm.select(...args);\n\n/**\n * This is functional version of projection operator. {@link link_to_projection | Projection} is a column filtering\n * operation.It expects list of fields name and either include those or exclude those based on {@link FilteringMode} on\n * the  resultant variable.It returns a function which is called with the DataModel instance on which the action needs\n * to be performed.\n *\n * Projection expects array of fields name based on which it creates the selection and rejection set. All the field\n * whose name is present in array goes in selection set and rest of the fields goes in rejection set.\n *\n * {@link FilteringMode} operates on the selection and rejection set to determine which one would reflect in the\n * resulatant datamodel.\n *\n * @warning\n * Selection and rejection set is only a logical idea for concept explanation purpose.\n *\n * @error\n * `FilteringMode.ALL` is not a valid working mode for functional version of `select`. Its only avialable on the\n * chained version.\n *\n * @public\n * @namespace DataModel\n * @module Operators\n *\n * @param {Array.<string | Regexp>} projField - An array of column names in string or regular expression.\n * @param {Object} [config] - An optional config to control the creation of new DataModel\n * @param {FilteringMode} [config.mode=FilteringMode.NORMAL] - Mode of the projection\n *\n * @return {PreparatorFunction} Function which expects an instance of DataModel on which the operator needs to be\n *      applied.\n */\nexport const project = (...args) => dm => dm.project(...args);\n\n/**\n * This is functional version of binnig operator. Binning happens on a measure field based on a binning configuration.\n * Binning in DataModel does not aggregate the number of rows present in DataModel instance after binning, it just adds\n * a new field with the binned value. Refer binning {@link example_of_binning | example} to have a intuition of what\n * binning is and the use case.\n *\n * Binning can be configured by\n * - providing custom bin configuration with non uniform buckets\n * - providing bin count\n * - providing each bin size\n *\n * When custom buckets are provided as part of binning configuration\n * @example\n *  // DataModel already prepared and assigned to dm vairable\n *  const buckets = {\n *      start: 30\n *      stops: [80, 100, 110]\n *  };\n *  const config = { buckets, name: 'binnedHP' }\n *  const binFn = bin('horsepower', config);\n *  const binnedDm = binFn(dm);\n *\n * @text\n * When `binCount` is defined as part of binning configuration\n * @example\n *  // DataModel already prepared and assigned to dm vairable\n *  const config = { binCount: 5, name: 'binnedHP' }\n *  const binFn = bin('horsepower', config);\n *  const binnedDm = binFn(Dm);\n *\n * @text\n * When `binSize` is defined as part of binning configuration\n * @example\n *  // DataModel already prepared and assigned to dm vairable\n *  const config = { binSize: 200, name: 'binnedHorsepower' }\n *  const binnedDm = dataModel.bin('horsepower', config);\n *  const binnedDm = binFn(Dm);\n *\n * @public\n * @namespace DataModel\n * @module Operators\n *\n * @param {String} name Name of measure which will be used to create bin\n * @param {Object} config Config required for bin creation\n * @param {Array.<Number>} config.bucketObj.stops Defination of bucket ranges. Two subsequent number from arrays\n *      are picked and a range is created. The first number from range is inclusive and the second number from range\n *      is exclusive.\n * @param {Number} [config.bucketObj.startAt] Force the start of the bin from a particular number.\n *      If not mentioned, the start of the bin or the lower domain of the data if stops is not mentioned, else its\n *      the first value of the stop.\n * @param {Number} config.binSize Bucket size for each bin\n * @param {Number} config.binCount Number of bins which will be created\n * @param {String} config.name Name of the new binned field to be created\n *\n * @return {PreparatorFunction} Function which expects an instance of DataModel on which the operator needs to be\n *      applied.\n */\nexport const bin = (...args) => dm => dm.bin(...args);\n\n/**\n * This is functional version of `groupBy` operator.Groups the data using particular dimensions and by reducing\n * measures. It expects a list of dimensions using which it projects the datamodel and perform aggregations to reduce\n * the duplicate tuples. Refer this {@link link_to_one_example_with_group_by | document} to know the intuition behind\n * groupBy.\n *\n * DataModel by default provides definition of few {@link reducer | Reducers}.\n * {@link ReducerStore | User defined reducers} can also be registered.\n *\n * This is the chained implementation of `groupBy`.\n * `groupBy` also supports {@link link_to_compose_groupBy | composability}\n *\n * @example\n * const groupBy = DataModel.Operators.groupBy;\n * const groupedFn = groupBy(['Year'], { horsepower: 'max' } );\n * groupedDM = groupByFn(dm);\n *\n * @public\n *\n * @param {Array.<string>} fieldsArr - Array containing the name of dimensions\n * @param {Object} [reducers={}] - A map whose key is the variable name and value is the name of the reducer. If its\n *      not passed, or any variable is ommitted from the object, default aggregation function is used from the\n *      schema of the variable.\n *\n * @return {PreparatorFunction} Function which expects an instance of DataModel on which the operator needs to be\n *      applied.\n */\nexport const groupBy = (...args) => dm => dm.groupBy(...args);\n\n/**\n * Enables composing operators to run multiple operations and save group of operataion as named opration on a DataModel.\n * The resulting DataModel will be the result of all the operation provided. The operations provided will be executed in\n * a serial manner ie. result of one operation will be the input for the next operations (like pipe operator in unix).\n *\n * Suported operations in compose are\n * - `select`\n * - `project`\n * - `groupBy`\n * - `bin`\n * - `compose`\n *\n * @example\n * const compose = DataModel.Operators.compose;\n * const select = DataModel.Operators.select;\n * const project = DataModel.Operators.project;\n *\n * let composedFn = compose(\n *    select(fields => fields.netprofit.value <= 15),\n *    project(['netprofit', 'netsales']));\n *\n * const dataModel = new DataModel(data1, schema1);\n *\n * let composedDm = composedFn(dataModel);\n *\n * @public\n * @namespace DataModel\n * @module Operators\n *\n * @param {Array.<Operators>} operators: An array of operation that will be applied on the\n * datatable.\n *\n * @returns {DataModel} Instance of resultant DataModel\n */\nexport const compose = (...operations) =>\n    (dm, config = { saveChild: true }) => {\n        let currentDM = dm;\n        let firstChild;\n        const derivations = [];\n\n        operations.forEach((operation) => {\n            currentDM = operation(currentDM);\n            derivations.push(...currentDM._derivation);\n            if (!firstChild) {\n                firstChild = currentDM;\n            }\n        });\n\n        if (firstChild && firstChild !== currentDM) {\n            firstChild.dispose();\n        }\n\n        // reset all ancestorDerivation saved in-between compose\n        currentDM._ancestorDerivation = [];\n        persistDerivations(\n            dm,\n            currentDM,\n            DM_DERIVATIVES.COMPOSE,\n            null,\n            derivations\n        );\n\n        if (config.saveChild) {\n            currentDM.setParent(dm);\n        } else {\n            currentDM.setParent(null);\n        }\n\n        return currentDM;\n    };\n","import DataModel from '../datamodel';\nimport { extend2 } from '../utils';\nimport { getCommonSchema } from './get-common-schema';\nimport { rowDiffsetIterator } from './row-diffset-iterator';\nimport { JOINS } from '../constants';\nimport { prepareJoinData } from '../helper';\n/**\n * Default filter function for crossProduct.\n *\n * @return {boolean} Always returns true.\n */\nfunction defaultFilterFn() { return true; }\n\n/**\n * Implementation of cross product operation between two DataModel instances.\n * It internally creates the data and schema for the new DataModel.\n *\n * @param {DataModel} dataModel1 - The left DataModel instance.\n * @param {DataModel} dataModel2 - The right DataModel instance.\n * @param {Function} filterFn - The filter function which is used to filter the tuples.\n * @param {boolean} [replaceCommonSchema=false] - The flag if the common name schema should be there.\n * @return {DataModel} Returns The newly created DataModel instance from the crossProduct operation.\n */\nexport function crossProduct (dm1, dm2, filterFn, replaceCommonSchema = false, jointype = JOINS.CROSS) {\n    const schema = [];\n    const data = [];\n    const applicableFilterFn = filterFn || defaultFilterFn;\n    const dm1FieldStore = dm1.getFieldspace();\n    const dm2FieldStore = dm2.getFieldspace();\n    const dm1FieldStoreName = dm1FieldStore.name;\n    const dm2FieldStoreName = dm2FieldStore.name;\n    const name = `${dm1FieldStore.name}.${dm2FieldStore.name}`;\n    const commonSchemaList = getCommonSchema(dm1FieldStore, dm2FieldStore);\n\n    if (dm1FieldStoreName === dm2FieldStoreName) {\n        throw new Error('DataModels must have different alias names');\n    }\n    // Here prepare the schema\n    dm1FieldStore.fields.forEach((field) => {\n        const tmpSchema = extend2({}, field.schema());\n        if (commonSchemaList.indexOf(tmpSchema.name) !== -1 && !replaceCommonSchema) {\n            tmpSchema.name = `${dm1FieldStore.name}.${tmpSchema.name}`;\n        }\n        schema.push(tmpSchema);\n    });\n    dm2FieldStore.fields.forEach((field) => {\n        const tmpSchema = extend2({}, field.schema());\n        if (commonSchemaList.indexOf(tmpSchema.name) !== -1) {\n            if (!replaceCommonSchema) {\n                tmpSchema.name = `${dm2FieldStore.name}.${tmpSchema.name}`;\n                schema.push(tmpSchema);\n            }\n        } else {\n            schema.push(tmpSchema);\n        }\n    });\n\n    // Here prepare Data\n    rowDiffsetIterator(dm1._rowDiffset, (i) => {\n        let rowAdded = false;\n        let rowPosition;\n        rowDiffsetIterator(dm2._rowDiffset, (ii) => {\n            const tuple = [];\n            const userArg = {};\n            userArg[dm1FieldStoreName] = {};\n            userArg[dm2FieldStoreName] = {};\n            dm1FieldStore.fields.forEach((field) => {\n                tuple.push(field.partialField.data[i]);\n                userArg[dm1FieldStoreName][field.name()] = field.partialField.data[i];\n            });\n            dm2FieldStore.fields.forEach((field) => {\n                if (!(commonSchemaList.indexOf(field.schema().name) !== -1 && replaceCommonSchema)) {\n                    tuple.push(field.partialField.data[ii]);\n                }\n                userArg[dm2FieldStoreName][field.name()] = field.partialField.data[ii];\n            });\n\n            let cachedStore = {};\n            let cloneProvider1 = () => dm1.detachedRoot();\n            let cloneProvider2 = () => dm2.detachedRoot();\n\n            const dm1Fields = prepareJoinData(userArg[dm1FieldStoreName]);\n            const dm2Fields = prepareJoinData(userArg[dm2FieldStoreName]);\n            if (applicableFilterFn(dm1Fields, dm2Fields, cloneProvider1, cloneProvider2, cachedStore)) {\n                const tupleObj = {};\n                tuple.forEach((cellVal, iii) => {\n                    tupleObj[schema[iii].name] = cellVal;\n                });\n                if (rowAdded && JOINS.CROSS !== jointype) {\n                    data[rowPosition] = tupleObj;\n                }\n                else {\n                    data.push(tupleObj);\n                    rowAdded = true;\n                    rowPosition = i;\n                }\n            } else if ((jointype === JOINS.LEFTOUTER || jointype === JOINS.RIGHTOUTER) && !rowAdded) {\n                const tupleObj = {};\n                let len = dm1FieldStore.fields.length - 1;\n                tuple.forEach((cellVal, iii) => {\n                    if (iii <= len) {\n                        tupleObj[schema[iii].name] = cellVal;\n                    }\n                    else {\n                        tupleObj[schema[iii].name] = null;\n                    }\n                });\n                rowAdded = true;\n                rowPosition = i;\n                data.push(tupleObj);\n            }\n        });\n    });\n\n    return new DataModel(data, schema, { name });\n}\n","import { DimensionSubtype, MeasureSubtype } from '../enums';\nimport { rowDiffsetIterator } from './row-diffset-iterator';\nimport { mergeSort } from './merge-sort';\nimport { fieldInSchema } from '../helper';\nimport { isCallable, isArray, } from '../utils';\n/**\n * Generates the sorting functions to sort the data of a DataModel instance\n * according to the input data type.\n *\n * @param {string} dataType - The data type e.g. 'measure', 'datetime' etc.\n * @param {string} sortType - The sorting order i.e. 'asc' or 'desc'.\n * @param {integer} index - The index of the data which will be sorted.\n * @return {Function} Returns the the sorting function.\n */\nfunction getSortFn (dataType, sortType, index) {\n    let retFunc;\n    switch (dataType) {\n    case MeasureSubtype.CONTINUOUS:\n    case DimensionSubtype.TEMPORAL:\n        if (sortType === 'desc') {\n            retFunc = (a, b) => b[index] - a[index];\n        } else {\n            retFunc = (a, b) => a[index] - b[index];\n        }\n        break;\n    default:\n        retFunc = (a, b) => {\n            const a1 = `${a[index]}`;\n            const b1 = `${b[index]}`;\n            if (a1 < b1) {\n                return sortType === 'desc' ? 1 : -1;\n            }\n            if (a1 > b1) {\n                return sortType === 'desc' ? -1 : 1;\n            }\n            return 0;\n        };\n    }\n    return retFunc;\n}\n\n/**\n * Groups the data according to the specified target field.\n *\n * @param {Array} data - The input data array.\n * @param {number} fieldIndex - The target field index within schema array.\n * @return {Array} Returns an array containing the grouped data.\n */\nfunction groupData(data, fieldIndex) {\n    const hashMap = new Map();\n    const groupedData = [];\n\n    data.forEach((datum) => {\n        const fieldVal = datum[fieldIndex];\n        if (hashMap.has(fieldVal)) {\n            groupedData[hashMap.get(fieldVal)][1].push(datum);\n        } else {\n            groupedData.push([fieldVal, [datum]]);\n            hashMap.set(fieldVal, groupedData.length - 1);\n        }\n    });\n\n    return groupedData;\n}\n\n/**\n * Creates the argument value used for sorting function when sort is done\n * with another fields.\n *\n * @param {Array} groupedDatum - The grouped datum for a single dimension field value.\n * @param {Array} targetFields - An array of the sorting fields.\n * @param {Array} targetFieldDetails - An array of the sorting field details in schema.\n * @return {Object} Returns an object containing the value of sorting fields and the target field name.\n */\nfunction createSortingFnArg(groupedDatum, targetFields, targetFieldDetails) {\n    const arg = {\n        label: groupedDatum[0]\n    };\n\n    targetFields.reduce((acc, next, idx) => {\n        acc[next] = groupedDatum[1].map(datum => datum[targetFieldDetails[idx].index]);\n        return acc;\n    }, arg);\n\n    return arg;\n}\n\n/**\n * Sorts the data before return in dataBuilder.\n *\n * @param {Object} dataObj - An object containing the data and schema.\n * @param {Array} sortingDetails - An array containing the sorting configs.\n */\nfunction sortData(dataObj, sortingDetails) {\n    const { data, schema } = dataObj;\n    let fieldName;\n    let sortMeta;\n    let fDetails;\n    let i = sortingDetails.length - 1;\n\n    for (; i >= 0; i--) {\n        fieldName = sortingDetails[i][0];\n        sortMeta = sortingDetails[i][1];\n        fDetails = fieldInSchema(schema, fieldName);\n\n        if (!fDetails) {\n            // eslint-disable-next-line no-continue\n            continue;\n        }\n\n        if (isCallable(sortMeta)) {\n            // eslint-disable-next-line no-loop-func\n            mergeSort(data, (a, b) => sortMeta(a[fDetails.index], b[fDetails.index]));\n        } else if (isArray(sortMeta)) {\n            const groupedData = groupData(data, fDetails.index);\n            const sortingFn = sortMeta[sortMeta.length - 1];\n            const targetFields = sortMeta.slice(0, sortMeta.length - 1);\n            const targetFieldDetails = targetFields.map(f => fieldInSchema(schema, f));\n\n            groupedData.forEach((groupedDatum) => {\n                groupedDatum.push(createSortingFnArg(groupedDatum, targetFields, targetFieldDetails));\n            });\n\n            mergeSort(groupedData, (a, b) => {\n                const m = a[2];\n                const n = b[2];\n                return sortingFn(m, n);\n            });\n\n            // Empty the array\n            data.length = 0;\n            groupedData.forEach((datum) => {\n                data.push(...datum[1]);\n            });\n        } else {\n            sortMeta = String(sortMeta).toLowerCase() === 'desc' ? 'desc' : 'asc';\n            mergeSort(data, getSortFn(fDetails.type, sortMeta, fDetails.index));\n        }\n    }\n\n    dataObj.uids = [];\n    data.forEach((value) => {\n        dataObj.uids.push(value.pop());\n    });\n}\n\n\n/**\n * Builds the actual data array.\n *\n * @param {Array} fieldStore - An array of field.\n * @param {string} rowDiffset - A string consisting of which rows to be included eg. '0-2,4,6';\n * @param {string} colIdentifier - A string consisting of the details of which column\n * to be included eg 'date,sales,profit';\n * @param {Object} sortingDetails - An object containing the sorting details of the DataModel instance.\n * @param {Object} options - The options required to create the type of the data.\n * @return {Object} Returns an object containing the multidimensional array and the relative schema.\n */\nexport function dataBuilder (fieldStore, rowDiffset, colIdentifier, sortingDetails, options) {\n    const defOptions = {\n        addUid: false,\n        columnWise: false\n    };\n    options = Object.assign({}, defOptions, options);\n\n    const retObj = {\n        schema: [],\n        data: [],\n        uids: []\n    };\n    const addUid = options.addUid;\n    const reqSorting = sortingDetails && sortingDetails.length > 0;\n    // It stores the fields according to the colIdentifier argument\n    const tmpDataArr = [];\n    // Stores the fields according to the colIdentifier argument\n    const colIArr = colIdentifier.split(',');\n\n    colIArr.forEach((colName) => {\n        for (let i = 0; i < fieldStore.length; i += 1) {\n            if (fieldStore[i].name() === colName) {\n                tmpDataArr.push(fieldStore[i]);\n                break;\n            }\n        }\n    });\n\n    // Inserts the schema to the schema object\n    tmpDataArr.forEach((field) => {\n        /** @todo Need to use extend2 here otherwise user can overwrite the schema. */\n        retObj.schema.push(field.schema());\n    });\n\n    if (addUid) {\n        retObj.schema.push({\n            name: 'uid',\n            type: 'identifier'\n        });\n    }\n\n    rowDiffsetIterator(rowDiffset, (i) => {\n        retObj.data.push([]);\n        const insertInd = retObj.data.length - 1;\n        let start = 0;\n        tmpDataArr.forEach((field, ii) => {\n            retObj.data[insertInd][ii + start] = field.partialField.data[i];\n        });\n        if (addUid) {\n            retObj.data[insertInd][tmpDataArr.length] = i;\n        }\n        // Creates an array of unique identifiers for each row\n        retObj.uids.push(i);\n\n        // If sorting needed then there is the need to expose the index\n        // mapping from the old index to its new index\n        if (reqSorting) { retObj.data[insertInd].push(i); }\n    });\n\n    // Handles the sort functionality\n    if (reqSorting) {\n        sortData(retObj, sortingDetails);\n    }\n\n    if (options.columnWise) {\n        const tmpData = Array(...Array(retObj.schema.length)).map(() => []);\n        retObj.data.forEach((tuple) => {\n            tuple.forEach((data, i) => {\n                tmpData[i].push(data);\n            });\n        });\n        retObj.data = tmpData;\n    }\n\n    return retObj;\n}\n","import DataModel from '../datamodel';\nimport { extend2 } from '../utils';\nimport { rowDiffsetIterator } from './row-diffset-iterator';\nimport { isArrEqual } from '../utils/helper';\n\n/**\n * Performs the union operation between two dm instances.\n *\n * @todo Fix the conflicts between union and difference terminology here.\n *\n * @param {dm} dm1 - The first dm instance.\n * @param {dm} dm2 - The second dm instance.\n * @return {dm} Returns the newly created dm after union operation.\n */\nexport function difference (dm1, dm2) {\n    const hashTable = {};\n    const schema = [];\n    const schemaNameArr = [];\n    const data = [];\n    const dm1FieldStore = dm1.getFieldspace();\n    const dm2FieldStore = dm2.getFieldspace();\n    const dm1FieldStoreFieldObj = dm1FieldStore.fieldsObj();\n    const dm2FieldStoreFieldObj = dm2FieldStore.fieldsObj();\n    const name = `${dm1FieldStore.name} union ${dm2FieldStore.name}`;\n\n   // For union the columns should match otherwise return a clone of the dm1\n    if (!isArrEqual(dm1._colIdentifier.split(',').sort(), dm2._colIdentifier.split(',').sort())) {\n        return null;\n    }\n\n    // Prepare the schema\n    (dm1._colIdentifier.split(',')).forEach((fieldName) => {\n        const field = dm1FieldStoreFieldObj[fieldName];\n        schema.push(extend2({}, field.schema()));\n        schemaNameArr.push(field.schema().name);\n    });\n\n    /**\n     * The helper function to create the data.\n     *\n     * @param {dm} dm - The dm instance for which the data is inserted.\n     * @param {Object} fieldsObj - The fieldStore object format.\n     * @param {boolean} addData - If true only tuple will be added to the data.\n     */\n    function prepareDataHelper(dm, fieldsObj, addData) {\n        rowDiffsetIterator(dm._rowDiffset, (i) => {\n            const tuple = {};\n            let hashData = '';\n            schemaNameArr.forEach((schemaName) => {\n                const value = fieldsObj[schemaName].partialField.data[i];\n                hashData += `-${value}`;\n                tuple[schemaName] = value;\n            });\n            if (!hashTable[hashData]) {\n                if (addData) { data.push(tuple); }\n                hashTable[hashData] = true;\n            }\n        });\n    }\n\n    // Prepare the data\n    prepareDataHelper(dm2, dm2FieldStoreFieldObj, false);\n    prepareDataHelper(dm1, dm1FieldStoreFieldObj, true);\n\n    return new DataModel(data, schema, { name });\n}\n\n","/**\n * The helper function that returns an array of common schema\n * from two fieldStore instances.\n *\n * @param {FieldStore} fs1 - The first FieldStore instance.\n * @param {FieldStore} fs2 - The second FieldStore instance.\n * @return {Array} An array containing the common schema.\n */\nexport function getCommonSchema (fs1, fs2) {\n    const retArr = [];\n    const fs1Arr = [];\n    fs1.fields.forEach((field) => {\n        fs1Arr.push(field.schema().name);\n    });\n    fs2.fields.forEach((field) => {\n        if (fs1Arr.indexOf(field.schema().name) !== -1) {\n            retArr.push(field.schema().name);\n        }\n    });\n    return retArr;\n}\n","import { isArray } from '../utils';\nimport InvalidAwareTypes from '../invalid-aware-types';\nimport { GROUP_BY_FUNCTIONS } from '../enums';\n\nconst { SUM, AVG, FIRST, LAST, COUNT, STD, MIN, MAX } = GROUP_BY_FUNCTIONS;\n\nfunction getFilteredValues(arr) {\n    return arr.filter(item => !(item instanceof InvalidAwareTypes));\n}\n/**\n * Reducer function that returns the sum of all the values.\n *\n * @public\n * @param  {Array.<number>} arr - The input array.\n * @return {number} Returns the sum of the array.\n */\nfunction sum (arr) {\n    if (isArray(arr) && !(arr[0] instanceof Array)) {\n        const filteredNumber = getFilteredValues(arr);\n        const totalSum = filteredNumber.length ?\n                            filteredNumber.reduce((acc, curr) => acc + curr, 0)\n                            : InvalidAwareTypes.NULL;\n        return totalSum;\n    }\n    return InvalidAwareTypes.NULL;\n}\n\n/**\n * Reducer function that returns the average of all the values.\n *\n * @public\n * @param  {Array.<number>} arr - The input array.\n * @return {number} Returns the mean value of the array.\n */\nfunction avg (arr) {\n    if (isArray(arr) && !(arr[0] instanceof Array)) {\n        const totalSum = sum(arr);\n        const len = arr.length || 1;\n        return (Number.isNaN(totalSum) || totalSum instanceof InvalidAwareTypes) ?\n                 InvalidAwareTypes.NULL : totalSum / len;\n    }\n    return InvalidAwareTypes.NULL;\n}\n\n/**\n * Reducer function that gives the min value amongst all the values.\n *\n * @public\n * @param  {Array.<number>} arr - The input array.\n * @return {number} Returns the minimum value of the array.\n */\nfunction min (arr) {\n    if (isArray(arr) && !(arr[0] instanceof Array)) {\n        // Filter out undefined, null and NaN values\n        const filteredValues = getFilteredValues(arr);\n\n        return (filteredValues.length) ? Math.min(...filteredValues) : InvalidAwareTypes.NULL;\n    }\n    return InvalidAwareTypes.NULL;\n}\n\n/**\n * Reducer function that gives the max value amongst all the values.\n *\n * @public\n * @param  {Array.<number>} arr - The input array.\n * @return {number} Returns the maximum value of the array.\n */\nfunction max (arr) {\n    if (isArray(arr) && !(arr[0] instanceof Array)) {\n        // Filter out undefined, null and NaN values\n        const filteredValues = getFilteredValues(arr);\n\n        return (filteredValues.length) ? Math.max(...filteredValues) : InvalidAwareTypes.NULL;\n    }\n    return InvalidAwareTypes.NULL;\n}\n\n/**\n * Reducer function that gives the first value of the array.\n *\n * @public\n * @param  {Array} arr - The input array.\n * @return {number} Returns the first value of the array.\n */\nfunction first (arr) {\n    return arr[0];\n}\n\n/**\n * Reducer function that gives the last value of the array.\n *\n * @public\n * @param  {Array} arr - The input array.\n * @return {number} Returns the last value of the array.\n */\nfunction last (arr) {\n    return arr[arr.length - 1];\n}\n\n/**\n * Reducer function that gives the count value of the array.\n *\n * @public\n * @param  {Array} arr - The input array.\n * @return {number} Returns the length of the array.\n */\nfunction count (arr) {\n    if (isArray(arr)) {\n        return arr.length;\n    }\n    return InvalidAwareTypes.NULL;\n}\n\n/**\n * Calculates the variance of the input array.\n *\n * @param  {Array.<number>} arr - The input array.\n * @return {number} Returns the variance of the input array.\n */\nfunction variance (arr) {\n    let mean = avg(arr);\n    return avg(arr.map(num => (num - mean) ** 2));\n}\n\n/**\n * Calculates the square root of the variance of the input array.\n *\n * @public\n * @param  {Array.<number>} arr - The input array.\n * @return {number} Returns the square root of the variance.\n */\nfunction std (arr) {\n    return Math.sqrt(variance(arr));\n}\n\n\nconst fnList = {\n    [SUM]: sum,\n    [AVG]: avg,\n    [MIN]: min,\n    [MAX]: max,\n    [FIRST]: first,\n    [LAST]: last,\n    [COUNT]: count,\n    [STD]: std\n};\n\nconst defaultReducerName = SUM;\n\nexport {\n    defaultReducerName,\n    sum as defReducer,\n    fnList,\n};\n","import { extend2 } from '../utils';\nimport { rowDiffsetIterator } from './row-diffset-iterator';\nimport DataModel from '../export';\nimport reducerStore from '../utils/reducer-store';\nimport { defaultReducerName } from './group-by-function';\nimport { FieldType } from '../enums';\n\n/**\n * This function sanitize the user given field and return a common Array structure field\n * list\n * @param  {DataModel} dataModel the dataModel operating on\n * @param  {Array} fieldArr  user input of field Array\n * @return {Array}           arrays of field name\n */\nfunction getFieldArr (dataModel, fieldArr) {\n    const retArr = [];\n    const fieldStore = dataModel.getFieldspace();\n    const dimensions = fieldStore.getDimension();\n\n    Object.entries(dimensions).forEach(([key]) => {\n        if (fieldArr && fieldArr.length) {\n            if (fieldArr.indexOf(key) !== -1) {\n                retArr.push(key);\n            }\n        } else {\n            retArr.push(key);\n        }\n    });\n\n    return retArr;\n}\n\n/**\n * This sanitize the reducer provide by the user and create a common type of object.\n * user can give function Also\n * @param  {DataModel} dataModel     dataModel to worked on\n * @param  {Object|function} [reducers={}] reducer provided by the users\n * @return {Object}               object containing reducer function for every measure\n */\nfunction getReducerObj (dataModel, reducers = {}) {\n    const retObj = {};\n    const fieldStore = dataModel.getFieldspace();\n    const measures = fieldStore.getMeasure();\n    const defReducer = reducerStore.defaultReducer();\n\n    Object.keys(measures).forEach((measureName) => {\n        if (typeof reducers[measureName] !== 'string') {\n            reducers[measureName] = measures[measureName].defAggFn();\n        }\n        const reducerFn = reducerStore.resolve(reducers[measureName]);\n        if (reducerFn) {\n            retObj[measureName] = reducerFn;\n        } else {\n            retObj[measureName] = defReducer;\n            reducers[measureName] = defaultReducerName;\n        }\n    });\n    return retObj;\n}\n\n/**\n * main function which perform the group-by operations which reduce the measures value is the\n * fields are common according to the reducer function provided\n * @param  {DataModel} dataModel the dataModel to worked\n * @param  {Array} fieldArr  fields according to which the groupby should be worked\n * @param  {Object|Function} reducers  reducers function\n * @param {DataModel} existingDataModel Existing datamodel instance\n * @return {DataModel} new dataModel with the group by\n */\nfunction groupBy (dataModel, fieldArr, reducers, existingDataModel) {\n    const sFieldArr = getFieldArr(dataModel, fieldArr);\n    const reducerObj = getReducerObj(dataModel, reducers);\n    const fieldStore = dataModel.getFieldspace();\n    const fieldStoreObj = fieldStore.fieldsObj();\n    const dbName = fieldStore.name;\n    const dimensionArr = [];\n    const measureArr = [];\n    const schema = [];\n    const hashMap = {};\n    const data = [];\n    let newDataModel;\n\n    // Prepare the schema\n    Object.entries(fieldStoreObj).forEach(([key, value]) => {\n        if (sFieldArr.indexOf(key) !== -1 || reducerObj[key]) {\n            schema.push(extend2({}, value.schema()));\n\n            switch (value.schema().type) {\n            case FieldType.MEASURE:\n                measureArr.push(key);\n                break;\n            default:\n            case FieldType.DIMENSION:\n                dimensionArr.push(key);\n            }\n        }\n    });\n    // Prepare the data\n    let rowCount = 0;\n    rowDiffsetIterator(dataModel._rowDiffset, (i) => {\n        let hash = '';\n        dimensionArr.forEach((_) => {\n            hash = `${hash}-${fieldStoreObj[_].partialField.data[i]}`;\n        });\n        if (hashMap[hash] === undefined) {\n            hashMap[hash] = rowCount;\n            data.push({});\n            dimensionArr.forEach((_) => {\n                data[rowCount][_] = fieldStoreObj[_].partialField.data[i];\n            });\n            measureArr.forEach((_) => {\n                data[rowCount][_] = [fieldStoreObj[_].partialField.data[i]];\n            });\n            rowCount += 1;\n        } else {\n            measureArr.forEach((_) => {\n                data[hashMap[hash]][_].push(fieldStoreObj[_].partialField.data[i]);\n            });\n        }\n    });\n\n    // reduction\n    let cachedStore = {};\n    let cloneProvider = () => dataModel.detachedRoot();\n    data.forEach((row) => {\n        const tuple = row;\n        measureArr.forEach((_) => {\n            tuple[_] = reducerObj[_](row[_], cloneProvider, cachedStore);\n        });\n    });\n    if (existingDataModel) {\n        existingDataModel.__calculateFieldspace();\n        newDataModel = existingDataModel;\n    }\n    else {\n        newDataModel = new DataModel(data, schema, { name: dbName });\n    }\n    return newDataModel;\n}\n\nexport { groupBy, getFieldArr, getReducerObj };\n","export { createBinnedFieldData } from './bucket-creator';\nexport { compose, bin, select, project, groupBy as groupby } from './compose';\nexport { calculateVariable, sort } from './pure-operators';\nexport { crossProduct } from './cross-product';\nexport { dataBuilder } from './data-builder';\nexport { difference } from './difference';\nexport { getCommonSchema } from './get-common-schema';\nexport { defReducer, fnList } from './group-by-function';\nexport { groupBy, getFieldArr, getReducerObj } from './group-by';\nexport { mergeSort } from './merge-sort';\nexport { naturalJoinFilter } from './natural-join-filter-function';\nexport { naturalJoin } from './natural-join';\nexport { leftOuterJoin, rightOuterJoin, fullOuterJoin } from './outer-join';\nexport { rowDiffsetIterator } from './row-diffset-iterator';\nexport { union } from './union';\n","/**\n * The default sort function.\n *\n * @param {*} a - The first value.\n * @param {*} b - The second value.\n * @return {number} Returns the comparison result e.g. 1 or 0 or -1.\n */\nfunction defSortFn (a, b) {\n    const a1 = `${a}`;\n    const b1 = `${b}`;\n    if (a1 < b1) {\n        return -1;\n    }\n    if (a1 > b1) {\n        return 1;\n    }\n    return 0;\n}\n\n/**\n * The helper function for merge sort which creates the sorted array\n * from the two halves of the input array.\n *\n * @param {Array} arr - The target array which needs to be merged.\n * @param {number} lo - The starting index of the first array half.\n * @param {number} mid - The ending index of the first array half.\n * @param {number} hi - The ending index of the second array half.\n * @param {Function} sortFn - The sort function.\n */\nfunction merge (arr, lo, mid, hi, sortFn) {\n    const mainArr = arr;\n    const auxArr = [];\n    for (let i = lo; i <= hi; i += 1) {\n        auxArr[i] = mainArr[i];\n    }\n    let a = lo;\n    let b = mid + 1;\n\n    for (let i = lo; i <= hi; i += 1) {\n        if (a > mid) {\n            mainArr[i] = auxArr[b];\n            b += 1;\n        } else if (b > hi) {\n            mainArr[i] = auxArr[a];\n            a += 1;\n        } else if (sortFn(auxArr[a], auxArr[b]) <= 0) {\n            mainArr[i] = auxArr[a];\n            a += 1;\n        } else {\n            mainArr[i] = auxArr[b];\n            b += 1;\n        }\n    }\n}\n\n/**\n * The helper function for merge sort which would be called\n * recursively for sorting the array halves.\n *\n * @param {Array} arr - The target array which needs to be sorted.\n * @param {number} lo - The starting index of the array half.\n * @param {number} hi - The ending index of the array half.\n * @param {Function} sortFn - The sort function.\n * @return {Array} Returns the target array itself.\n */\nfunction sort (arr, lo, hi, sortFn) {\n    if (hi === lo) { return arr; }\n\n    const mid = lo + Math.floor((hi - lo) / 2);\n    sort(arr, lo, mid, sortFn);\n    sort(arr, mid + 1, hi, sortFn);\n    merge(arr, lo, mid, hi, sortFn);\n\n    return arr;\n}\n\n/**\n * The implementation of merge sort.\n * It is used in DataModel for stable sorting as it is not sure\n * what the sorting algorithm used by browsers is stable or not.\n *\n * @param {Array} arr - The target array which needs to be sorted.\n * @param {Function} [sortFn=defSortFn] - The sort function.\n * @return {Array} Returns the input array itself in sorted order.\n */\nexport function mergeSort (arr, sortFn = defSortFn) {\n    if (arr.length > 1) {\n        sort(arr, 0, arr.length - 1, sortFn);\n    }\n    return arr;\n}\n","import { getCommonSchema } from './get-common-schema';\n\n/**\n * The filter function used in natural join.\n * It generates a function that will have the logic to join two\n * DataModel instances by the process of natural join.\n *\n * @param {DataModel} dm1 - The left DataModel instance.\n * @param {DataModel} dm2 - The right DataModel instance.\n * @return {Function} Returns a function that is used in cross-product operation.\n */\nexport function naturalJoinFilter (dm1, dm2) {\n    const dm1FieldStore = dm1.getFieldspace();\n    const dm2FieldStore = dm2.getFieldspace();\n    // const dm1FieldStoreName = dm1FieldStore.name;\n    // const dm2FieldStoreName = dm2FieldStore.name;\n    const commonSchemaArr = getCommonSchema(dm1FieldStore, dm2FieldStore);\n\n    return (dm1Fields, dm2Fields) => {\n        let retainTuple = true;\n        commonSchemaArr.forEach((fieldName) => {\n            if (dm1Fields[fieldName].value ===\n                dm2Fields[fieldName].value && retainTuple) {\n                retainTuple = true;\n            } else {\n                retainTuple = false;\n            }\n        });\n        return retainTuple;\n    };\n}\n","import { crossProduct } from './cross-product';\nimport { naturalJoinFilter } from './natural-join-filter-function';\n\nexport function naturalJoin (dataModel1, dataModel2) {\n    return crossProduct(dataModel1, dataModel2, naturalJoinFilter(dataModel1, dataModel2), true);\n}\n","import { crossProduct } from './cross-product';\nimport { JOINS } from '../constants';\nimport { union } from './union';\n\n\nexport function leftOuterJoin (dataModel1, dataModel2, filterFn) {\n    return crossProduct(dataModel1, dataModel2, filterFn, false, JOINS.LEFTOUTER);\n}\n\nexport function rightOuterJoin (dataModel1, dataModel2, filterFn) {\n    return crossProduct(dataModel2, dataModel1, filterFn, false, JOINS.RIGHTOUTER);\n}\n\nexport function fullOuterJoin (dataModel1, dataModel2, filterFn) {\n    return union(leftOuterJoin(dataModel1, dataModel2, filterFn), rightOuterJoin(dataModel1, dataModel2, filterFn));\n}\n","/**\n * Wrapper on calculateVariable() method of DataModel to behave\n * the pure-function functionality.\n *\n * @param {Array} args - The argument list.\n * @return {any} Returns the returned value of calling function.\n */\nexport const calculateVariable = (...args) => dm => dm.calculateVariable(...args);\n\n/**\n * Wrapper on sort() method of DataModel to behave\n * the pure-function functionality.\n *\n * @param {Array} args - The argument list.\n * @return {any} Returns the returned value of calling function.\n */\nexport const sort = (...args) => dm => dm.sort(...args);\n","/**\n * Iterates through the diffSet array and call the callback with the current\n * index.\n *\n * @param {string} rowDiffset - The row diffset string e.g. '0-4,6,10-13'.\n * @param {Function} callback - The callback function to be called with every index.\n */\nexport function rowDiffsetIterator (rowDiffset, callback) {\n    if (rowDiffset.length > 0) {\n        const rowDiffArr = rowDiffset.split(',');\n        rowDiffArr.forEach((diffStr) => {\n            const diffStsArr = diffStr.split('-');\n            const start = +(diffStsArr[0]);\n            const end = +(diffStsArr[1] || diffStsArr[0]);\n            if (end >= start) {\n                for (let i = start; i <= end; i += 1) {\n                    callback(i);\n                }\n            }\n        });\n    }\n}\n","import DataModel from '../export';\nimport { extend2 } from '../utils';\nimport { rowDiffsetIterator } from './row-diffset-iterator';\nimport { isArrEqual } from '../utils/helper';\n/**\n * Performs the union operation between two dm instances.\n *\n * @param {dm} dm1 - The first dm instance.\n * @param {dm} dm2 - The second dm instance.\n * @return {dm} Returns the newly created dm after union operation.\n */\nexport function union (dm1, dm2) {\n    const hashTable = {};\n    const schema = [];\n    const schemaNameArr = [];\n    const data = [];\n    const dm1FieldStore = dm1.getFieldspace();\n    const dm2FieldStore = dm2.getFieldspace();\n    const dm1FieldStoreFieldObj = dm1FieldStore.fieldsObj();\n    const dm2FieldStoreFieldObj = dm2FieldStore.fieldsObj();\n    const name = `${dm1FieldStore.name} union ${dm2FieldStore.name}`;\n\n    // For union the columns should match otherwise return a clone of the dm1\n    if (!isArrEqual(dm1._colIdentifier.split(',').sort(), dm2._colIdentifier.split(',').sort())) {\n        return null;\n    }\n\n    // Prepare the schema\n    (dm1._colIdentifier.split(',')).forEach((fieldName) => {\n        const field = dm1FieldStoreFieldObj[fieldName];\n        schema.push(extend2({}, field.schema()));\n        schemaNameArr.push(field.schema().name);\n    });\n\n    /**\n     * The helper function to create the data.\n     *\n     * @param {dm} dm - The dm instance for which the data is inserted.\n     * @param {Object} fieldsObj - The fieldStore object format.\n     */\n    function prepareDataHelper (dm, fieldsObj) {\n        rowDiffsetIterator(dm._rowDiffset, (i) => {\n            const tuple = {};\n            let hashData = '';\n            schemaNameArr.forEach((schemaName) => {\n                const value = fieldsObj[schemaName].partialField.data[i];\n                hashData += `-${value}`;\n                tuple[schemaName] = value;\n            });\n            if (!hashTable[hashData]) {\n                data.push(tuple);\n                hashTable[hashData] = true;\n            }\n        });\n    }\n\n    // Prepare the data\n    prepareDataHelper(dm1, dm1FieldStoreFieldObj);\n    prepareDataHelper(dm2, dm2FieldStoreFieldObj);\n\n    return new DataModel(data, schema, { name });\n}\n","import { FilteringMode } from './enums';\nimport { getUniqueId } from './utils';\nimport { updateFields, cloneWithSelect, cloneWithProject, updateData } from './helper';\nimport { crossProduct, difference, naturalJoinFilter, union } from './operator';\n\n/**\n * Relation provides the definitions of basic operators of relational algebra like *selection*, *projection*, *union*,\n * *difference* etc.\n *\n * It is extended by {@link DataModel} to inherit the functionalities of relational algebra concept.\n *\n * @class\n * @public\n * @module Relation\n * @namespace DataModel\n */\nclass Relation {\n\n    /**\n     * Creates a new Relation instance by providing underlying data and schema.\n     *\n     * @private\n     *\n     * @param {Object | string | Relation} data - The input tabular data in dsv or json format or\n     * an existing Relation instance object.\n     * @param {Array} schema - An array of data schema.\n     * @param {Object} [options] - The optional options.\n     */\n    constructor (...params) {\n        let source;\n\n        this._parent = null;\n        this._derivation = [];\n        this._ancestorDerivation = [];\n        this._children = [];\n\n        if (params.length === 1 && ((source = params[0]) instanceof Relation)) {\n            // parent datamodel was passed as part of source\n            this._colIdentifier = source._colIdentifier;\n            this._rowDiffset = source._rowDiffset;\n            this._dataFormat = source._dataFormat;\n            this._parent = source;\n            this._partialFieldspace = this._parent._partialFieldspace;\n            this._fieldStoreName = getUniqueId();\n            this.__calculateFieldspace().calculateFieldsConfig();\n        } else {\n            updateData(this, ...params);\n            this._fieldStoreName = this._partialFieldspace.name;\n            this.__calculateFieldspace().calculateFieldsConfig();\n            this._propagationNameSpace = {\n                mutableActions: {},\n                immutableActions: {}\n            };\n        }\n    }\n\n    /**\n     * Retrieves the {@link Schema | schema} details for every {@link Field | field} as an array.\n     *\n     * @public\n     *\n     * @return {Array.<Schema>} Array of fields schema.\n     *      ```\n     *      [\n     *          { name: 'Name', type: 'dimension' },\n     *          { name: 'Miles_per_Gallon', type: 'measure', numberFormat: (val) => `${val} miles / gallon` },\n     *          { name: 'Cylinder', type: 'dimension' },\n     *          { name: 'Displacement', type: 'measure', defAggFn: 'max' },\n     *          { name: 'HorsePower', type: 'measure', defAggFn: 'max' },\n     *          { name: 'Weight_in_lbs', type: 'measure', defAggFn: 'avg',  },\n     *          { name: 'Acceleration', type: 'measure', defAggFn: 'avg' },\n     *          { name: 'Year', type: 'dimension', subtype: 'datetime', format: '%Y' },\n     *          { name: 'Origin' }\n     *      ]\n     *      ```\n     */\n    getSchema () {\n        return this.getFieldspace().fields.map(d => d.schema());\n    }\n\n    /**\n     * Returns the name of the {@link DataModel} instance. If no name was specified during {@link DataModel}\n     * initialization, then it returns a auto-generated name.\n     *\n     * @public\n     *\n     * @return {string} Name of the DataModel instance.\n     */\n    getName() {\n        return this._fieldStoreName;\n    }\n\n    getFieldspace () {\n        return this._fieldspace;\n    }\n\n    __calculateFieldspace () {\n        this._fieldspace = updateFields([this._rowDiffset, this._colIdentifier],\n             this.getPartialFieldspace(), this._fieldStoreName);\n        return this;\n    }\n\n    getPartialFieldspace () {\n        return this._partialFieldspace;\n    }\n\n    /**\n     * Performs {@link link_of_cross_product | cross-product} between two {@link DataModel} instances and returns a\n     * new {@link DataModel} instance containing the results. This operation is also called theta join.\n     *\n     * Cross product takes two set and create one set where each value of one set is paired with each value of another\n     * set.\n     *\n     * This method takes an optional predicate which filters the generated result rows. If the predicate returns true\n     * the combined row is included in the resulatant table.\n     *\n     * @example\n     *  let originDM = dm.project(['Origin','Origin_Formal_Name']);\n     *  let carsDM = dm.project(['Name','Miles_per_Gallon','Origin'])\n     *\n     *  console.log(carsDM.join(originDM)));\n     *\n     *  console.log(carsDM.join(originDM,\n     *      obj => obj.[originDM.getName()].Origin === obj.[carsDM.getName()].Origin));\n     *\n     * @text\n     * This is chained version of `join` operator. `join` can also be used as\n     * {@link link_to_join_op | functional operator}.\n     *\n     * @public\n     *\n     * @param {DataModel} joinWith - The DataModel to be joined with the current instance DataModel.\n     * @param {SelectionPredicate} filterFn - The predicate function that will filter the result of the crossProduct.\n     *\n     * @return {DataModel} New DataModel instance created after joining.\n     */\n    join (joinWith, filterFn) {\n        return crossProduct(this, joinWith, filterFn);\n    }\n\n    /**\n     * {@link natural_join | Natural join} is a special kind of cross-product join where filtering of rows are performed\n     * internally by resolving common fields are from both table and the rows with common value are included.\n     *\n     * @example\n     *  let originDM = dm.project(['Origin','Origin_Formal_Name']);\n     *  let carsDM = dm.project(['Name','Miles_per_Gallon','Origin'])\n     *\n     *  console.log(carsDM.naturalJoin(originDM));\n     *\n     * @text\n     * This is chained version of `naturalJoin` operator. `naturalJoin` can also be used as\n     * {@link link_to_join_op | functional operator}.\n     *\n     * @public\n     *\n     * @param {DataModel} joinWith - The DataModel with which the current instance of DataModel on which the method is\n     *      called will be joined.\n     * @return {DataModel} New DataModel instance created after joining.\n     */\n    naturalJoin (joinWith) {\n        return crossProduct(this, joinWith, naturalJoinFilter(this, joinWith), true);\n    }\n\n    /**\n     * {@link link_to_union | Union} operation can be termed as vertical stacking of all rows from both the DataModel\n     * instances, provided that both of the {@link DataModel} instances should have same column names.\n     *\n     * @example\n     * console.log(EuropeanMakerDM.union(USAMakerDM));\n     *\n     * @text\n     * This is chained version of `naturalJoin` operator. `naturalJoin` can also be used as\n     * {@link link_to_join_op | functional operator}.\n     *\n     * @public\n     *\n     * @param {DataModel} unionWith - DataModel instance for which union has to be applied with the instance on which\n     *      the method is called\n     *\n     * @return {DataModel} New DataModel instance with the result of the operation\n     */\n    union (unionWith) {\n        return union(this, unionWith);\n    }\n\n    /**\n     * {@link link_to_difference | Difference } operation only include rows which are present in the datamodel on which\n     * it was called but not on the one passed as argument.\n     *\n     * @example\n     * console.log(highPowerDM.difference(highExpensiveDM));\n     *\n     * @text\n     * This is chained version of `naturalJoin` operator. `naturalJoin` can also be used as\n     * {@link link_to_join_op | functional operator}.\n     *\n     * @public\n     *\n     * @param {DataModel} differenceWith - DataModel instance for which difference has to be applied with the instance\n     *      on which the method is called\n     * @return {DataModel} New DataModel instance with the result of the operation\n     */\n    difference (differenceWith) {\n        return difference(this, differenceWith);\n    }\n\n    /**\n     * {@link link_to_selection | Selection} is a row filtering operation. It expects a predicate and an optional mode\n     * which control which all rows should be included in the resultant DataModel instance.\n     *\n     * {@link SelectionPredicate} is a function which returns a boolean value. For selection operation the selection\n     * function is called for each row of DataModel instance with the current row passed as argument.\n     *\n     * After executing {@link SelectionPredicate} the rows are labeled as either an entry of selection set or an entry\n     * of rejection set.\n     *\n     * {@link FilteringMode} operates on the selection and rejection set to determine which one would reflect in the\n     * resultant datamodel.\n     *\n     * @warning\n     * Selection and rejection set is only a logical idea for concept explanation purpose.\n     *\n     * @example\n     *  // with selection mode NORMAL:\n     *  const normDt = dt.select(fields => fields.Origin.value === \"USA\")\n     *  console.log(normDt));\n     *\n     * // with selection mode INVERSE:\n     * const inverDt = dt.select(fields => fields.Origin.value === \"USA\", { mode: DataModel.FilteringMode.INVERSE })\n     * console.log(inverDt);\n     *\n     * // with selection mode ALL:\n     * const dtArr = dt.select(fields => fields.Origin.value === \"USA\", { mode: DataModel.FilteringMode.ALL })\n     * // print the selected parts\n     * console.log(dtArr[0]);\n     * // print the inverted parts\n     * console.log(dtArr[1]);\n     *\n     * @text\n     * This is chained version of `select` operator. `select` can also be used as\n     * {@link link_to_join_op | functional operator}.\n     *\n     * @public\n     *\n     * @param {Function} selectFn - The predicate function which is called for each row with the current row.\n     * ```\n     *  function (row, i, cloneProvider, store)  { ... }\n     * ```\n     * @param {Object} config - The configuration object to control the inclusion exclusion of a row in resultant\n     * DataModel instance.\n     * @param {FilteringMode} [config.mode=FilteringMode.NORMAL] - The mode of the selection.\n     * @return {DataModel} Returns the new DataModel instance(s) after operation.\n     */\n    select (selectFn, config) {\n        const defConfig = {\n            mode: FilteringMode.NORMAL,\n            saveChild: true\n        };\n        config = Object.assign({}, defConfig, config);\n\n        const cloneConfig = { saveChild: config.saveChild };\n\n        return cloneWithSelect(\n            this,\n            selectFn,\n            config,\n            cloneConfig\n        );\n    }\n\n    /**\n     * Retrieves a boolean value if the current {@link DataModel} instance has data.\n     *\n     * @example\n     * const schema = [\n     *    { name: 'CarName', type: 'dimension' },\n     *    { name: 'HorsePower', type: 'measure' },\n     *    { name: \"Origin\", type: 'dimension' }\n     * ];\n     * const data = [];\n     *\n     * const dt = new DataModel(data, schema);\n     * console.log(dt.isEmpty());\n     *\n     * @public\n     *\n     * @return {Boolean} True if the datamodel has no data, otherwise false.\n     */\n    isEmpty () {\n        return !this._rowDiffset.length || !this._colIdentifier.length;\n    }\n\n    /**\n     * Creates a clone from the current DataModel instance with child parent relationship.\n     *\n     * @private\n     * @param {boolean} [saveChild=true] - Whether the cloned instance would be recorded in the parent instance.\n     * @return {DataModel} - Returns the newly cloned DataModel instance.\n     */\n    clone (saveChild = true) {\n        const clonedDm = new this.constructor(this);\n        if (saveChild) {\n            clonedDm.setParent(this);\n        } else {\n            clonedDm.setParent(null);\n        }\n        return clonedDm;\n    }\n\n    /**\n     * {@link Projection} is filter column (field) operation. It expects list of fields' name and either include those\n     * or exclude those based on {@link FilteringMode} on the resultant variable.\n     *\n     * Projection expects array of fields name based on which it creates the selection and rejection set. All the field\n     * whose name is present in array goes in selection set and rest of the fields goes in rejection set.\n     *\n     * {@link FilteringMode} operates on the selection and rejection set to determine which one would reflect in the\n     * resulatant datamodel.\n     *\n     * @warning\n     * Selection and rejection set is only a logical idea for concept explanation purpose.\n     *\n     * @example\n     *  const dm = new DataModel(data, schema);\n     *\n     *  // with projection mode NORMAL:\n     *  const normDt = dt.project([\"Name\", \"HorsePower\"]);\n     *  console.log(normDt.getData());\n     *\n     *  // with projection mode INVERSE:\n     *  const inverDt = dt.project([\"Name\", \"HorsePower\"], { mode: DataModel.FilteringMode.INVERSE })\n     *  console.log(inverDt.getData());\n     *\n     *  // with selection mode ALL:\n     *  const dtArr = dt.project([\"Name\", \"HorsePower\"], { mode: DataModel.FilteringMode.ALL })\n     *  // print the normal parts\n     *  console.log(dtArr[0].getData());\n     *  // print the inverted parts\n     *  console.log(dtArr[1].getData());\n     *\n     * @text\n     * This is chained version of `select` operator. `select` can also be used as\n     * {@link link_to_join_op | functional operator}.\n     *\n     * @public\n     *\n     * @param {Array.<string | Regexp>} projField - An array of column names in string or regular expression.\n     * @param {Object} [config] - An optional config to control the creation of new DataModel\n     * @param {FilteringMode} [config.mode=FilteringMode.NORMAL] - Mode of the projection\n     *\n     * @return {DataModel} Returns the new DataModel instance after operation.\n     */\n    project (projField, config) {\n        const defConfig = {\n            mode: FilteringMode.NORMAL,\n            saveChild: true\n        };\n        config = Object.assign({}, defConfig, config);\n        const fieldConfig = this.getFieldsConfig();\n        const allFields = Object.keys(fieldConfig);\n        const { mode } = config;\n\n        let normalizedProjField = projField.reduce((acc, field) => {\n            if (field.constructor.name === 'RegExp') {\n                acc.push(...allFields.filter(fieldName => fieldName.search(field) !== -1));\n            } else if (field in fieldConfig) {\n                acc.push(field);\n            }\n            return acc;\n        }, []);\n\n        normalizedProjField = Array.from(new Set(normalizedProjField)).map(field => field.trim());\n        let dataModel;\n\n        if (mode === FilteringMode.ALL) {\n            let projectionClone = cloneWithProject(this, normalizedProjField, {\n                mode: FilteringMode.NORMAL,\n                saveChild: config.saveChild\n            }, allFields);\n            let rejectionClone = cloneWithProject(this, normalizedProjField, {\n                mode: FilteringMode.INVERSE,\n                saveChild: config.saveChild\n            }, allFields);\n            dataModel = [projectionClone, rejectionClone];\n        } else {\n            let projectionClone = cloneWithProject(this, normalizedProjField, config, allFields);\n            dataModel = projectionClone;\n        }\n\n        return dataModel;\n    }\n\n    getFieldsConfig () {\n        return this._fieldConfig;\n    }\n\n    calculateFieldsConfig () {\n        this._fieldConfig = this._fieldspace.fields.reduce((acc, fieldObj, i) => {\n            acc[fieldObj.name()] = {\n                index: i,\n                def: fieldObj.schema(),\n            };\n            return acc;\n        }, {});\n        return this;\n    }\n\n\n    /**\n     * Frees up the resources associated with the current DataModel instance and breaks all the links instance has in\n     * the DAG.\n     *\n     * @public\n     */\n    dispose () {\n        this._parent && this._parent.removeChild(this);\n        this._parent = null;\n        this._children.forEach((child) => {\n            child._parent = null;\n        });\n        this._children = [];\n    }\n\n    /**\n     * Removes the specified child {@link DataModel} from the child list of the current {@link DataModel} instance.\n     *\n     * @example\n     * const schema = [\n     *    { name: 'Name', type: 'dimension' },\n     *    { name: 'HorsePower', type: 'measure' },\n     *    { name: \"Origin\", type: 'dimension' }\n     * ];\n     *\n     * const data = [\n     *    { Name: \"chevrolet chevelle malibu\", Horsepower: 130, Origin: \"USA\" },\n     *    { Name: \"citroen ds-21 pallas\", Horsepower: 115, Origin: \"Europe\" },\n     *    { Name: \"datsun pl510\", Horsepower: 88, Origin: \"Japan\" },\n     *    { Name: \"amc rebel sst\", Horsepower: 150, Origin: \"USA\"},\n     * ]\n     *\n     * const dt = new DataModel(data, schema);\n     *\n     * const dt2 = dt.select(fields => fields.Origin.value === \"USA\")\n     * dt.removeChild(dt2);\n     *\n     * @private\n     *\n     * @param {DataModel} child - Delegates the parent to remove this child.\n     */\n    removeChild (child) {\n        let idx = this._children.findIndex(sibling => sibling === child);\n        idx !== -1 ? this._children.splice(idx, 1) : true;\n    }\n\n    /**\n     * Sets the specified {@link DataModel} as a parent for the current {@link DataModel} instance.\n     *\n     * @param {DataModel} parent - The datamodel instance which will act as parent.\n     */\n    setParent (parent) {\n        this._parent && this._parent.removeChild(this);\n        this._parent = parent;\n        parent && parent._children.push(this);\n    }\n\n    /**\n     * Returns the parent {@link DataModel} instance.\n     *\n     * @example\n     * const schema = [\n     *    { name: 'Name', type: 'dimension' },\n     *    { name: 'HorsePower', type: 'measure' },\n     *    { name: \"Origin\", type: 'dimension' }\n     * ];\n     *\n     * const data = [\n     *    { Name: \"chevrolet chevelle malibu\", Horsepower: 130, Origin: \"USA\" },\n     *    { Name: \"citroen ds-21 pallas\", Horsepower: 115, Origin: \"Europe\" },\n     *    { Name: \"datsun pl510\", Horsepower: 88, Origin: \"Japan\" },\n     *    { Name: \"amc rebel sst\", Horsepower: 150, Origin: \"USA\"},\n     * ]\n     *\n     * const dt = new DataModel(data, schema);\n     *\n     * const dt2 = dt.select(fields => fields.Origin.value === \"USA\");\n     * const parentDm = dt2.getParent();\n     *\n     * @return {DataModel} Returns the parent DataModel instance.\n     */\n    getParent () {\n        return this._parent;\n    }\n\n    /**\n     * Returns the immediate child {@link DataModel} instances.\n     *\n     * @example\n     * const schema = [\n     *    { name: 'Name', type: 'dimension' },\n     *    { name: 'HorsePower', type: 'measure' },\n     *    { name: \"Origin\", type: 'dimension' }\n     * ];\n     *\n     * const data = [\n     *    { Name: \"chevrolet chevelle malibu\", Horsepower: 130, Origin: \"USA\" },\n     *    { Name: \"citroen ds-21 pallas\", Horsepower: 115, Origin: \"Europe\" },\n     *    { Name: \"datsun pl510\", Horsepower: 88, Origin: \"Japan\" },\n     *    { Name: \"amc rebel sst\", Horsepower: 150, Origin: \"USA\"},\n     * ]\n     *\n     * const dt = new DataModel(data, schema);\n     *\n     * const childDm1 = dt.select(fields => fields.Origin.value === \"USA\");\n     * const childDm2 = dt.select(fields => fields.Origin.value === \"Japan\");\n     * const childDm3 = dt.groupBy([\"Origin\"]);\n     *\n     * @return {DataModel[]} Returns the immediate child DataModel instances.\n     */\n    getChildren () {\n        return this._children;\n    }\n\n    /**\n     * Returns the in-between operation meta data while creating the current {@link DataModel} instance.\n     *\n     * @example\n     * const schema = [\n     *   { name: 'Name', type: 'dimension' },\n     *   { name: 'HorsePower', type: 'measure' },\n     *   { name: \"Origin\", type: 'dimension' }\n     * ];\n     *\n     * const data = [\n     *   { Name: \"chevrolet chevelle malibu\", Horsepower: 130, Origin: \"USA\" },\n     *   { Name: \"citroen ds-21 pallas\", Horsepower: 115, Origin: \"Europe\" },\n     *   { Name: \"datsun pl510\", Horsepower: 88, Origin: \"Japan\" },\n     *   { Name: \"amc rebel sst\", Horsepower: 150, Origin: \"USA\"},\n     * ]\n     *\n     * const dt = new DataModel(data, schema);\n     * const dt2 = dt.select(fields => fields.Origin.value === \"USA\");\n     * const dt3 = dt2.groupBy([\"Origin\"]);\n     * const derivations = dt3.getDerivations();\n     *\n     * @return {Any[]} Returns the derivation meta data.\n     */\n    getDerivations () {\n        return this._derivation;\n    }\n\n    /**\n     * Returns the in-between operation meta data happened from root {@link DataModel} to current instance.\n     *\n     * @example\n     * const schema = [\n     *   { name: 'Name', type: 'dimension' },\n     *   { name: 'HorsePower', type: 'measure' },\n     *   { name: \"Origin\", type: 'dimension' }\n     * ];\n     *\n     * const data = [\n     *   { Name: \"chevrolet chevelle malibu\", Horsepower: 130, Origin: \"USA\" },\n     *   { Name: \"citroen ds-21 pallas\", Horsepower: 115, Origin: \"Europe\" },\n     *   { Name: \"datsun pl510\", Horsepower: 88, Origin: \"Japan\" },\n     *   { Name: \"amc rebel sst\", Horsepower: 150, Origin: \"USA\"},\n     * ]\n     *\n     * const dt = new DataModel(data, schema);\n     * const dt2 = dt.select(fields => fields.Origin.value === \"USA\");\n     * const dt3 = dt2.groupBy([\"Origin\"]);\n     * const ancDerivations = dt3.getAncestorDerivations();\n     *\n     * @return {Any[]} Returns the previous derivation meta data.\n     */\n    getAncestorDerivations () {\n        return this._ancestorDerivation;\n    }\n}\n\nexport default Relation;\n","import { fnList } from '../operator/group-by-function';\n\nexport const { sum, avg, min, max, first, last, count, std: sd } = fnList;\n","/**\n * The utility function to calculate major column.\n *\n * @param {Object} store - The store object.\n * @return {Function} Returns the push function.\n */\nexport default (store) => {\n    let i = 0;\n    return (...fields) => {\n        fields.forEach((val, fieldIndex) => {\n            if (!(store[fieldIndex] instanceof Array)) {\n                store[fieldIndex] = Array.from({ length: i });\n            }\n            store[fieldIndex].push(val);\n        });\n        i++;\n    };\n};\n","/**\n * Creates a JS native date object from input\n *\n * @param {string | number | Date} date Input using which date object to be created\n * @return {Date} : JS native date object\n */\nfunction convertToNativeDate (date) {\n    if (date instanceof Date) {\n        return date;\n    }\n\n    return new Date(date);\n}\n/**\n * Apply padding before a number if its less than 1o. This is used when constant digit's number to be returned\n * between 0 - 99\n *\n * @param {number} n Input to be padded\n * @return {string} Padded number\n */\nfunction pad (n) {\n    return (n < 10) ? (`0${n}`) : n;\n}\n/*\n * DateFormatter utility to convert any date format to any other date format\n * DateFormatter parse a date time stamp specified by a user abiding by rules which are defined\n * by user in terms of token. It creates JS native date object from the user specified format.\n * That native date can also be displayed\n * in any specified format.\n * This utility class only takes care of format conversion only\n */\n\n/*\n * Escapes all the special character that are used in regular expression.\n * Like\n * RegExp.escape('sgfd-$') // Output: sgfd\\-\\$\n *\n * @param text {String} : text which is to be escaped\n */\nRegExp.escape = function (text) {\n    return text.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n};\n\n/**\n * DateTimeFormatter class to convert any user format of date time stamp to any other format\n * of date time stamp.\n *\n * @param {string} format Format of the date given. For the above date,\n * 'year: %Y, month: %b, day: %d'.\n * @class\n */\n/* istanbul ignore next */ function DateTimeFormatter (format) {\n    this.format = format;\n    this.dtParams = undefined;\n    this.nativeDate = undefined;\n}\n\n// The identifier of the tokens\nDateTimeFormatter.TOKEN_PREFIX = '%';\n\n// JS native Date constructor takes the date params (year, month, etc) in a certail sequence.\n// This defines the sequence of the date parameters in the constructor.\nDateTimeFormatter.DATETIME_PARAM_SEQUENCE = {\n    YEAR: 0,\n    MONTH: 1,\n    DAY: 2,\n    HOUR: 3,\n    MINUTE: 4,\n    SECOND: 5,\n    MILLISECOND: 6\n};\n\n/*\n * This is a default number parsing utility. It tries to parse a number in integer, if parsing is unsuccessful, it\n * gives back a default value.\n *\n * @param: defVal {Number} : Default no if the parsing to integer is not successful\n * @return {Function} : An closure function which is to be called by passing an the value which needs to be parsed.\n */\nDateTimeFormatter.defaultNumberParser = function (defVal) {\n    return function (val) {\n        let parsedVal;\n        if (isFinite(parsedVal = parseInt(val, 10))) {\n            return parsedVal;\n        }\n\n        return defVal;\n    };\n};\n\n/*\n * This is a default number range utility. It tries to find an element in the range. If not found it returns a\n * default no as an index.\n *\n * @param: range {Array} : The list which is to be serached\n * @param: defVal {Number} : Default no if the serach and find does not return anything\n * @return {Function} : An closure function which is to be called by passing an the value which needs to be found\n */\nDateTimeFormatter.defaultRangeParser = function (range, defVal) {\n    return (val) => {\n        let i;\n        let l;\n\n        if (!val) { return defVal; }\n\n        const nVal = val.toLowerCase();\n\n        for (i = 0, l = range.length; i < l; i++) {\n            if (range[i].toLowerCase() === nVal) {\n                return i;\n            }\n        }\n\n        if (i === undefined) {\n            return defVal;\n        }\n        return null;\n    };\n};\n\n/*\n * Defines the tokens which are supporter by the dateformatter. Using this definitation a value gets extracted from\n * the user specifed date string. This also formats the value for display purpose from native JS date.\n * The definition of each token contains the following named properties\n * {\n *     %token_name% : {\n *         name: name of the token, this is used in reverse lookup,\n *         extract: a function that returns the regular expression to extract that piece of information. All the\n *                  regex should be gouped by using ()\n *         parser: a function which receives value extracted by the above regex and parse it to get the date params\n *         formatter: a formatter function that takes milliseconds or JS Date object and format the param\n *                  represented by the token only.\n *     }\n * }\n *\n * @return {Object} : Definition of the all the supported tokens.\n */\nDateTimeFormatter.getTokenDefinitions = function () {\n    const daysDef = {\n        short: [\n            'Sun',\n            'Mon',\n            'Tue',\n            'Wed',\n            'Thu',\n            'Fri',\n            'Sat'\n        ],\n        long: [\n            'Sunday',\n            'Monday',\n            'Tuesday',\n            'Wednesday',\n            'Thursday',\n            'Friday',\n            'Saturday'\n        ]\n    };\n    const monthsDef = {\n        short: [\n            'Jan',\n            'Feb',\n            'Mar',\n            'Apr',\n            'May',\n            'Jun',\n            'Jul',\n            'Aug',\n            'Sep',\n            'Oct',\n            'Nov',\n            'Dec'\n        ],\n        long: [\n            'January',\n            'February',\n            'March',\n            'April',\n            'May',\n            'June',\n            'July',\n            'August',\n            'September',\n            'October',\n            'November',\n            'December'\n        ]\n    };\n\n    const definitions = {\n        H: {\n            // 24 hours format\n            name: 'H',\n            index: 3,\n            extract () { return '(\\\\d+)'; },\n            parser: DateTimeFormatter.defaultNumberParser(),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n\n                return d.getHours().toString();\n            }\n        },\n        l: {\n            // 12 hours format\n            name: 'l',\n            index: 3,\n            extract () { return '(\\\\d+)'; },\n            parser: DateTimeFormatter.defaultNumberParser(),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const hours = d.getHours() % 12;\n\n                return (hours === 0 ? 12 : hours).toString();\n            }\n        },\n        p: {\n            // AM or PM\n            name: 'p',\n            index: 3,\n            extract () { return '(AM|PM)'; },\n            parser: (val) => {\n                if (val) {\n                    return val.toLowerCase();\n                }\n                return null;\n            },\n            formatter: (val) => {\n                const d = convertToNativeDate(val);\n                const hours = d.getHours();\n\n                return (hours < 12 ? 'AM' : 'PM');\n            }\n        },\n        P: {\n            // am or pm\n            name: 'P',\n            index: 3,\n            extract () { return '(am|pm)'; },\n            parser: (val) => {\n                if (val) {\n                    return val.toLowerCase();\n                }\n                return null;\n            },\n            formatter: (val) => {\n                const d = convertToNativeDate(val);\n                const hours = d.getHours();\n\n                return (hours < 12 ? 'am' : 'pm');\n            }\n        },\n        M: {\n            // Two digit minutes 00 - 59\n            name: 'M',\n            index: 4,\n            extract () { return '(\\\\d+)'; },\n            parser: DateTimeFormatter.defaultNumberParser(),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const mins = d.getMinutes();\n\n                return pad(mins);\n            }\n        },\n        S: {\n            // Two digit seconds 00 - 59\n            name: 'S',\n            index: 5,\n            extract () { return '(\\\\d+)'; },\n            parser: DateTimeFormatter.defaultNumberParser(),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const seconds = d.getSeconds();\n\n                return pad(seconds);\n            }\n        },\n        K: {\n            // Milliseconds\n            name: 'K',\n            index: 6,\n            extract () { return '(\\\\d+)'; },\n            parser: DateTimeFormatter.defaultNumberParser(),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const ms = d.getMilliseconds();\n\n                return ms.toString();\n            }\n        },\n        a: {\n            // Short name of day, like Mon\n            name: 'a',\n            index: 2,\n            extract () { return `(${daysDef.short.join('|')})`; },\n            parser: DateTimeFormatter.defaultRangeParser(daysDef.short),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const day = d.getDay();\n\n                return (daysDef.short[day]).toString();\n            }\n        },\n        A: {\n            // Long name of day, like Monday\n            name: 'A',\n            index: 2,\n            extract () { return `(${daysDef.long.join('|')})`; },\n            parser: DateTimeFormatter.defaultRangeParser(daysDef.long),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const day = d.getDay();\n\n                return (daysDef.long[day]).toString();\n            }\n        },\n        e: {\n            // 8 of March, 11 of November\n            name: 'e',\n            index: 2,\n            extract () { return '(\\\\d+)'; },\n            parser: DateTimeFormatter.defaultNumberParser(),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const day = d.getDate();\n\n                return day.toString();\n            }\n        },\n        d: {\n            // 08 of March, 11 of November\n            name: 'd',\n            index: 2,\n            extract () { return '(\\\\d+)'; },\n            parser: DateTimeFormatter.defaultNumberParser(),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const day = d.getDate();\n\n                return pad(day);\n            }\n        },\n        b: {\n            // Short month, like Jan\n            name: 'b',\n            index: 1,\n            extract () { return `(${monthsDef.short.join('|')})`; },\n            parser: DateTimeFormatter.defaultRangeParser(monthsDef.short),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const month = d.getMonth();\n\n                return (monthsDef.short[month]).toString();\n            }\n        },\n        B: {\n            // Long month, like January\n            name: 'B',\n            index: 1,\n            extract () { return `(${monthsDef.long.join('|')})`; },\n            parser: DateTimeFormatter.defaultRangeParser(monthsDef.long),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const month = d.getMonth();\n\n                return (monthsDef.long[month]).toString();\n            }\n        },\n        m: {\n            // Two digit month of year like 01 for January\n            name: 'm',\n            index: 1,\n            extract () { return '(\\\\d+)'; },\n            parser (val) { return DateTimeFormatter.defaultNumberParser()(val) - 1; },\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const month = d.getMonth();\n\n                return pad(month + 1);\n            }\n        },\n        y: {\n            // Short year like 90 for 1990\n            name: 'y',\n            index: 0,\n            extract () { return '(\\\\d{2})'; },\n            parser (val) {\n                let result;\n                if (val) {\n                    const l = val.length;\n                    val = val.substring(l - 2, l);\n                }\n                let parsedVal = DateTimeFormatter.defaultNumberParser()(val);\n                let presentDate = new Date();\n                let presentYear = Math.trunc((presentDate.getFullYear()) / 100);\n\n                result = `${presentYear}${parsedVal}`;\n\n                if (convertToNativeDate(result).getFullYear() > presentDate.getFullYear()) {\n                    result = `${presentYear - 1}${parsedVal}`;\n                }\n                return convertToNativeDate(result).getFullYear();\n            },\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                let year = d.getFullYear().toString();\n                let l;\n\n                if (year) {\n                    l = year.length;\n                    year = year.substring(l - 2, l);\n                }\n\n                return year;\n            }\n        },\n        Y: {\n            // Long year like 1990\n            name: 'Y',\n            index: 0,\n            extract () { return '(\\\\d{4})'; },\n            parser: DateTimeFormatter.defaultNumberParser(),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const year = d.getFullYear().toString();\n\n                return year;\n            }\n        }\n    };\n\n    return definitions;\n};\n\n/*\n * The tokens which works internally is not user friendly in terms of memorizing the names. This gives a formal\n * definition to the informal notations.\n *\n * @return {Object} : Formal definition of the tokens\n */\nDateTimeFormatter.getTokenFormalNames = function () {\n    const definitions = DateTimeFormatter.getTokenDefinitions();\n\n    return {\n        HOUR: definitions.H,\n        HOUR_12: definitions.l,\n        AMPM_UPPERCASE: definitions.p,\n        AMPM_LOWERCASE: definitions.P,\n        MINUTE: definitions.M,\n        SECOND: definitions.S,\n        SHORT_DAY: definitions.a,\n        LONG_DAY: definitions.A,\n        DAY_OF_MONTH: definitions.e,\n        DAY_OF_MONTH_CONSTANT_WIDTH: definitions.d,\n        SHORT_MONTH: definitions.b,\n        LONG_MONTH: definitions.B,\n        MONTH_OF_YEAR: definitions.m,\n        SHORT_YEAR: definitions.y,\n        LONG_YEAR: definitions.Y\n    };\n};\n\n/*\n * This defines the rules and declares dependencies that resolves a date parameter (year, month etc) from\n * the date time parameter array.\n *\n * @return {Object} : An object that contains dependencies and a resolver function. The dependencies values are fed\n *                  to the resolver function in that particular sequence only.\n */\nDateTimeFormatter.tokenResolver = function () {\n    const definitions = DateTimeFormatter.getTokenDefinitions();\n    const defaultResolver = (...args) => { // eslint-disable-line require-jsdoc\n        let i = 0;\n        let arg;\n        let targetParam;\n        const l = args.length;\n\n        for (; i < l; i++) {\n            arg = args[i];\n            if (args[i]) {\n                targetParam = arg;\n            }\n        }\n\n        if (!targetParam) { return null; }\n\n        return targetParam[0].parser(targetParam[1]);\n    };\n\n    return {\n        YEAR: [definitions.y, definitions.Y,\n            defaultResolver\n        ],\n        MONTH: [definitions.b, definitions.B, definitions.m,\n            defaultResolver\n        ],\n        DAY: [definitions.a, definitions.A, definitions.e, definitions.d,\n            defaultResolver\n        ],\n        HOUR: [definitions.H, definitions.l, definitions.p, definitions.P,\n            function (hourFormat24, hourFormat12, ampmLower, ampmUpper) {\n                let targetParam;\n                let amOrpm;\n                let isPM;\n                let val;\n\n                if (hourFormat12 && (amOrpm = (ampmLower || ampmUpper))) {\n                    if (amOrpm[0].parser(amOrpm[1]) === 'pm') {\n                        isPM = true;\n                    }\n\n                    targetParam = hourFormat12;\n                } else if (hourFormat12) {\n                    targetParam = hourFormat12;\n                } else {\n                    targetParam = hourFormat24;\n                }\n\n                if (!targetParam) { return null; }\n\n                val = targetParam[0].parser(targetParam[1]);\n                if (isPM) {\n                    val += 12;\n                }\n                return val;\n            }\n        ],\n        MINUTE: [definitions.M,\n            defaultResolver\n        ],\n        SECOND: [definitions.S,\n            defaultResolver\n        ]\n    };\n};\n\n/*\n * Finds token from the format rule specified by a user.\n * @param format {String} : The format of the input date specified by the user\n * @return {Array} : An array of objects which contains the available token and their occurence index in the format\n */\nDateTimeFormatter.findTokens = function (format) {\n    const tokenPrefix = DateTimeFormatter.TOKEN_PREFIX;\n    const definitions = DateTimeFormatter.getTokenDefinitions();\n    const tokenLiterals = Object.keys(definitions);\n    const occurrence = [];\n    let i;\n    let forwardChar;\n\n    while ((i = format.indexOf(tokenPrefix, i + 1)) >= 0) {\n        forwardChar = format[i + 1];\n        if (tokenLiterals.indexOf(forwardChar) === -1) { continue; }\n\n        occurrence.push({\n            index: i,\n            token: forwardChar\n        });\n    }\n\n    return occurrence;\n};\n\n/*\n * Format any JS date to a specified date given by user.\n *\n * @param date {Number | Date} : The date object which is to be formatted\n * @param format {String} : The format using which the date will be formatted for display\n */\nDateTimeFormatter.formatAs = function (date, format) {\n    const nDate = convertToNativeDate(date);\n    const occurrence = DateTimeFormatter.findTokens(format);\n    const definitions = DateTimeFormatter.getTokenDefinitions();\n    let formattedStr = String(format);\n    const tokenPrefix = DateTimeFormatter.TOKEN_PREFIX;\n    let token;\n    let formattedVal;\n    let i;\n    let l;\n\n    for (i = 0, l = occurrence.length; i < l; i++) {\n        token = occurrence[i].token;\n        formattedVal = definitions[token].formatter(nDate);\n        formattedStr = formattedStr.replace(new RegExp(tokenPrefix + token, 'g'), formattedVal);\n    }\n\n    return formattedStr;\n};\n\n/*\n * Parses the user specified date string to extract the date time params.\n *\n * @return {Array} : Value of date time params in an array [year, month, day, hour, minutes, seconds, milli]\n */\nDateTimeFormatter.prototype.parse = function (dateTimeStamp, options) {\n    const tokenResolver = DateTimeFormatter.tokenResolver();\n    const dtParams = this.extractTokenValue(dateTimeStamp);\n    const dtParamSeq = DateTimeFormatter.DATETIME_PARAM_SEQUENCE;\n    const noBreak = options && options.noBreak;\n    const dtParamArr = [];\n    const args = [];\n    let resolverKey;\n    let resolverParams;\n    let resolverFn;\n    let val;\n    let i;\n    let param;\n    let resolvedVal;\n    let l;\n    let result = [];\n\n    for (resolverKey in tokenResolver) {\n        if (!{}.hasOwnProperty.call(tokenResolver, resolverKey)) { continue; }\n\n        args.length = 0;\n        resolverParams = tokenResolver[resolverKey];\n        resolverFn = resolverParams.splice(resolverParams.length - 1, 1)[0];\n\n        for (i = 0, l = resolverParams.length; i < l; i++) {\n            param = resolverParams[i];\n            val = dtParams[param.name];\n\n            if (val === undefined) {\n                args.push(null);\n            } else {\n                args.push([param, val]);\n            }\n        }\n\n        resolvedVal = resolverFn.apply(this, args);\n\n        if ((resolvedVal === undefined || resolvedVal === null) && !noBreak) {\n            break;\n        }\n\n        dtParamArr[dtParamSeq[resolverKey]] = resolvedVal;\n    }\n\n    if (dtParamArr.length && this.checkIfOnlyYear(dtParamArr.length))\n     {\n        result.unshift(dtParamArr[0], 0, 1); }\n    else {\n        result.unshift(...dtParamArr);\n    }\n\n    return result;\n};\n\n/*\n * Extract the value of the token from user specified date time string.\n *\n * @return {Object} : An key value pair which contains the tokens as key and value as pair\n */\nDateTimeFormatter.prototype.extractTokenValue = function (dateTimeStamp) {\n    const format = this.format;\n    const definitions = DateTimeFormatter.getTokenDefinitions();\n    const tokenPrefix = DateTimeFormatter.TOKEN_PREFIX;\n    const occurrence = DateTimeFormatter.findTokens(format);\n    const tokenObj = {};\n\n    let lastOccurrenceIndex;\n    let occObj;\n    let occIndex;\n    let targetText;\n    let regexFormat;\n\n    let l;\n    let i;\n\n    regexFormat = String(format);\n\n    const tokenArr = occurrence.map(obj => obj.token);\n    const occurrenceLength = occurrence.length;\n    for (i = occurrenceLength - 1; i >= 0; i--) {\n        occIndex = occurrence[i].index;\n\n        if (occIndex + 1 === regexFormat.length - 1) {\n            lastOccurrenceIndex = occIndex;\n            continue;\n        }\n\n        if (lastOccurrenceIndex === undefined) {\n            lastOccurrenceIndex = regexFormat.length;\n        }\n\n        targetText = regexFormat.substring(occIndex + 2, lastOccurrenceIndex);\n        regexFormat = regexFormat.substring(0, occIndex + 2) +\n            RegExp.escape(targetText) +\n            regexFormat.substring(lastOccurrenceIndex, regexFormat.length);\n\n        lastOccurrenceIndex = occIndex;\n    }\n\n    for (i = 0; i < occurrenceLength; i++) {\n        occObj = occurrence[i];\n        regexFormat = regexFormat.replace(tokenPrefix + occObj.token, definitions[occObj.token].extract());\n    }\n\n    const extractValues = dateTimeStamp.match(new RegExp(regexFormat)) || [];\n    extractValues.shift();\n\n    for (i = 0, l = tokenArr.length; i < l; i++) {\n        tokenObj[tokenArr[i]] = extractValues[i];\n    }\n    return tokenObj;\n};\n\n/*\n * Give back the JS native date formed from  user specified date string\n *\n * @return {Date} : Native JS Date\n */\nDateTimeFormatter.prototype.getNativeDate = function (dateTimeStamp) {\n    let date = null;\n    if (Number.isFinite(dateTimeStamp)) {\n        date = new Date(dateTimeStamp);\n    } else if (!this.format && Date.parse(dateTimeStamp)) {\n        date = new Date(dateTimeStamp);\n    }\n    else {\n        const dtParams = this.dtParams = this.parse(dateTimeStamp);\n        if (dtParams.length) {\n            this.nativeDate = new Date(...dtParams);\n            date = this.nativeDate;\n        }\n    }\n    return date;\n};\n\nDateTimeFormatter.prototype.checkIfOnlyYear = function(len) {\n    return len === 1 && this.format.match(/y|Y/g).length;\n};\n\n/*\n * Represents JS native date to a user specified format.\n *\n * @param format {String} : The format according to which the date is to be represented\n * @return {String} : The formatted date string\n */\nDateTimeFormatter.prototype.formatAs = function (format, dateTimeStamp) {\n    let nativeDate;\n\n    if (dateTimeStamp) {\n        nativeDate = this.nativeDate = this.getNativeDate(dateTimeStamp);\n    } else if (!(nativeDate = this.nativeDate)) {\n        nativeDate = this.getNativeDate(dateTimeStamp);\n    }\n\n    return DateTimeFormatter.formatAs(nativeDate, format);\n};\n\nexport { DateTimeFormatter as default };\n","/**\n * Generates domain for measure field.\n *\n * @param {Array} data - The array of data.\n * @return {Array} Returns the measure domain.\n */\nexport default (data) => {\n    let min = Number.POSITIVE_INFINITY;\n    let max = Number.NEGATIVE_INFINITY;\n\n    data.forEach((d) => {\n        if (d < min) {\n            min = d;\n        }\n        if (d > max) {\n            max = d;\n        }\n    });\n\n    return [min, max];\n};\n","/* eslint-disable */\nconst OBJECTSTRING = 'object';\nconst objectToStrFn = Object.prototype.toString;\nconst objectToStr = '[object Object]';\nconst arrayToStr = '[object Array]';\n\nfunction checkCyclicRef(obj, parentArr) {\n    let i = parentArr.length;\n    let bIndex = -1;\n\n    while (i) {\n        if (obj === parentArr[i]) {\n            bIndex = i;\n            return bIndex;\n        }\n        i -= 1;\n    }\n\n    return bIndex;\n}\n\nfunction merge(obj1, obj2, skipUndef, tgtArr, srcArr) {\n    var item,\n        srcVal,\n        tgtVal,\n        str,\n        cRef;\n    // check whether obj2 is an array\n    // if array then iterate through it's index\n    // **** MOOTOOLS precution\n\n    if (!srcArr) {\n        tgtArr = [obj1];\n        srcArr = [obj2];\n    }\n    else {\n        tgtArr.push(obj1);\n        srcArr.push(obj2);\n    }\n\n    if (obj2 instanceof Array) {\n        for (item = 0; item < obj2.length; item += 1) {\n            try {\n                srcVal = obj1[item];\n                tgtVal = obj2[item];\n            }\n            catch (e) {\n                continue;\n            }\n\n            if (typeof tgtVal !== OBJECTSTRING) {\n                if (!(skipUndef && tgtVal === undefined)) {\n                    obj1[item] = tgtVal;\n                }\n            }\n            else {\n                if (srcVal === null || typeof srcVal !== OBJECTSTRING) {\n                    srcVal = obj1[item] = tgtVal instanceof Array ? [] : {};\n                }\n                cRef = checkCyclicRef(tgtVal, srcArr);\n                if (cRef !== -1) {\n                    srcVal = obj1[item] = tgtArr[cRef];\n                }\n                else {\n                    merge(srcVal, tgtVal, skipUndef, tgtArr, srcArr);\n                }\n            }\n        }\n    }\n    else {\n        for (item in obj2) {\n            try {\n                srcVal = obj1[item];\n                tgtVal = obj2[item];\n            }\n            catch (e) {\n                continue;\n            }\n\n            if (tgtVal !== null && typeof tgtVal === OBJECTSTRING) {\n                // Fix for issue BUG: FWXT-602\n                // IE < 9 Object.prototype.toString.call(null) gives\n                // '[object Object]' instead of '[object Null]'\n                // that's why null value becomes Object in IE < 9\n                str = objectToStrFn.call(tgtVal);\n                if (str === objectToStr) {\n                    if (srcVal === null || typeof srcVal !== OBJECTSTRING) {\n                        srcVal = obj1[item] = {};\n                    }\n                    cRef = checkCyclicRef(tgtVal, srcArr);\n                    if (cRef !== -1) {\n                        srcVal = obj1[item] = tgtArr[cRef];\n                    }\n                    else {\n                        merge(srcVal, tgtVal, skipUndef, tgtArr, srcArr);\n                    }\n                }\n                else if (str === arrayToStr) {\n                    if (srcVal === null || !(srcVal instanceof Array)) {\n                        srcVal = obj1[item] = [];\n                    }\n                    cRef = checkCyclicRef(tgtVal, srcArr);\n                    if (cRef !== -1) {\n                        srcVal = obj1[item] = tgtArr[cRef];\n                    }\n                    else {\n                        merge(srcVal, tgtVal, skipUndef, tgtArr, srcArr);\n                    }\n                }\n                else {\n                    obj1[item] = tgtVal;\n                }\n            }\n            else {\n                if (skipUndef && tgtVal === undefined) {\n                    continue;\n                }\n                obj1[item] = tgtVal;\n            }\n        }\n    }\n    return obj1;\n}\n\n\nfunction extend2 (obj1, obj2, skipUndef) {\n    //if none of the arguments are object then return back\n    if (typeof obj1 !== OBJECTSTRING && typeof obj2 !== OBJECTSTRING) {\n        return null;\n    }\n\n    if (typeof obj2 !== OBJECTSTRING || obj2 === null) {\n        return obj1;\n    }\n\n    if (typeof obj1 !== OBJECTSTRING) {\n        obj1 = obj2 instanceof Array ? [] : {};\n    }\n    merge(obj1, obj2, skipUndef);\n    return obj1;\n}\n\nexport { extend2 as default };\n","import { DataFormat } from '../enums';\n\n/**\n * Checks whether the value is an array.\n *\n * @param  {*} val - The value to be checked.\n * @return {boolean} Returns true if the value is an array otherwise returns false.\n */\nexport function isArray (val) {\n    return Array.isArray(val);\n}\n\n/**\n * Checks whether the value is an object.\n *\n * @param  {*} val - The value to be checked.\n * @return {boolean} Returns true if the value is an object otherwise returns false.\n */\nexport function isObject (val) {\n    return val === Object(val);\n}\n\n/**\n * Checks whether the value is a string value.\n *\n * @param  {*} val - The value to be checked.\n * @return {boolean} Returns true if the value is a string value otherwise returns false.\n */\nexport function isString (val) {\n    return typeof val === 'string';\n}\n\n/**\n * Checks whether the value is callable.\n *\n * @param {*} val - The value to be checked.\n * @return {boolean} Returns true if the value is callable otherwise returns false.\n */\nexport function isCallable (val) {\n    return typeof val === 'function';\n}\n\n/**\n * Returns the unique values from the input array.\n *\n * @param {Array} data - The input array.\n * @return {Array} Returns a new array of unique values.\n */\nexport function uniqueValues (data) {\n    return [...new Set(data)];\n}\n\nexport const getUniqueId = () => `id-${new Date().getTime()}${Math.round(Math.random() * 10000)}`;\n\n/**\n * Checks Whether two arrays have same content.\n *\n * @param {Array} arr1 - The first array.\n * @param {Array} arr2 - The 2nd array.\n * @return {boolean} Returns whether two array have same content.\n */\nexport function isArrEqual(arr1, arr2) {\n    if (!isArray(arr1) || !isArray(arr2)) {\n        return arr1 === arr2;\n    }\n\n    if (arr1.length !== arr2.length) {\n        return false;\n    }\n\n    for (let i = 0; i < arr1.length; i++) {\n        if (arr1[i] !== arr2[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * It is the default number format function for the measure field type.\n *\n * @param {any} val - The input value.\n * @return {number} Returns a number value.\n */\nexport function formatNumber(val) {\n    return val;\n}\n\n/**\n * Returns the detected data format.\n *\n * @param {any} data - The input data to be tested.\n * @return {string} Returns the data format name.\n */\nexport const detectDataFormat = (data) => {\n    if (isString(data)) {\n        return DataFormat.DSV_STR;\n    } else if (isArray(data) && isArray(data[0])) {\n        return DataFormat.DSV_ARR;\n    } else if (isArray(data) && (data.length === 0 || isObject(data[0]))) {\n        return DataFormat.FLAT_JSON;\n    }\n    return null;\n};\n","export { default as DateTimeFormatter } from './date-time-formatter';\nexport { default as columnMajor } from './column-major';\nexport { default as generateMeasureDomain } from './domain-generator';\nexport { default as extend2 } from './extend2';\nexport * from './helper';\n","import { defReducer, fnList } from '../operator';\n\n/**\n * A page level storage which stores, registers, unregisters reducers for all the datamodel instances. There is only one\n * reducer store available in a page. All the datamodel instances receive same instance of reducer store. DataModel\n * out of the box provides handful of {@link reducer | reducers} which can be used as reducer funciton.\n *\n * @public\n * @namespace DataModel\n */\nclass ReducerStore {\n    constructor () {\n        this.store = new Map();\n        this.store.set('defReducer', defReducer);\n\n        Object.entries(fnList).forEach((key) => {\n            this.store.set(key[0], key[1]);\n        });\n    }\n\n    /**\n     * Changes the `defaultReducer` globally. For all the fields which does not have `defAggFn` mentioned in schema, the\n     * value of `defaultReducer` is used for aggregation.\n     *\n     * @public\n     * @param {string} [reducer='sum'] - The name of the default reducer. It picks up the definition from store by doing\n     * name lookup. If no name is found then it takes `sum` as the default reducer.\n     * @return {ReducerStore} Returns instance of the singleton store in page.\n     */\n    defaultReducer (...params) {\n        if (!params.length) {\n            return this.store.get('defReducer');\n        }\n\n        let reducer = params[0];\n\n        if (typeof reducer === 'function') {\n            this.store.set('defReducer', reducer);\n        } else {\n            reducer = String(reducer);\n            if (Object.keys(fnList).indexOf(reducer) !== -1) {\n                this.store.set('defReducer', fnList[reducer]);\n            } else {\n                throw new Error(`Reducer ${reducer} not found in registry`);\n            }\n        }\n        return this;\n    }\n\n    /**\n     *\n     * Registers a {@link reducer | reducer}.\n     * A {@link reducer | reducer} has to be registered before it is used.\n     *\n     * @example\n     *  // find the mean squared value of a given set\n     *  const reducerStore = DataModel.Reducers();\n     *\n     *  reducers.register('meanSquared', (arr) => {\n     *      const squaredVal = arr.map(item => item * item);\n     *      let sum = 0;\n     *      for (let i = 0, l = squaredVal.length; i < l; i++) {\n     *          sum += squaredVal[i++];\n     *      }\n     *\n     *      return sum;\n     *  })\n     *\n     *  // datamodel (dm) is already prepared with cars.json\n     *  const dm1 = dm.groupBy(['origin'], {\n     *      accleration: 'meanSquared'\n     *  });\n     *\n     * @public\n     *\n     * @param {string} name formal name for a reducer. If the given name already exists in store it is overridden by new\n     *      definition.\n     * @param {Function} reducer definition of {@link reducer} function.\n     *\n     * @return {Function} function for unregistering the reducer.\n     */\n    register (name, reducer) {\n        if (typeof reducer !== 'function') {\n            throw new Error('Reducer should be a function');\n        }\n\n        name = String(name);\n        this.store.set(name, reducer);\n\n        return () => { this.__unregister(name); };\n    }\n\n    __unregister (name) {\n        if (this.store.has(name)) {\n            this.store.delete(name);\n        }\n    }\n\n    resolve (name) {\n        if (name instanceof Function) {\n            return name;\n        }\n        return this.store.get(name);\n    }\n}\n\nconst reducerStore = (function () {\n    let store = null;\n\n    function getStore () {\n        if (store === null) {\n            store = new ReducerStore();\n        }\n        return store;\n    }\n    return getStore();\n}());\n\nexport default reducerStore;\n","/**\n * The wrapper class on top of the primitive value of a field.\n *\n * @todo Need to have support for StringValue, NumberValue, DateTimeValue\n * and GeoValue. These types should expose predicate API mostly.\n */\nclass Value {\n\n  /**\n   * Creates new Value instance.\n   *\n   * @param {*} val - the primitive value from the field cell.\n   * @param {string | Field} field - The field from which the value belongs.\n   */\n    constructor (val, field) {\n        Object.defineProperty(this, '_value', {\n            enumerable: false,\n            configurable: false,\n            writable: false,\n            value: val\n        });\n\n        this.field = field;\n    }\n\n  /**\n   * Returns the field value.\n   *\n   * @return {*} Returns the current value.\n   */\n    get value () {\n        return this._value;\n    }\n\n  /**\n   * Converts to human readable string.\n   *\n   * @override\n   * @return {string} Returns a human readable string of the field value.\n   *\n   */\n    toString () {\n        return String(this.value);\n    }\n\n  /**\n   * Returns the value of the field.\n   *\n   * @override\n   * @return {*} Returns the field value.\n   */\n    valueOf () {\n        return this.value;\n    }\n}\n\nexport default Value;\n"],"sourceRoot":""}