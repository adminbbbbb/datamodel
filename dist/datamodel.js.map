{"version":3,"sources":["webpack://DataModel/webpack/universalModuleDefinition","webpack://DataModel/webpack/bootstrap","webpack://DataModel/./node_modules/d3-dsv/src/autoType.js","webpack://DataModel/./node_modules/d3-dsv/src/csv.js","webpack://DataModel/./node_modules/d3-dsv/src/dsv.js","webpack://DataModel/./node_modules/d3-dsv/src/index.js","webpack://DataModel/./node_modules/d3-dsv/src/tsv.js","webpack://DataModel/./src/constants/index.js","webpack://DataModel/./src/converter/dataConverterStore.js","webpack://DataModel/./src/converter/defaultConverters/autoConverter.js","webpack://DataModel/./src/converter/defaultConverters/dsvArrayConverter.js","webpack://DataModel/./src/converter/defaultConverters/dsvStringConverter.js","webpack://DataModel/./src/converter/defaultConverters/index.js","webpack://DataModel/./src/converter/defaultConverters/jsonConverter.js","webpack://DataModel/./src/converter/index.js","webpack://DataModel/./src/converter/model/dataConverter.js","webpack://DataModel/./src/converter/utils/auto-resolver.js","webpack://DataModel/./src/converter/utils/dsv-arr.js","webpack://DataModel/./src/converter/utils/dsv-str.js","webpack://DataModel/./src/converter/utils/flat-json.js","webpack://DataModel/./src/datamodel.js","webpack://DataModel/./src/default-config.js","webpack://DataModel/./src/enums/data-format.js","webpack://DataModel/./src/enums/dimension-subtype.js","webpack://DataModel/./src/enums/field-type.js","webpack://DataModel/./src/enums/filtering-mode.js","webpack://DataModel/./src/enums/group-by-functions.js","webpack://DataModel/./src/enums/index.js","webpack://DataModel/./src/enums/measure-subtype.js","webpack://DataModel/./src/export.js","webpack://DataModel/./src/field-creator.js","webpack://DataModel/./src/field-store.js","webpack://DataModel/./src/fields/binned/index.js","webpack://DataModel/./src/fields/categorical/index.js","webpack://DataModel/./src/fields/continuous/index.js","webpack://DataModel/./src/fields/dimension/index.js","webpack://DataModel/./src/fields/field-registry.js","webpack://DataModel/./src/fields/field/index.js","webpack://DataModel/./src/fields/helper.js","webpack://DataModel/./src/fields/index.js","webpack://DataModel/./src/fields/measure/index.js","webpack://DataModel/./src/fields/parsers/binned-parser/index.js","webpack://DataModel/./src/fields/parsers/categorical-parser/index.js","webpack://DataModel/./src/fields/parsers/continuous-parser/index.js","webpack://DataModel/./src/fields/parsers/field-parser/index.js","webpack://DataModel/./src/fields/parsers/temporal-parser/index.js","webpack://DataModel/./src/fields/partial-field/index.js","webpack://DataModel/./src/fields/temporal/index.js","webpack://DataModel/./src/helper.js","webpack://DataModel/./src/index.js","webpack://DataModel/./src/invalid-aware-types.js","webpack://DataModel/./src/operator/bucket-creator.js","webpack://DataModel/./src/operator/compose.js","webpack://DataModel/./src/operator/cross-product.js","webpack://DataModel/./src/operator/data-builder.js","webpack://DataModel/./src/operator/difference.js","webpack://DataModel/./src/operator/get-common-schema.js","webpack://DataModel/./src/operator/group-by-function.js","webpack://DataModel/./src/operator/group-by.js","webpack://DataModel/./src/operator/index.js","webpack://DataModel/./src/operator/merge-sort.js","webpack://DataModel/./src/operator/natural-join-filter-function.js","webpack://DataModel/./src/operator/natural-join.js","webpack://DataModel/./src/operator/outer-join.js","webpack://DataModel/./src/operator/pure-operators.js","webpack://DataModel/./src/operator/row-diffset-iterator.js","webpack://DataModel/./src/operator/sort.js","webpack://DataModel/./src/operator/union.js","webpack://DataModel/./src/relation.js","webpack://DataModel/./src/stats/index.js","webpack://DataModel/./src/utils/column-major.js","webpack://DataModel/./src/utils/date-time-formatter.js","webpack://DataModel/./src/utils/domain-generator.js","webpack://DataModel/./src/utils/extend2.js","webpack://DataModel/./src/utils/helper.js","webpack://DataModel/./src/utils/index.js","webpack://DataModel/./src/utils/reducer-store.js","webpack://DataModel/./src/value.js"],"names":["autoType","object","key","value","trim","number","NaN","isNaN","test","Date","csv","dsv","csvParse","parse","csvParseRows","parseRows","csvFormat","format","csvFormatBody","formatBody","csvFormatRows","formatRows","EOL","EOF","QUOTE","NEWLINE","RETURN","objectConverter","columns","Function","map","name","i","JSON","stringify","join","customConverter","f","row","inferColumns","rows","columnSet","Object","create","forEach","column","push","pad","width","s","length","Array","formatYear","year","formatDate","date","hours","getUTCHours","minutes","getUTCMinutes","seconds","getUTCSeconds","milliseconds","getUTCMilliseconds","getUTCFullYear","getUTCMonth","getUTCDate","delimiter","reFormat","RegExp","DELIMITER","charCodeAt","text","convert","N","I","n","t","eof","eol","token","j","c","slice","replace","preformatBody","formatValue","concat","formatRow","tsv","tsvParse","tsvParseRows","tsvFormat","tsvFormatBody","tsvFormatRows","PROPAGATION","ROW_ID","DM_DERIVATIVES","SELECT","PROJECT","GROUPBY","COMPOSE","CAL_VAR","BIN","SORT","JOINS","CROSS","LEFTOUTER","RIGHTOUTER","NATURAL","FULLOUTER","LOGICAL_OPERATORS","AND","OR","DataConverterStore","store","Map","converters","_getDefaultConverters","DSVStringConverter","DSVArrayConverter","JSONConverter","AutoDataConverter","set","converter","type","DataConverter","delete","has","get","converterStore","getStore","DataFormat","AUTO","data","schema","options","DSV_ARR","DSVArr","DSV_STR","DSVStr","FLAT_JSON","FlatJSON","_type","Error","Auto","dataFormat","detectDataFormat","arr","isArray","defaultOption","firstRowHeader","schemaFields","unitSchema","assign","columnMajor","headers","splice","headerMap","reduce","acc","h","fields","field","schemaField","headIndex","str","fieldSeparator","d3Dsv","header","insertionIndex","schemaFieldsName","item","keys","DataModel","args","_onPropagation","defOptions","order","formatter","withUid","getAllFields","sort","getPartialFieldspace","dataGenerated","dataBuilder","call","_rowDiffset","d","_colIdentifier","columnWise","addUid","uids","fieldNames","e","fmtFieldNames","fmtFieldIdx","next","idx","indexOf","elem","fIdx","fmtFn","datum","datumIdx","undefined","rowDiffset","ids","diffSets","split","Number","start","end","fill","_","fieldsArr","reducers","config","saveChild","groupByString","params","newDataModel","groupBy","persistDerivations","defaultReducer","reducerStore","setParent","sortingDetails","rawData","getData","dataInCSVArr","sortedDm","constructor","_dataFormat","getFieldspace","colData","formattedData","rowsCount","serializedData","rowIdx","colIdx","fieldName","partialFieldspace","_partialFieldspace","cachedValueObjects","_cachedValueObjects","partialField","fieldsObj","obj","Value","fieldIndex","findIndex","fieldinst","_cachedFieldsObj","_cachedDimension","_cachedMeasure","__calculateFieldspace","calculateFieldsConfig","dependency","sanitizeUnitSchema","replaceVar","fieldsConfig","getFieldsConfig","depVars","retrieveFn","depFieldIndices","fieldSpec","index","clone","fs","suppliedFields","cachedStore","cloneProvider","detachedRoot","computedValues","rowDiffsetIterator","fieldsData","createFields","addField","identifiers","addToNameSpace","propConfig","isMutableAction","propagationSourceId","sourceId","payload","rootModel","getRootDataModel","propagationNameSpace","_propagationNameSpace","rootGroupByModel","getRootGroupByModel","rootModels","groupByModel","model","addToPropNamespace","propagateToAllDataModels","propagationSource","propagateImmutableActions","eventName","callback","propModel","propListeners","fn","measureFieldName","binFieldName","measureField","createBinnedFieldData","binnedData","bins","binField","FieldType","DIMENSION","subtype","DimensionSubtype","BINNED","serialize","getSchema","dimensionArr","reducerFn","defConfig","mode","FilteringMode","NORMAL","splitWithSelect","uniqueFields","commonFields","fieldConfig","allFields","normalizedProjFieldSets","fieldSet","getNormalizedProFields","splitWithProject","InvalidAwareTypes","invalidAwareVals","fieldRegistry","Relation","CATEGORICAL","TEMPORAL","MEASURE","INVERSE","ALL","GROUP_BY_FUNCTIONS","SUM","AVG","MIN","MAX","FIRST","LAST","COUNT","STD","MeasureSubtype","CONTINUOUS","Operators","compose","bin","select","project","calculateVariable","crossProduct","difference","naturalJoin","leftOuterJoin","rightOuterJoin","fullOuterJoin","union","version","pkg","Stats","DateTimeFormatter","FieldsUtility","enums","createUnitField","BUILDER","build","createUnitFieldFromPartial","dataColumn","headersObj","fieldStore","createNamespace","fieldArr","dataId","getUniqueId","getMeasure","measureFields","getDimension","dimensionFields","Binned","binsArr","BinnedParser","Dimension","Categorical","hash","Set","domain","add","CategoricalParser","Continuous","calculateContinuousDomain","ContinuousParser","Measure","_cachedDomain","calculateDataDomain","Field","FieldTypeRegistry","_fieldType","dimension","registerDefaultFields","registerFieldType","Temporal","description","displayName","builder","_params","_context","PartialField","parser","min","POSITIVE_INFINITY","max","NEGATIVE_INFINITY","unit","defAggFn","defaultReducerName","numberFormat","formatNumber","val","regex","String","result","isInvalid","matched","match","parseFloat","NA","getInvalidType","FieldParser","parsedVal","TemporalParser","_dtf","nativeDate","getNativeDate","getTime","_sanitize","_cachedMinDiff","sortedData","filter","a","b","arrLn","minDiff","prevDatum","nextDatum","processedCount","Math","isFinite","parsedDatum","formatAs","prepareSelectionData","resp","entries","prepareJoinData","formattedValue","rawValue","updateFields","fieldStoreName","colIdentifier","collID","partialFieldMap","newFields","coll","persistCurrentDerivation","operation","criteriaFn","_derivation","op","meta","criteria","persistAncestorDerivation","sourceDm","newDm","_ancestorDerivation","selectModeMap","diffIndex","calcDiff","generateRowDiffset","lastInsertedValue","li","selectRowDiffsetIterator","checker","lastInsertedValueSel","lastInsertedValueRej","newRowDiffSet","rejRowDiffSet","shouldSelect","shouldReject","checkerResult","rejectRowDiffset","rowSplitDiffsetIterator","fieldStoreObj","splitRowDiffset","dimensionMap","dimensionSet","selectHelper","clonedDm","selectFn","iterator","selectorHelperFn","cloneWithAllFields","getKey","rowId","len","keyFn","internalValue","domainChecker","domainArr","some","dom","boundsChecker","isWithinDomain","fieldType","filterPropagationModel","propModels","fns","filterByDim","filterByMeasure","clonedModel","modelFieldsConfig","range","values","indices","def","dLen","valuesMap","rangeKeys","hasData","present","every","filteredModel","clonedDMs","cloned","derivation","derivationFormula","addDiffsetToClonedDm","selectConfig","cloneWithSelect","cloneConfig","extraCloneDm","setOfRowDiffsets","cloneWithProject","projField","projectionSet","actualProjField","projFieldSet","projFields","extend2","validateUnitSchema","sanitizeAndValidateSchema","resolveFieldName","dataHeader","fieldNameAs","as","updateData","relation","defaultConfig","nameSpace","valueObjects","rawFieldsData","formattedFieldsData","fieldInSchema","getDerivationArguments","applyExistingOperationOnModel","dataModel","derivations","getDerivations","selectionModel","getFilteredModel","path","propagateIdentifiers","propModelInf","excludeModels","criterias","propagate","handlePropagation","children","_children","child","matchingCriteria","groupedModel","_parent","find","getPathToRootModel","propagationInf","propagateToSource","filterFn","entry","addGroupedModel","conf","crit","actionCriterias","mutableActions","filteredCriteria","sourceActionCriterias","actionInf","actionConf","applyOnSource","action","models","sourceIdentifiers","inf","propagationModel","reverse","immutableActions","filterImmutableAction","criteriaModel","sourceNamespace","normalizedProjField","search","from","getNumberFormattedVal","require","module","exports","default","_invalidAwareValsMap","_value","NULL","NIL","invalid","nil","null","generateBuckets","binSize","buckets","findBucketRange","bucketRanges","leftIdx","rightIdx","midIdx","floor","binsCount","dMin","dMax","ceil","abs","unshift","dm","operations","currentDM","firstChild","dispose","defaultFilterFn","dm1","dm2","replaceCommonSchema","jointype","applicableFilterFn","dm1FieldStore","dm2FieldStore","dm1FieldStoreName","dm2FieldStoreName","commonSchemaList","getCommonSchema","tmpSchema","rowAdded","rowPosition","ii","tuple","userArg","cloneProvider1","cloneProvider2","dm1Fields","dm2Fields","tupleObj","cellVal","iii","retObj","reqSorting","tmpDataArr","colIArr","colName","insertInd","sortData","tmpData","hashTable","schemaNameArr","dm1FieldStoreFieldObj","dm2FieldStoreFieldObj","isArrEqual","prepareDataHelper","addData","hashData","schemaName","fs1","fs2","retArr","fs1Arr","getFilteredValues","sum","filteredNumber","totalSum","curr","avg","filteredValues","first","last","count","variance","mean","num","std","sqrt","fnList","getFieldArr","dimensions","getReducerObj","measures","defReducer","measureName","resolve","existingDataModel","sFieldArr","reducerObj","dbName","measureArr","hashMap","rowCount","defSortFn","a1","b1","merge","lo","mid","hi","sortFn","mainArr","auxArr","mergeSort","naturalJoinFilter","commonSchemaArr","retainTuple","dataModel1","dataModel2","rowDiffArr","diffStr","diffStsArr","getSortFn","dataType","sortType","retFunc","resolveStrSortOrder","fDetails","strSortOrder","sortOrder","toLowerCase","groupData","groupedData","fieldVal","createSortingFnArg","groupedDatum","targetFields","targetFieldDetails","arg","label","applyStandardSort","sortMeta","isCallable","sortingFn","m","makeGroupMapAndSort","depColumns","targetCol","currRow","fVal","nMap","applyGroupSort","detail","sortedGroupMap","nextMap","shift","dataObj","sDetial","groupSortingIdx","standardSortingDetails","groupSortingDetails","pop","source","_fieldStoreName","_fieldspace","joinWith","unionWith","differenceWith","projectionClone","rejectionClone","_fieldConfig","fieldObj","removeChild","sibling","parent","sd","convertToNativeDate","escape","dtParams","TOKEN_PREFIX","DATETIME_PARAM_SEQUENCE","YEAR","MONTH","DAY","HOUR","MINUTE","SECOND","MILLISECOND","defaultNumberParser","defVal","parseInt","defaultRangeParser","l","nVal","getTokenDefinitions","daysDef","short","long","monthsDef","definitions","H","extract","getHours","toString","p","P","M","mins","getMinutes","S","getSeconds","K","ms","getMilliseconds","day","getDay","A","getDate","month","getMonth","B","y","substring","presentDate","presentYear","trunc","getFullYear","Y","getTokenFormalNames","HOUR_12","AMPM_UPPERCASE","AMPM_LOWERCASE","SHORT_DAY","LONG_DAY","DAY_OF_MONTH","DAY_OF_MONTH_CONSTANT_WIDTH","SHORT_MONTH","LONG_MONTH","MONTH_OF_YEAR","SHORT_YEAR","LONG_YEAR","tokenResolver","defaultResolver","targetParam","hourFormat24","hourFormat12","ampmLower","ampmUpper","amOrpm","isPM","findTokens","tokenPrefix","tokenLiterals","occurrence","forwardChar","nDate","formattedStr","formattedVal","prototype","dateTimeStamp","extractTokenValue","dtParamSeq","noBreak","dtParamArr","resolverKey","resolverParams","resolverFn","param","resolvedVal","hasOwnProperty","apply","checkIfOnlyYear","tokenObj","lastOccurrenceIndex","occObj","occIndex","targetText","regexFormat","tokenArr","occurrenceLength","extractValues","OBJECTSTRING","objectToStrFn","objectToStr","arrayToStr","checkCyclicRef","parentArr","bIndex","obj1","obj2","skipUndef","tgtArr","srcArr","srcVal","tgtVal","cRef","isObject","isString","uniqueValues","round","random","arr1","arr2","ReducerStore","reducer","__unregister","defineProperties","enumerable","configurable","writable","_formattedValue","_internalValue"],"mappings":"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","file":"datamodel.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"DataModel\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"DataModel\"] = factory();\n\telse\n\t\troot[\"DataModel\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","export default function autoType(object) {\n  for (var key in object) {\n    var value = object[key].trim(), number;\n    if (!value) value = null;\n    else if (value === \"true\") value = true;\n    else if (value === \"false\") value = false;\n    else if (value === \"NaN\") value = NaN;\n    else if (!isNaN(number = +value)) value = number;\n    else if (/^([-+]\\d{2})?\\d{4}(-\\d{2}(-\\d{2})?)?(T\\d{2}:\\d{2}(:\\d{2}(\\.\\d{3})?)?(Z|[-+]\\d{2}:\\d{2})?)?$/.test(value)) value = new Date(value);\n    else continue;\n    object[key] = value;\n  }\n  return object;\n}\n","import dsv from \"./dsv\";\n\nvar csv = dsv(\",\");\n\nexport var csvParse = csv.parse;\nexport var csvParseRows = csv.parseRows;\nexport var csvFormat = csv.format;\nexport var csvFormatBody = csv.formatBody;\nexport var csvFormatRows = csv.formatRows;\n","var EOL = {},\n    EOF = {},\n    QUOTE = 34,\n    NEWLINE = 10,\n    RETURN = 13;\n\nfunction objectConverter(columns) {\n  return new Function(\"d\", \"return {\" + columns.map(function(name, i) {\n    return JSON.stringify(name) + \": d[\" + i + \"]\";\n  }).join(\",\") + \"}\");\n}\n\nfunction customConverter(columns, f) {\n  var object = objectConverter(columns);\n  return function(row, i) {\n    return f(object(row), i, columns);\n  };\n}\n\n// Compute unique columns in order of discovery.\nfunction inferColumns(rows) {\n  var columnSet = Object.create(null),\n      columns = [];\n\n  rows.forEach(function(row) {\n    for (var column in row) {\n      if (!(column in columnSet)) {\n        columns.push(columnSet[column] = column);\n      }\n    }\n  });\n\n  return columns;\n}\n\nfunction pad(value, width) {\n  var s = value + \"\", length = s.length;\n  return length < width ? new Array(width - length + 1).join(0) + s : s;\n}\n\nfunction formatYear(year) {\n  return year < 0 ? \"-\" + pad(-year, 6)\n    : year > 9999 ? \"+\" + pad(year, 6)\n    : pad(year, 4);\n}\n\nfunction formatDate(date) {\n  var hours = date.getUTCHours(),\n      minutes = date.getUTCMinutes(),\n      seconds = date.getUTCSeconds(),\n      milliseconds = date.getUTCMilliseconds();\n  return isNaN(date) ? \"Invalid Date\"\n      : formatYear(date.getUTCFullYear(), 4) + \"-\" + pad(date.getUTCMonth() + 1, 2) + \"-\" + pad(date.getUTCDate(), 2)\n      + (milliseconds ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \":\" + pad(seconds, 2) + \".\" + pad(milliseconds, 3) + \"Z\"\n      : seconds ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \":\" + pad(seconds, 2) + \"Z\"\n      : minutes || hours ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \"Z\"\n      : \"\");\n}\n\nexport default function(delimiter) {\n  var reFormat = new RegExp(\"[\\\"\" + delimiter + \"\\n\\r]\"),\n      DELIMITER = delimiter.charCodeAt(0);\n\n  function parse(text, f) {\n    var convert, columns, rows = parseRows(text, function(row, i) {\n      if (convert) return convert(row, i - 1);\n      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);\n    });\n    rows.columns = columns || [];\n    return rows;\n  }\n\n  function parseRows(text, f) {\n    var rows = [], // output rows\n        N = text.length,\n        I = 0, // current character index\n        n = 0, // current line number\n        t, // current token\n        eof = N <= 0, // current token followed by EOF?\n        eol = false; // current token followed by EOL?\n\n    // Strip the trailing newline.\n    if (text.charCodeAt(N - 1) === NEWLINE) --N;\n    if (text.charCodeAt(N - 1) === RETURN) --N;\n\n    function token() {\n      if (eof) return EOF;\n      if (eol) return eol = false, EOL;\n\n      // Unescape quotes.\n      var i, j = I, c;\n      if (text.charCodeAt(j) === QUOTE) {\n        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);\n        if ((i = I) >= N) eof = true;\n        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;\n        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }\n        return text.slice(j + 1, i - 1).replace(/\"\"/g, \"\\\"\");\n      }\n\n      // Find next delimiter or newline.\n      while (I < N) {\n        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;\n        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }\n        else if (c !== DELIMITER) continue;\n        return text.slice(j, i);\n      }\n\n      // Return last token before EOF.\n      return eof = true, text.slice(j, N);\n    }\n\n    while ((t = token()) !== EOF) {\n      var row = [];\n      while (t !== EOL && t !== EOF) row.push(t), t = token();\n      if (f && (row = f(row, n++)) == null) continue;\n      rows.push(row);\n    }\n\n    return rows;\n  }\n\n  function preformatBody(rows, columns) {\n    return rows.map(function(row) {\n      return columns.map(function(column) {\n        return formatValue(row[column]);\n      }).join(delimiter);\n    });\n  }\n\n  function format(rows, columns) {\n    if (columns == null) columns = inferColumns(rows);\n    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join(\"\\n\");\n  }\n\n  function formatBody(rows, columns) {\n    if (columns == null) columns = inferColumns(rows);\n    return preformatBody(rows, columns).join(\"\\n\");\n  }\n\n  function formatRows(rows) {\n    return rows.map(formatRow).join(\"\\n\");\n  }\n\n  function formatRow(row) {\n    return row.map(formatValue).join(delimiter);\n  }\n\n  function formatValue(value) {\n    return value == null ? \"\"\n        : value instanceof Date ? formatDate(value)\n        : reFormat.test(value += \"\") ? \"\\\"\" + value.replace(/\"/g, \"\\\"\\\"\") + \"\\\"\"\n        : value;\n  }\n\n  return {\n    parse: parse,\n    parseRows: parseRows,\n    format: format,\n    formatBody: formatBody,\n    formatRows: formatRows\n  };\n}\n","export {default as dsvFormat} from \"./dsv\";\nexport {csvParse, csvParseRows, csvFormat, csvFormatBody, csvFormatRows} from \"./csv\";\nexport {tsvParse, tsvParseRows, tsvFormat, tsvFormatBody, tsvFormatRows} from \"./tsv\";\nexport {default as autoType} from \"./autoType\";\n","import dsv from \"./dsv\";\n\nvar tsv = dsv(\"\\t\");\n\nexport var tsvParse = tsv.parse;\nexport var tsvParseRows = tsv.parseRows;\nexport var tsvFormat = tsv.format;\nexport var tsvFormatBody = tsv.formatBody;\nexport var tsvFormatRows = tsv.formatRows;\n","export { DataFormat, FilteringMode } from '../enums';\n/**\n * The event name for data propagation.\n */\nexport const PROPAGATION = 'propagation';\n\n/**\n * The name of the unique row id column in DataModel.\n */\nexport const ROW_ID = '__id__';\n\n/**\n * The enums for operation names performed on DataModel.\n */\nexport const DM_DERIVATIVES = {\n    SELECT: 'select',\n    PROJECT: 'project',\n    GROUPBY: 'group',\n    COMPOSE: 'compose',\n    CAL_VAR: 'calculatedVariable',\n    BIN: 'bin',\n    SORT: 'sort'\n};\n\nexport const JOINS = {\n    CROSS: 'cross',\n    LEFTOUTER: 'leftOuter',\n    RIGHTOUTER: 'rightOuter',\n    NATURAL: 'natural',\n    FULLOUTER: 'fullOuter'\n};\n\nexport const LOGICAL_OPERATORS = {\n    AND: 'and',\n    OR: 'or'\n};\n","import DataConverter from './model/dataConverter';\nimport { DSVStringConverter, DSVArrayConverter, JSONConverter, AutoDataConverter } from './defaultConverters';\n\nclass DataConverterStore {\n    constructor() {\n        this.store = new Map();\n        this.converters(this._getDefaultConverters());\n    }\n\n    _getDefaultConverters() {\n        return [\n            new DSVStringConverter(),\n            new DSVArrayConverter(),\n            new JSONConverter(),\n            new AutoDataConverter()\n        ];\n    }\n\n    /**\n     * Sets the given converters in the store and returns the store\n     * @param  {Array<DataConverter>} converters : contains array of converter instance\n     * @return { Map<String,DataConverter> }\n     */\n    converters(converters = []) {\n        converters.forEach(converter => this.store.set(converter.type, converter));\n        return this.store;\n    }\n\n    /**\n     * Registers a Converter of type DataConverter\n     * @param {DataConverter} converter : converter Instance\n     * @returns self\n     */\n    register(converter) {\n        if (converter instanceof DataConverter) {\n            this.store.set(converter.type, converter);\n            return this;\n        }\n        return null;\n    }\n\n    /**\n     * Rempves a converter from store\n     * @param {DataConverter} converter : converter Instance\n     * @returns self\n     */\n\n    unregister(converter) {\n        this.store.delete(converter.type);\n        return this;\n    }\n\n    get(name) {\n        if (this.store.has(name)) {\n            return this.store.get(name);\n        }\n        return null;\n    }\n\n}\n\nconst converterStore = (function () {\n    let store = null;\n\n    function getStore () {\n        store = new DataConverterStore();\n        return store;\n    }\n    return store || getStore();\n}());\n\nexport default converterStore;\n","import DataConverter from '../model/dataConverter';\nimport AUTO from '../utils/auto-resolver';\nimport DataFormat from '../../enums/data-format';\n\nexport default class AutoDataConverter extends DataConverter {\n    constructor() {\n        super(DataFormat.AUTO);\n    }\n\n    convert(data, schema, options) {\n        return AUTO(data, schema, options);\n    }\n}\n","import DataConverter from '../model/dataConverter';\nimport DSVArr from '../utils/dsv-arr';\nimport DataFormat from '../../enums/data-format';\n\nexport default class DSVArrayConverter extends DataConverter {\n    constructor() {\n        super(DataFormat.DSV_ARR);\n    }\n\n    convert(data, schema, options) {\n        return DSVArr(data, schema, options);\n    }\n}\n","import DataConverter from '../model/dataConverter';\nimport DSVStr from '../utils/dsv-str';\nimport DataFormat from '../../enums/data-format';\n\nexport default class DSVStringConverter extends DataConverter {\n    constructor() {\n        super(DataFormat.DSV_STR);\n    }\n\n    convert(data, schema, options) {\n        return DSVStr(data, schema, options);\n    }\n}\n","export { default as DSVStringConverter } from './dsvStringConverter';\nexport { default as JSONConverter } from './jsonConverter';\nexport { default as DSVArrayConverter } from './dsvArrayConverter';\nexport { default as AutoDataConverter } from './autoConverter';\n","import DataConverter from '../model/dataConverter';\nimport FlatJSON from '../utils/flat-json';\nimport DataFormat from '../../enums/data-format';\n\nexport default class JSONConverter extends DataConverter {\n    constructor() {\n        super(DataFormat.FLAT_JSON);\n    }\n\n    convert(data, schema, options) {\n        return FlatJSON(data, schema, options);\n    }\n}\n","import converterStore from './dataConverterStore';\nimport DataConverter from './model/dataConverter';\n\nexport { DataConverter, converterStore };\n","/**\n * Interface for all data converters\n */\nexport default class DataConverter {\n    constructor(type) {\n        this._type = type;\n    }\n\n    get type() {\n        return this._type;\n    }\n\n    convert() {\n        throw new Error('Convert method not implemented.');\n    }\n\n}\n","import FlatJSON from './flat-json';\nimport DSVArr from './dsv-arr';\nimport DSVStr from './dsv-str';\nimport { detectDataFormat } from '../../utils';\n\n/**\n * Parses the input data and detect the format automatically.\n *\n * @param {string|Array} data - The input data.\n * @param {Object} options - An optional config specific to data format.\n * @return {Array.<Object>} Returns an array of headers and column major data.\n */\nfunction Auto (data, schema, options) {\n    const converters = { FlatJSON, DSVStr, DSVArr };\n    const dataFormat = detectDataFormat(data);\n\n    if (!dataFormat) {\n        throw new Error('Couldn\\'t detect the data format');\n    }\n\n    return converters[dataFormat](data, schema, options);\n}\n\nexport default Auto;\n","import { columnMajor } from '../../utils';\n\n/**\n * Parses and converts data formatted in DSV array to a manageable internal format.\n *\n * @param {Array.<Array>} arr - A 2D array containing of the DSV data.\n * @param {Object} options - Option to control the behaviour of the parsing.\n * @param {boolean} [options.firstRowHeader=true] - Whether the first row of the dsv data is header or not.\n * @return {Array} Returns an array of headers and column major data.\n * @example\n *\n * // Sample input data:\n * const data = [\n *    [\"a\", \"b\", \"c\"],\n *    [1, 2, 3],\n *    [4, 5, 6],\n *    [7, 8, 9]\n * ];\n */\nfunction DSVArr(arr, schema, options) {\n    if (!Array.isArray(schema)) {\n        throw new Error('Schema missing or is in an unsupported format');\n    }\n    const defaultOption = {\n        firstRowHeader: true,\n    };\n    const schemaFields = schema.map(unitSchema => unitSchema.name);\n    options = Object.assign({}, defaultOption, options);\n\n    const columns = [];\n    const push = columnMajor(columns);\n\n    let headers = schemaFields;\n    if (options.firstRowHeader) {\n        // If header present then remove the first header row.\n        // Do in-place mutation to save space.\n        headers = arr.splice(0, 1)[0];\n    }\n    // create a map of the headers\n    const headerMap = headers.reduce((acc, h, i) => (\n        Object.assign(acc, { [h]: i })\n    ), {});\n\n    arr.forEach((fields) => {\n        const field = [];\n        schemaFields.forEach((schemaField) => {\n            const headIndex = headerMap[schemaField];\n            field.push(fields[headIndex]);\n        });\n        return push(...field);\n    });\n    return [schemaFields, columns];\n}\n\nexport default DSVArr;\n","import { dsvFormat as d3Dsv } from 'd3-dsv';\nimport DSVArr from './dsv-arr';\n\n/**\n * Parses and converts data formatted in DSV string to a manageable internal format.\n *\n * @todo Support to be given for https://tools.ietf.org/html/rfc4180.\n * @todo Sample implementation https://github.com/knrz/CSV.js/.\n *\n * @param {string} str - The input DSV string.\n * @param {Object} options - Option to control the behaviour of the parsing.\n * @param {boolean} [options.firstRowHeader=true] - Whether the first row of the dsv string data is header or not.\n * @param {string} [options.fieldSeparator=\",\"] - The separator of two consecutive field.\n * @return {Array} Returns an array of headers and column major data.\n * @example\n *\n * // Sample input data:\n * const data = `\n * a,b,c\n * 1,2,3\n * 4,5,6\n * 7,8,9\n * `\n */\nfunction DSVStr (str, schema, options) {\n    const defaultOption = {\n        firstRowHeader: true,\n        fieldSeparator: ','\n    };\n    options = Object.assign({}, defaultOption, options);\n\n    const dsv = d3Dsv(options.fieldSeparator);\n    return DSVArr(dsv.parseRows(str), schema, options);\n}\n\nexport default DSVStr;\n","import { columnMajor } from '../../utils';\n\n/**\n * Parses and converts data formatted in JSON to a manageable internal format.\n *\n * @param {Array.<Object>} arr - The input data formatted in JSON.\n * @return {Array.<Object>} Returns an array of headers and column major data.\n * @example\n *\n * // Sample input data:\n * const data = [\n *    {\n *      \"a\": 1,\n *      \"b\": 2,\n *      \"c\": 3\n *    },\n *    {\n *      \"a\": 4,\n *      \"b\": 5,\n *      \"c\": 6\n *    },\n *    {\n *      \"a\": 7,\n *      \"b\": 8,\n *      \"c\": 9\n *    }\n * ];\n */\nfunction FlatJSON (arr, schema) {\n    if (!Array.isArray(schema)) {\n        throw new Error('Schema missing or is in an unsupported format');\n    }\n\n    const header = {};\n    let i = 0;\n    let insertionIndex;\n    const columns = [];\n    const push = columnMajor(columns);\n    const schemaFieldsName = schema.map(unitSchema => unitSchema.name);\n\n    arr.forEach((item) => {\n        const fields = [];\n        schemaFieldsName.forEach((unitSchema) => {\n            if (unitSchema in header) {\n                insertionIndex = header[unitSchema];\n            } else {\n                header[unitSchema] = i++;\n                insertionIndex = i - 1;\n            }\n            fields[insertionIndex] = item[unitSchema];\n        });\n        push(...fields);\n    });\n\n    return [Object.keys(header), columns];\n}\n\nexport default FlatJSON;\n","/* eslint-disable default-case */\n\nimport { FieldType, DimensionSubtype, DataFormat, FilteringMode } from './enums';\nimport {\n    persistDerivations,\n    getRootGroupByModel,\n    propagateToAllDataModels,\n    getRootDataModel,\n    propagateImmutableActions,\n    addToPropNamespace,\n    sanitizeUnitSchema,\n    splitWithSelect,\n    splitWithProject,\n    getNormalizedProFields\n} from './helper';\nimport { DM_DERIVATIVES, PROPAGATION } from './constants';\nimport {\n    dataBuilder,\n    rowDiffsetIterator,\n    groupBy\n} from './operator';\nimport { createBinnedFieldData } from './operator/bucket-creator';\nimport Relation from './relation';\nimport reducerStore from './utils/reducer-store';\nimport { createFields } from './field-creator';\nimport InvalidAwareTypes from './invalid-aware-types';\nimport Value from './value';\nimport { converterStore } from './converter';\nimport { fieldRegistry } from './fields';\n\n/**\n * DataModel is an in-browser representation of tabular data. It supports\n * {@link https://en.wikipedia.org/wiki/Relational_algebra | relational algebra} operators as well as generic data\n * processing opearators.\n * DataModel extends {@link Relation} class which defines all the relational algebra opreators. DataModel gives\n * definition of generic data processing operators which are not relational algebra complient.\n *\n * @public\n * @class\n * @extends Relation\n * @memberof Datamodel\n */\nclass DataModel extends Relation {\n    /**\n     * Creates a new DataModel instance by providing data and schema. Data could be in the form of\n     * - Flat JSON\n     * - DSV String\n     * - 2D Array\n     *\n     * By default DataModel finds suitable adapter to serialize the data. DataModel also expects a\n     * {@link Schema | schema} for identifying the variables present in data.\n     *\n     * @constructor\n     * @example\n     * const data = loadData('cars.csv');\n     * const schema = [\n     *      { name: 'Name', type: 'dimension' },\n     *      { name: 'Miles_per_Gallon', type: 'measure', unit : 'cm', scale: '1000', numberformat: val => `${val}G`},\n     *      { name: 'Cylinders', type: 'dimension' },\n     *      { name: 'Displacement', type: 'measure' },\n     *      { name: 'Horsepower', type: 'measure' },\n     *      { name: 'Weight_in_lbs', type: 'measure' },\n     *      { name: 'Acceleration', type: 'measure' },\n     *      { name: 'Year', type: 'dimension', subtype: 'datetime', format: '%Y' },\n     *      { name: 'Origin', type: 'dimension' }\n     * ];\n     * const dm = new DataModel(data, schema, { name: 'Cars' });\n     * table(dm);\n     *\n     * @public\n     *\n     * @param {Array.<Object> | string | Array.<Array>} data Input data in any of the mentioned formats\n     * @param {Array.<Schema>} schema Defination of the variables. Order of the variables in data and order of the\n     *      variables in schema has to be same.\n     * @param {object} [options] Optional arguments to specify more settings regarding the creation part\n     * @param {string} [options.name] Name of the datamodel instance. If no name is given an auto generated name is\n     *      assigned to the instance.\n     * @param {string} [options.fieldSeparator=','] specify field separator type if the data is of type dsv string.\n     */\n    constructor (...args) {\n        super(...args);\n\n        this._onPropagation = [];\n    }\n\n    /**\n     * Reducers are simple functions which reduces an array of numbers to a representative number of the set.\n     * Like an array of numbers `[10, 20, 5, 15]` can be reduced to `12.5` if average / mean reducer function is\n     * applied. All the measure fields in datamodel (variables in data) needs a reducer to handle aggregation.\n     *\n     * @public\n     *\n     * @return {ReducerStore} Singleton instance of {@link ReducerStore}.\n     */\n    static get Reducers () {\n        return reducerStore;\n    }\n\n    /**\n     * Converters are functions that transforms data in various format tpo datamodel consumabe format.\n     */\n    static get Converters() {\n        return converterStore;\n    }\n\n    /**\n     * Register new type of fields\n     */\n    static get FieldTypes() {\n        return fieldRegistry;\n    }\n\n    /**\n     * Configure null, undefined, invalid values in the source data\n     *\n     * @public\n     *\n     * @param {Object} [config] - Configuration to control how null, undefined and non-parsable values are\n     * represented in DataModel.\n     * @param {string} [config.undefined] - Define how an undefined value will be represented.\n     * @param {string} [config.null] - Define how a null value will be represented.\n     * @param {string} [config.invalid] - Define how a non-parsable value will be represented.\n     */\n    static configureInvalidAwareTypes (config) {\n        return InvalidAwareTypes.invalidAwareVals(config);\n    }\n\n    /**\n     * Retrieve the data attached to an instance in JSON format.\n     *\n     * @example\n     * // DataModel instance is already prepared and assigned to dm variable\n     *  const data = dm.getData({\n     *      order: 'column',\n     *      formatter: {\n     *          origin: (val) => val === 'European Union' ? 'EU' : val;\n     *      }\n     *  });\n     *  console.log(data);\n     *\n     * @public\n     *\n     * @param {Object} [options] Options to control how the raw data is to be returned.\n     * @param {string} [options.order='row'] Defines if data is retieved in row order or column order. Possible values\n     *      are `'rows'` and `'columns'`\n     * @param {Function} [options.formatter=null] Formats the output data. This expects an object, where the keys are\n     *      the name of the variable needs to be formatted. The formatter function is called for each row passing the\n     *      value of the cell for a particular row as arguments. The formatter is a function in the form of\n     *      `function (value, rowId, schema) => { ... }`\n     *      Know more about {@link Fomatter}.\n     *\n     * @return {Array} Returns a multidimensional array of the data with schema. The return format looks like\n     *      ```\n     *          {\n     *              data,\n     *              schema\n     *          }\n     *      ```\n     */\n    getData (options) {\n        const defOptions = {\n            order: 'row',\n            formatter: null,\n            withUid: false,\n            getAllFields: false,\n            sort: []\n        };\n        options = Object.assign({}, defOptions, options);\n        const fields = this.getPartialFieldspace().fields;\n\n        const dataGenerated = dataBuilder.call(\n            this,\n            this.getPartialFieldspace().fields,\n            this._rowDiffset,\n            options.getAllFields ? fields.map(d => d.name()).join() : this._colIdentifier,\n            options.sort,\n            {\n                columnWise: options.order === 'column',\n                addUid: !!options.withUid\n            }\n        );\n\n        if (!options.formatter) {\n            return dataGenerated;\n        }\n\n        const { formatter } = options;\n        const { data, schema, uids } = dataGenerated;\n        const fieldNames = schema.map((e => e.name));\n        const fmtFieldNames = Object.keys(formatter);\n        const fmtFieldIdx = fmtFieldNames.reduce((acc, next) => {\n            const idx = fieldNames.indexOf(next);\n            if (idx !== -1) {\n                acc.push([idx, formatter[next]]);\n            }\n            return acc;\n        }, []);\n\n        if (options.order === 'column') {\n            fmtFieldIdx.forEach((elem) => {\n                const fIdx = elem[0];\n                const fmtFn = elem[1];\n\n                data[fIdx].forEach((datum, datumIdx) => {\n                    data[fIdx][datumIdx] = fmtFn.call(\n                        undefined,\n                        datum,\n                        uids[datumIdx],\n                        schema[fIdx]\n                    );\n                });\n            });\n        } else {\n            data.forEach((datum, datumIdx) => {\n                fmtFieldIdx.forEach((elem) => {\n                    const fIdx = elem[0];\n                    const fmtFn = elem[1];\n\n                    datum[fIdx] = fmtFn.call(\n                        undefined,\n                        datum[fIdx],\n                        uids[datumIdx],\n                        schema[fIdx]\n                    );\n                });\n            });\n        }\n\n        return dataGenerated;\n    }\n\n    /**\n     * Returns the unique ids in an array.\n     *\n     * @return {Array} Returns an array of ids.\n     */\n    getUids () {\n        const rowDiffset = this._rowDiffset;\n        const ids = [];\n\n        if (rowDiffset.length) {\n            const diffSets = rowDiffset.split(',');\n\n            diffSets.forEach((set) => {\n                let [start, end] = set.split('-').map(Number);\n\n                end = end !== undefined ? end : start;\n                ids.push(...Array(end - start + 1).fill().map((_, idx) => start + idx));\n            });\n        }\n\n        return ids;\n    }\n    /**\n     * Groups the data using particular dimensions and by reducing measures. It expects a list of dimensions using which\n     * it projects the datamodel and perform aggregations to reduce the duplicate tuples. Refer this\n     * {@link link_to_one_example_with_group_by | document} to know the intuition behind groupBy.\n     *\n     * DataModel by default provides definition of few {@link reducer | Reducers}.\n     * {@link ReducerStore | User defined reducers} can also be registered.\n     *\n     * This is the chained implementation of `groupBy`.\n     * `groupBy` also supports {@link link_to_compose_groupBy | composability}\n     *\n     * @example\n     * const groupedDM = dm.groupBy(['Year'], { horsepower: 'max' } );\n     * console.log(groupedDm);\n     *\n     * @public\n     *\n     * @param {Array.<string>} fieldsArr - Array containing the name of dimensions\n     * @param {Object} [reducers={}] - A map whose key is the variable name and value is the name of the reducer. If its\n     *      not passed, or any variable is ommitted from the object, default aggregation function is used from the\n     *      schema of the variable.\n     *\n     * @return {DataModel} Returns a new DataModel instance after performing the groupby.\n     */\n    groupBy (fieldsArr, reducers = {}, config = { saveChild: true }) {\n        const groupByString = `${fieldsArr.join()}`;\n        let params = [this, fieldsArr, reducers];\n        const newDataModel = groupBy(...params);\n\n        persistDerivations(\n            this,\n            newDataModel,\n            DM_DERIVATIVES.GROUPBY,\n            { fieldsArr, groupByString, defaultReducer: reducerStore.defaultReducer() },\n            reducers\n        );\n\n        if (config.saveChild) {\n            newDataModel.setParent(this);\n        } else {\n            newDataModel.setParent(null);\n        }\n\n        return newDataModel;\n    }\n\n    /**\n     * Performs sorting operation on the current {@link DataModel} instance according to the specified sorting details.\n     * Like every other operator it doesn't mutate the current DataModel instance on which it was called, instead\n     * returns a new DataModel instance containing the sorted data.\n     *\n     * DataModel support multi level sorting by listing the variables using which sorting needs to be performed and\n     * the type of sorting `ASC` or `DESC`.\n     *\n     * In the following example, data is sorted by `Origin` field in `DESC` order in first level followed by another\n     * level of sorting by `Acceleration` in `ASC` order.\n     *\n     * @example\n     * // here dm is the pre-declared DataModel instance containing the data of 'cars.json' file\n     * let sortedDm = dm.sort([\n     *    [\"Origin\", \"DESC\"]\n     *    [\"Acceleration\"] // Default value is ASC\n     * ]);\n     *\n     * console.log(dm.getData());\n     * console.log(sortedDm.getData());\n     *\n     * // Sort with a custom sorting function\n     * sortedDm = dm.sort([\n     *    [\"Origin\", \"DESC\"]\n     *    [\"Acceleration\", (a, b) => a - b] // Custom sorting function\n     * ]);\n     *\n     * console.log(dm.getData());\n     * console.log(sortedDm.getData());\n     *\n     * @text\n     * DataModel also provides another sorting mechanism out of the box where sort is applied to a variable using\n     * another variable which determines the order.\n     * Like the above DataModel contains three fields `Origin`, `Name` and `Acceleration`. Now, the data in this\n     * model can be sorted by `Origin` field according to the average value of all `Acceleration` for a\n     * particular `Origin` value.\n     *\n     * @example\n     * // here dm is the pre-declared DataModel instance containing the data of 'cars.json' file\n     * const sortedDm = dm.sort([\n     *     ['Origin', ['Acceleration', (a, b) => avg(...a.Acceleration) - avg(...b.Acceleration)]]\n     * ]);\n     *\n     * console.log(dm.getData());\n     * console.log(sortedDm.getData());\n     *\n     * @public\n     *\n     * @param {Array.<Array>} sortingDetails - Sorting details based on which the sorting will be performed.\n     * @return {DataModel} Returns a new instance of DataModel with sorted data.\n     */\n    sort (sortingDetails, config = { saveChild: false }) {\n        const rawData = this.getData({\n            order: 'row',\n            sort: sortingDetails\n        });\n        const header = rawData.schema.map(field => field.name);\n        const dataInCSVArr = [header].concat(rawData.data);\n\n        const sortedDm = new this.constructor(dataInCSVArr, rawData.schema, { dataFormat: 'DSVArr' });\n\n        persistDerivations(\n            this,\n            sortedDm,\n            DM_DERIVATIVES.SORT,\n            config,\n            sortingDetails\n        );\n\n        if (config.saveChild) {\n            sortedDm.setParent(this);\n        } else {\n            sortedDm.setParent(null);\n        }\n\n        return sortedDm;\n    }\n\n    /**\n     * Performs the serialization operation on the current {@link DataModel} instance according to the specified data\n     * type. When an {@link DataModel} instance is created, it de-serializes the input data into its internal format,\n     * and during its serialization process, it converts its internal data format to the specified data type and returns\n     * that data regardless what type of data is used during the {@link DataModel} initialization.\n     *\n     * @example\n     * // here dm is the pre-declared DataModel instance.\n     * const csvData = dm.serialize(DataModel.DataFormat.DSV_STR, { fieldSeparator: \",\" });\n     * console.log(csvData); // The csv formatted data.\n     *\n     * const jsonData = dm.serialize(DataModel.DataFormat.FLAT_JSON);\n     * console.log(jsonData); // The json data.\n     *\n     * @public\n     *\n     * @param {string} type - The data type name for serialization.\n     * @param {Object} options - The optional option object.\n     * @param {string} options.fieldSeparator - The field separator character for DSV data type.\n     * @return {Array|string} Returns the serialized data.\n     */\n    serialize (type, options) {\n        type = type || this._dataFormat;\n        options = Object.assign({}, { fieldSeparator: ',' }, options);\n\n        const fields = this.getFieldspace().fields;\n        const colData = fields.map(f => f.formattedData());\n        const rowsCount = colData[0].length;\n        let serializedData;\n        let rowIdx;\n        let colIdx;\n\n        if (type === DataFormat.FLAT_JSON) {\n            serializedData = [];\n            for (rowIdx = 0; rowIdx < rowsCount; rowIdx++) {\n                const row = {};\n                for (colIdx = 0; colIdx < fields.length; colIdx++) {\n                    row[fields[colIdx].name()] = colData[colIdx][rowIdx];\n                }\n                serializedData.push(row);\n            }\n        } else if (type === DataFormat.DSV_STR) {\n            serializedData = [fields.map(f => f.name()).join(options.fieldSeparator)];\n            for (rowIdx = 0; rowIdx < rowsCount; rowIdx++) {\n                const row = [];\n                for (colIdx = 0; colIdx < fields.length; colIdx++) {\n                    row.push(colData[colIdx][rowIdx]);\n                }\n                serializedData.push(row.join(options.fieldSeparator));\n            }\n            serializedData = serializedData.join('\\n');\n        } else if (type === DataFormat.DSV_ARR) {\n            serializedData = [fields.map(f => f.name())];\n            for (rowIdx = 0; rowIdx < rowsCount; rowIdx++) {\n                const row = [];\n                for (colIdx = 0; colIdx < fields.length; colIdx++) {\n                    row.push(colData[colIdx][rowIdx]);\n                }\n                serializedData.push(row);\n            }\n        } else {\n            throw new Error(`Data type ${type} is not supported`);\n        }\n\n        return serializedData;\n    }\n\n    addField (field) {\n        const fieldName = field.name();\n        this._colIdentifier += `,${fieldName}`;\n        const partialFieldspace = this._partialFieldspace;\n        const cachedValueObjects = partialFieldspace._cachedValueObjects;\n        const formattedData = field.formattedData();\n        const rawData = field.partialField.data;\n\n        if (!partialFieldspace.fieldsObj()[field.name()]) {\n            partialFieldspace.fields.push(field);\n            cachedValueObjects.forEach((obj, i) => {\n                obj[field.name()] = new Value(formattedData[i], rawData[i], field);\n            });\n        } else {\n            const fieldIndex = partialFieldspace.fields.findIndex(fieldinst => fieldinst.name() === fieldName);\n            fieldIndex >= 0 && (partialFieldspace.fields[fieldIndex] = field);\n        }\n\n        // flush out cached namespace values on addition of new fields\n        partialFieldspace._cachedFieldsObj = null;\n        partialFieldspace._cachedDimension = null;\n        partialFieldspace._cachedMeasure = null;\n\n        this.__calculateFieldspace().calculateFieldsConfig();\n        return this;\n    }\n\n    /**\n    * Creates a new variable calculated from existing variables. This method expects the definition of the newly created\n    * variable and a function which resolves the value of the new variable from existing variables.\n    *\n    * Can create a new measure based on existing variables:\n    * @example\n    *  // DataModel already prepared and assigned to dm variable;\n    *  const newDm = dataModel.calculateVariable({\n    *      name: 'powerToWeight',\n    *      type: 'measure'\n    *  }, ['horsepower', 'weight_in_lbs', (hp, weight) => hp / weight ]);\n    *\n    *\n    * Can create a new dimension based on existing variables:\n    * @example\n    *  // DataModel already prepared and assigned to dm variable;\n    *  const child = dataModel.calculateVariable(\n    *     {\n    *       name: 'Efficiency',\n    *       type: 'dimension'\n    *     }, ['horsepower', (hp) => {\n    *      if (hp < 80) { return 'low'; },\n    *      else if (hp < 120) { return 'moderate'; }\n    *      else { return 'high' }\n    *  }]);\n    *\n    * @public\n    *\n    * @param {Object} schema - The schema of newly defined variable.\n    * @param {Array.<string|function>} dependency - An array containing the dependency variable names and a resolver\n    * function as the last element.\n    * @param {Object} config - An optional config object.\n    * @param {boolean} [config.saveChild] - Whether the newly created DataModel will be a child.\n    * @param {boolean} [config.replaceVar] - Whether the newly created variable will replace the existing variable.\n    * @return {DataModel} Returns an instance of DataModel with the new field.\n    */\n    calculateVariable (schema, dependency, config) {\n        schema = sanitizeUnitSchema(schema);\n        config = Object.assign({}, { saveChild: true, replaceVar: false }, config);\n\n        const fieldsConfig = this.getFieldsConfig();\n        const depVars = dependency.slice(0, dependency.length - 1);\n        const retrieveFn = dependency[dependency.length - 1];\n\n        if (fieldsConfig[schema.name] && !config.replaceVar) {\n            throw new Error(`${schema.name} field already exists in datamodel`);\n        }\n\n        const depFieldIndices = depVars.map((field) => {\n            const fieldSpec = fieldsConfig[field];\n            if (!fieldSpec) {\n                // @todo dont throw error here, use warning in production mode\n                throw new Error(`${field} is not a valid column name.`);\n            }\n            return fieldSpec.index;\n        });\n\n        const clone = this.clone(config.saveChild);\n\n        const fs = clone.getFieldspace().fields;\n        const suppliedFields = depFieldIndices.map(idx => fs[idx]);\n\n        let cachedStore = {};\n        let cloneProvider = () => this.detachedRoot();\n\n        const computedValues = [];\n        rowDiffsetIterator(clone._rowDiffset, (i) => {\n            const fieldsData = suppliedFields.map(field => field.partialField.data[i]);\n            computedValues[i] = retrieveFn(...fieldsData, i, cloneProvider, cachedStore);\n        });\n        const [field] = createFields([computedValues], [schema], [schema.name]);\n        clone.addField(field);\n\n        persistDerivations(\n            this,\n            clone,\n            DM_DERIVATIVES.CAL_VAR,\n            { config: schema, fields: depVars },\n            retrieveFn\n        );\n\n        return clone;\n    }\n\n    /**\n     * Propagates changes across all the connected DataModel instances.\n     *\n     * @param {Array} identifiers - A list of identifiers that were interacted with.\n     * @param {Object} payload - The interaction specific details.\n     *\n     * @return {DataModel} DataModel instance.\n     */\n    propagate (identifiers, config = {}, addToNameSpace, propConfig = {}) {\n        const isMutableAction = config.isMutableAction;\n        const propagationSourceId = config.sourceId;\n        const payload = config.payload;\n        const rootModel = getRootDataModel(this);\n        const propagationNameSpace = rootModel._propagationNameSpace;\n        const rootGroupByModel = getRootGroupByModel(this);\n        const rootModels = {\n            groupByModel: rootGroupByModel,\n            model: rootModel\n        };\n\n        addToNameSpace && addToPropNamespace(propagationNameSpace, config, this);\n        propagateToAllDataModels(identifiers, rootModels, { propagationNameSpace,\n            sourceId: propagationSourceId,\n            propagationSource: this },\n            Object.assign({\n                payload\n            }, config));\n\n        if (isMutableAction) {\n            propagateImmutableActions(propagationNameSpace, rootModel, {\n                config,\n                propConfig\n            }, this);\n        }\n\n        return this;\n    }\n\n    /**\n     * Associates a callback with an event name.\n     *\n     * @param {string} eventName - The name of the event.\n     * @param {Function} callback - The callback to invoke.\n     * @return {DataModel} Returns this current DataModel instance itself.\n     */\n    on (eventName, callback) {\n        switch (eventName) {\n        case PROPAGATION:\n            this._onPropagation.push(callback);\n            break;\n        }\n        return this;\n    }\n\n    /**\n     * Unsubscribes the callbacks for the provided event name.\n     *\n     * @param {string} eventName - The name of the event to unsubscribe.\n     * @return {DataModel} Returns the current DataModel instance itself.\n     */\n    unsubscribe (eventName) {\n        switch (eventName) {\n        case PROPAGATION:\n            this._onPropagation = [];\n            break;\n\n        }\n        return this;\n    }\n\n    /**\n     * This method is used to invoke the method associated with propagation.\n     *\n     * @param {Object} payload The interaction payload.\n     * @param {DataModel} identifiers The propagated DataModel.\n     * @memberof DataModel\n     */\n    handlePropagation (propModel, payload) {\n        let propListeners = this._onPropagation;\n        propListeners.forEach(fn => fn.call(this, propModel, payload));\n    }\n\n    /**\n     * Performs the binning operation on a measure field based on the binning configuration. Binning means discretizing\n     * values of a measure. Binning configuration contains an array; subsequent values from the array marks the boundary\n     * of buckets in [inclusive, exclusive) range format. This operation does not mutate the subject measure field,\n     * instead, it creates a new field (variable) of type dimension and subtype binned.\n     *\n     * Binning can be configured by\n     * - providing custom bin configuration with non-uniform buckets,\n     * - providing bins count,\n     * - providing each bin size,\n     *\n     * When custom `buckets` are provided as part of binning configuration:\n     * @example\n     *  // DataModel already prepared and assigned to dm variable\n     *  const config = { name: 'binnedHP', buckets: [30, 80, 100, 110] }\n     *  const binnedDM = dataModel.bin('horsepower', config);\n     *\n     * @text\n     * When `binsCount` is defined as part of binning configuration:\n     * @example\n     *  // DataModel already prepared and assigned to dm variable\n     *  const config = { name: 'binnedHP', binsCount: 5, start: 0, end: 100 }\n     *  const binDM = dataModel.bin('horsepower', config);\n     *\n     * @text\n     * When `binSize` is defined as part of binning configuration:\n     * @example\n     *  // DataModel already prepared and assigned to dm variable\n     *  const config = { name: 'binnedHorsepower', binSize: 20, start: 5}\n     *  const binDM = dataModel.bin('horsepower', config);\n     *\n     * @public\n     *\n     * @param {string} measureFieldName - The name of the target measure field.\n     * @param {Object} config - The config object.\n     * @param {string} [config.name] - The name of the new field which will be created.\n     * @param {string} [config.buckets] - An array containing the bucket ranges.\n     * @param {string} [config.binSize] - The size of each bin. It is ignored when buckets are given.\n     * @param {string} [config.binsCount] - The total number of bins to generate. It is ignored when buckets are given.\n     * @param {string} [config.start] - The start value of the bucket ranges. It is ignored when buckets are given.\n     * @param {string} [config.end] - The end value of the bucket ranges. It is ignored when buckets are given.\n     * @return {DataModel} Returns a new {@link DataModel} instance with the new field.\n     */\n    bin (measureFieldName, config) {\n        const fieldsConfig = this.getFieldsConfig();\n\n        if (!fieldsConfig[measureFieldName]) {\n            throw new Error(`Field ${measureFieldName} doesn't exist`);\n        }\n\n        const binFieldName = config.name || `${measureFieldName}_binned`;\n\n        if (fieldsConfig[binFieldName]) {\n            throw new Error(`Field ${binFieldName} already exists`);\n        }\n\n        const measureField = this.getFieldspace().fieldsObj()[measureFieldName];\n        const { binnedData, bins } = createBinnedFieldData(measureField, this._rowDiffset, config);\n\n        const binField = createFields([binnedData], [\n            {\n                name: binFieldName,\n                type: FieldType.DIMENSION,\n                subtype: DimensionSubtype.BINNED,\n                bins\n            }], [binFieldName])[0];\n\n        const clone = this.clone(config.saveChild);\n        clone.addField(binField);\n\n        persistDerivations(\n            this,\n            clone,\n            DM_DERIVATIVES.BIN,\n             { measureFieldName, config, binFieldName },\n             null\n        );\n\n        return clone;\n    }\n\n    /**\n     * Creates a new {@link DataModel} instance with completely detached root from current {@link DataModel} instance,\n     * the new {@link DataModel} instance has no parent-children relationship with the current one, but has same data as\n     * the current one.\n     * This API is useful when a completely different {@link DataModel} but with same data as the current instance is\n     * needed.\n     *\n     * @example\n     *  const dm = new DataModel(data, schema);\n     *  const detachedDm = dm.detachedRoot();\n     *\n     * // has different namespace\n     * console.log(dm.getPartialFieldspace().name);\n     * console.log(detachedDm.getPartialFieldspace().name);\n     *\n     * // has same data\n     * console.log(dm.getData());\n     * console.log(detachedDm.getData());\n     *\n     * @public\n     *\n     * @return {DataModel} Returns a detached {@link DataModel} instance.\n     */\n    detachedRoot () {\n        const data = this.serialize(DataFormat.FLAT_JSON);\n        const schema = this.getSchema();\n\n        return new DataModel(data, schema);\n    }\n\n    /**\n     * Creates a set of new {@link DataModel} instances by splitting the set of rows in the source {@link DataModel}\n     * instance based on a set of dimensions.\n     *\n     * For each unique dimensional value, a new split is created which creates a unique {@link DataModel} instance for\n     *  that split\n     *\n     * If multiple dimensions are provided, it splits the source {@link DataModel} instance with all possible\n     * combinations of the dimensional values for all the dimensions provided\n     *\n     * Additionally, it also accepts a predicate function to reduce the set of rows provided. A\n     * {@link link_to_selection | Selection} is performed on all the split {@link DataModel} instances based on\n     * the predicate function\n     *\n     * @example\n     *  // without predicate function:\n     *  const splitDt = dt.splitByRow(['Origin'])\n     *  console.log(splitDt));\n     * // This should give three unique DataModel instances, one each having rows only for 'USA',\n     * // 'Europe' and 'Japan' respectively\n     *\n     * @example\n     *  // without predicate function:\n     *  const splitDtMulti = dt.splitByRow(['Origin', 'Cylinders'])\n     *  console.log(splitDtMulti));\n     * // This should give DataModel instances for all unique combinations of Origin and Cylinder values\n     *\n     * @example\n     * // with predicate function:\n     * const splitWithPredDt = dt.select(['Origin'], fields => fields.Origin.value === \"USA\")\n     * console.log(splitWithPredDt);\n     * // This should not include the DataModel for the Origin : 'USA'\n     *\n     *\n     * @public\n     *\n     * @param {Array} dimensionArr - Set of dimensions based on which the split should occur\n     * @param {Object} config - The configuration object\n     * @param {string} [config.saveChild] - Configuration to save child or not\n     * @param {string}[config.mode=FilteringMode.NORMAL] -The mode of the selection.\n     * @return {Array}  Returns the new DataModel instances after operation.\n     */\n    splitByRow (dimensionArr, reducerFn, config) {\n        const fieldsConfig = this.getFieldsConfig();\n\n        dimensionArr.forEach((fieldName) => {\n            if (!fieldsConfig[fieldName]) {\n                throw new Error(`Field ${fieldName} doesn't exist in the schema`);\n            }\n        });\n\n        const defConfig = {\n            mode: FilteringMode.NORMAL,\n            saveChild: true\n        };\n\n        config = Object.assign({}, defConfig, config);\n\n        return splitWithSelect(this, dimensionArr, reducerFn, config);\n    }\n\n    /**\n     * Creates a set of new {@link DataModel} instances by splitting the set of fields in the source {@link DataModel}\n     * instance based on a set of common and unique field names provided.\n     *\n     * Each DataModel created contains a set of fields which are common to all and a set of unique fields.\n     * It also accepts configurations such as saveChild and mode(inverse or normal) to include/exclude the respective\n     * fields\n     *\n     * @example\n     *  // without predicate function:\n     *  const splitDt = dt.splitByColumn( [['Acceleration'], ['Horsepower']], ['Origin'])\n     *  console.log(splitDt));\n     * // This should give two unique DataModel instances, both having the field 'Origin' and\n     * // one each having 'Acceleration' and 'Horsepower' fields respectively\n     *\n     * @example\n     *  // without predicate function:\n     *  const splitDtInv = dt.splitByColumn( [['Acceleration'], ['Horsepower'],['Origin', 'Cylinders'],\n     *                           {mode: 'inverse'})\n     *  console.log(splitDtInv));\n     * // This should give DataModel instances in the following way:\n     * // All DataModel Instances do not have the fields 'Origin' and 'Cylinders'\n     * // One DataModel Instance has rest of the fields except 'Acceleration' and the other DataModel instance\n     * // has rest of the fields except 'Horsepower'\n     *\n     *\n     *\n     * @public\n     *\n     * @param {Array} uniqueFields - Set of unique fields included in each datamModel instance\n     * @param {Array} commonFields - Set of common fields included in all datamModel instances\n     * @param {Object} config - The configuration object\n     * @param {string} [config.saveChild] - Configuration to save child or not\n     * @param {string}[config.mode=FilteringMode.NORMAL] -The mode of the selection.\n     * @return {Array}  Returns the new DataModel instances after operation.\n     */\n    splitByColumn (uniqueFields = [], commonFields = [], config) {\n        const defConfig = {\n            mode: FilteringMode.NORMAL,\n            saveChild: true\n        };\n        const fieldConfig = this.getFieldsConfig();\n        const allFields = Object.keys(fieldConfig);\n        const normalizedProjFieldSets = [[commonFields]];\n\n        config = Object.assign({}, defConfig, config);\n        uniqueFields = uniqueFields.length ? uniqueFields : [[]];\n\n\n        uniqueFields.forEach((fieldSet, i) => {\n            normalizedProjFieldSets[i] = getNormalizedProFields(\n                [...fieldSet, ...commonFields],\n                allFields,\n                fieldConfig);\n        });\n\n        return splitWithProject(this, normalizedProjFieldSets, config, allFields);\n    }\n\n\n}\n\nexport default DataModel;\n","import { DataFormat } from './enums';\n\nexport default {\n    dataFormat: DataFormat.AUTO\n};\n","/**\n * DataFormat Enum defines the format of the input data.\n * Based on the format of the data the respective adapter is loaded.\n *\n * @readonly\n * @enum {string}\n */\nconst DataFormat = {\n    FLAT_JSON: 'FlatJSON',\n    DSV_STR: 'DSVStr',\n    DSV_ARR: 'DSVArr',\n    AUTO: 'Auto'\n};\n\nexport default DataFormat;\n","/**\n * DimensionSubtype enum defines the sub types of the Dimensional Field.\n *\n * @readonly\n * @enum {string}\n */\nconst DimensionSubtype = {\n    CATEGORICAL: 'categorical',\n    TEMPORAL: 'temporal',\n    BINNED: 'binned'\n};\n\nexport default DimensionSubtype;\n","/**\n * FieldType enum defines the high level field based on which visuals are controlled.\n * Measure in a high level is numeric field and Dimension in a high level is string field.\n *\n * @readonly\n * @enum {string}\n */\nconst FieldType = {\n    MEASURE: 'measure',\n    DIMENSION: 'dimension'\n};\n\nexport default FieldType;\n","/**\n * Filtering mode enum defines the filering modes of DataModel.\n *\n * @readonly\n * @enum {string}\n */\nconst FilteringMode = {\n    NORMAL: 'normal',\n    INVERSE: 'inverse',\n    ALL: 'all'\n};\n\nexport default FilteringMode;\n","/**\n * Group by function names\n *\n * @readonly\n * @enum {string}\n */\nconst GROUP_BY_FUNCTIONS = {\n    SUM: 'sum',\n    AVG: 'avg',\n    MIN: 'min',\n    MAX: 'max',\n    FIRST: 'first',\n    LAST: 'last',\n    COUNT: 'count',\n    STD: 'std'\n};\n\nexport default GROUP_BY_FUNCTIONS;\n","/**\n * FilteringMode determines if resultant DataModel should be created from selection set or rejection set.\n *\n * The following modes are available\n * - `NORMAL`: Only entries from selection set are included in the resulatant DataModel instance\n * - `INVERSE`: Only entries from rejection set are included in the resulatant DataModel instance\n * - ALL: Both the entries from selection and rejection set are returned in two different DataModel instance\n */\n\nexport { default as DataFormat } from './data-format';\nexport { default as DimensionSubtype } from './dimension-subtype';\nexport { default as MeasureSubtype } from './measure-subtype';\nexport { default as FieldType } from './field-type';\nexport { default as FilteringMode } from './filtering-mode';\nexport { default as GROUP_BY_FUNCTIONS } from './group-by-functions';\n","/**\n * MeasureSubtype enum defines the sub types of the Measure Field.\n *\n * @readonly\n * @enum {string}\n */\nconst MeasureSubtype = {\n    CONTINUOUS: 'continuous'\n};\n\nexport default MeasureSubtype;\n","import DataModel from './datamodel';\nimport {\n  compose,\n  bin,\n  select,\n  project,\n  groupby as groupBy,\n  calculateVariable,\n  sort,\n  crossProduct,\n  difference,\n  naturalJoin,\n  leftOuterJoin,\n  rightOuterJoin,\n  fullOuterJoin,\n  union,\n  rowDiffsetIterator\n} from './operator';\nimport * as Stats from './stats';\nimport * as enums from './enums';\nimport { DataConverter } from './converter';\nimport { DateTimeFormatter } from './utils';\nimport { DataFormat, FilteringMode, DM_DERIVATIVES } from './constants';\nimport InvalidAwareTypes from './invalid-aware-types';\nimport pkg from '../package.json';\nimport * as FieldsUtility from './fields';\n\nconst Operators = {\n    compose,\n    bin,\n    select,\n    project,\n    groupBy,\n    calculateVariable,\n    sort,\n    crossProduct,\n    difference,\n    naturalJoin,\n    leftOuterJoin,\n    rightOuterJoin,\n    fullOuterJoin,\n    union,\n    rowDiffsetIterator\n};\n\nconst version = pkg.version;\nObject.assign(DataModel, {\n    Operators,\n    Stats,\n    DM_DERIVATIVES,\n    DateTimeFormatter,\n    DataFormat,\n    FilteringMode,\n    InvalidAwareTypes,\n    version,\n    DataConverter,\n    FieldsUtility\n}, enums);\n\nexport default DataModel;\n","import { FieldType, DimensionSubtype, MeasureSubtype } from './enums';\nimport { fieldRegistry } from './fields';\n\n/**\n * Creates a field instance according to the provided data and schema.\n *\n * @param {Array} data - The field data array.\n * @param {Object} schema - The field schema object.\n * @return {Field} Returns the newly created field instance.\n */\nfunction createUnitField(data, schema) {\n    data = data || [];\n\n    if (fieldRegistry.has(schema.subtype)) {\n        return fieldRegistry.get(schema.subtype)\n                        .BUILDER\n                        .fieldName(schema.name)\n                        .schema(schema)\n                        .data(data)\n                        .rowDiffset(`0-${data.length - 1}`)\n                        .build();\n    }\n    return fieldRegistry\n                    .get(schema.type === FieldType.MEASURE ? MeasureSubtype.CONTINUOUS : DimensionSubtype.CATEGORICAL)\n                    .BUILDER\n                    .fieldName(schema.name)\n                    .schema(schema)\n                    .data(data)\n                    .rowDiffset(`0-${data.length - 1}`)\n                    .build();\n}\n\n\n/**\n * Creates a field instance from partialField and rowDiffset.\n *\n * @param {PartialField} partialField - The corresponding partial field.\n * @param {string} rowDiffset - The data subset config.\n * @return {Field} Returns the newly created field instance.\n */\nexport function createUnitFieldFromPartial(partialField, rowDiffset) {\n    const { schema } = partialField;\n\n    if (fieldRegistry.has(schema.subtype)) {\n        return fieldRegistry.get(schema.subtype)\n                        .BUILDER\n                        .partialField(partialField)\n                        .rowDiffset(rowDiffset)\n                        .build();\n    }\n    return fieldRegistry\n                    .get(schema.type === FieldType.MEASURE ? MeasureSubtype.CONTINUOUS : DimensionSubtype.CATEGORICAL)\n                    .BUILDER\n                    .partialField(partialField)\n                    .rowDiffset(rowDiffset)\n                    .build();\n}\n\n/**\n * Creates the field instances with input data and schema.\n *\n * @param {Array} dataColumn - The data array for fields.\n * @param {Array} schema - The schema array for fields.\n * @param {Array} headers - The array of header names.\n * @return {Array.<Field>} Returns an array of newly created field instances.\n */\nexport function createFields(dataColumn, schema, headers) {\n    const headersObj = {};\n\n    if (!(headers && headers.length)) {\n        headers = schema.map(item => item.name);\n    }\n\n    headers.forEach((header, i) => {\n        headersObj[header] = i;\n    });\n\n    return schema.map(item => createUnitField(dataColumn[headersObj[item.name]], item));\n}\n","import { FieldType } from './enums';\nimport { getUniqueId } from './utils';\n\nconst fieldStore = {\n    data: {},\n\n    createNamespace (fieldArr, name) {\n        const dataId = name || getUniqueId();\n\n        this.data[dataId] = {\n            name: dataId,\n            fields: fieldArr,\n\n            fieldsObj () {\n                let fieldsObj = this._cachedFieldsObj;\n\n                if (!fieldsObj) {\n                    fieldsObj = this._cachedFieldsObj = {};\n                    this.fields.forEach((field) => {\n                        fieldsObj[field.name()] = field;\n                    });\n                }\n                return fieldsObj;\n            },\n            getMeasure () {\n                let measureFields = this._cachedMeasure;\n\n                if (!measureFields) {\n                    measureFields = this._cachedMeasure = {};\n                    this.fields.forEach((field) => {\n                        if (field.schema().type === FieldType.MEASURE) {\n                            measureFields[field.name()] = field;\n                        }\n                    });\n                }\n                return measureFields;\n            },\n            getDimension () {\n                let dimensionFields = this._cachedDimension;\n\n                if (!this._cachedDimension) {\n                    dimensionFields = this._cachedDimension = {};\n                    this.fields.forEach((field) => {\n                        if (field.schema().type === FieldType.DIMENSION) {\n                            dimensionFields[field.name()] = field;\n                        }\n                    });\n                }\n                return dimensionFields;\n            },\n        };\n        return this.data[dataId];\n    },\n};\n\nexport default fieldStore;\n","import Dimension from '../dimension';\nimport BinnedParser from '../parsers/binned-parser';\n\n/**\n * Represents binned field subtype.\n *\n * @public\n * @class\n * @extends Dimension\n */\nexport default class Binned extends Dimension {\n    /**\n     * Calculates the corresponding field domain.\n     *\n     * @public\n     * @override\n     * @return {Array} Returns the last and first values of bins config array.\n     */\n    calculateDataDomain () {\n        const binsArr = this.partialField.schema.bins;\n        return [binsArr[0], binsArr[binsArr.length - 1]];\n    }\n\n    /**\n     * Returns the bins config provided while creating the field instance.\n     *\n     * @public\n     * @return {Array} Returns the bins array config.\n     */\n    bins () {\n        return this.partialField.schema.bins;\n    }\n\n    static parser() {\n        return new BinnedParser();\n    }\n}\n","import { rowDiffsetIterator } from '../../operator/row-diffset-iterator';\nimport { DimensionSubtype } from '../../enums';\nimport Dimension from '../dimension';\nimport CategoricalParser from '../parsers/categorical-parser';\n/**\n * Represents categorical field subtype.\n *\n * @public\n * @class\n * @extends Dimension\n */\nexport default class Categorical extends Dimension {\n    /**\n     * Returns the subtype of the field.\n     *\n     * @public\n     * @override\n     * @return {string} Returns the subtype of the field.\n     */\n    subtype () {\n        return DimensionSubtype.CATEGORICAL;\n    }\n\n    /**\n     * Calculates the corresponding field domain.\n     *\n     * @public\n     * @override\n     * @return {Array} Returns the unique values.\n     */\n    calculateDataDomain () {\n        const hash = new Set();\n        const domain = [];\n\n        // here don't use this.data() as the iteration will be occurred two times on same data.\n        rowDiffsetIterator(this.rowDiffset, (i) => {\n            const datum = this.partialField.data[i];\n            if (!hash.has(datum)) {\n                hash.add(datum);\n                domain.push(datum);\n            }\n        });\n        return domain;\n    }\n\n    static parser() {\n        return new CategoricalParser();\n    }\n}\n","import { MeasureSubtype } from '../../enums';\nimport Measure from '../measure';\nimport ContinuousParser from '../parsers/continuous-parser';\nimport { calculateContinuousDomain } from '../helper';\n\n/**\n * Represents continuous field subtype.\n *\n * @public\n * @class\n * @extends Measure\n */\nexport default class Continuous extends Measure {\n    /**\n     * Returns the subtype of the field.\n     *\n     * @public\n     * @override\n     * @return {string} Returns the subtype of the field.\n     */\n    subtype () {\n        return MeasureSubtype.CONTINUOUS;\n    }\n\n    /**\n     * Calculates the corresponding field domain.\n     *\n     * @public\n     * @override\n     * @return {Array} Returns the min and max values.\n     */\n    calculateDataDomain () {\n        return calculateContinuousDomain(this.partialField.data, this.rowDiffset);\n    }\n\n    static parser() {\n        return new ContinuousParser();\n    }\n}\n","import Field from '../field';\n\n/**\n * Represents dimension field type.\n *\n * @public\n * @class\n * @extends Field\n */\nexport default class Dimension extends Field {\n    /**\n     * Returns the domain for the dimension field.\n     *\n     * @override\n     * @public\n     * @return {any} Returns the calculated domain.\n     */\n    domain () {\n        if (!this._cachedDomain) {\n            this._cachedDomain = this.calculateDataDomain();\n        }\n        return this._cachedDomain;\n    }\n\n    /**\n     * Calculates the corresponding field domain.\n     *\n     * @public\n     * @abstract\n     */\n    calculateDataDomain () {\n        throw new Error('Not yet implemented');\n    }\n\n     /**\n     * Returns the formatted version of the underlying field data.\n     *\n     * @public\n     * @override\n     * @return {Array} Returns the formatted data.\n     */\n    formattedData () {\n        return this.data();\n    }\n}\n","import Categorical from './categorical';\nimport Temporal from './temporal';\nimport Binned from './binned';\nimport Continuous from './continuous';\nimport { DimensionSubtype, MeasureSubtype } from '../enums';\n\n\nclass FieldTypeRegistry {\n    constructor() {\n        this._fieldType = new Map();\n    }\n\n    registerFieldType(subtype, dimension) {\n        this._fieldType.set(subtype, dimension);\n        return this;\n    }\n\n    has(type) {\n        return this._fieldType.has(type);\n    }\n\n    get(type) {\n        return this._fieldType.get(type);\n    }\n}\n\nconst registerDefaultFields = (store) => {\n    store\n                    .registerFieldType(DimensionSubtype.CATEGORICAL, Categorical)\n                    .registerFieldType(DimensionSubtype.TEMPORAL, Temporal)\n                    .registerFieldType(DimensionSubtype.BINNED, Binned)\n                    .registerFieldType(MeasureSubtype.CONTINUOUS, Continuous);\n};\n\nconst fieldRegistry = (function () {\n    let store = null;\n    function getStore () {\n        store = new FieldTypeRegistry();\n        registerDefaultFields(store);\n        return store;\n    }\n    return store || getStore();\n}());\n\nexport default fieldRegistry;\n\n","import { rowDiffsetIterator } from '../../operator/row-diffset-iterator';\nimport PartialField from '../partial-field';\n\n/**\n * In {@link DataModel}, every tabular data consists of column, a column is stored as field.\n * Field contains all the data for a given column in an array.\n *\n * Each record consists of several fields; the fields of all records form the columns.\n * Examples of fields: name, gender, sex etc.\n *\n * In DataModel, each field can have multiple attributes which describes its data and behaviour.\n * A field can have two types of data: Measure and Dimension.\n *\n * A Dimension Field is the context on which a data is categorized and the measure is the numerical values that\n * quantify the data set.\n * In short a dimension is the lens through which you are looking at your measure data.\n *\n * Refer to {@link Schema} to get info about possible field attributes.\n *\n * @public\n * @class\n */\nexport default class Field {\n    /**\n     * Initialize a new instance.\n     *\n     * @public\n     * @param {PartialField} partialField - The partialField instance which holds the whole data.\n     * @param {string} rowDiffset - The data subset definition.\n     */\n    constructor (partialField, rowDiffset) {\n        this.partialField = partialField;\n        this.rowDiffset = rowDiffset;\n    }\n\n    static parser() {\n        throw new Error('Not yet implemented');\n    }\n\n    /**\n     * Generates the field type specific domain.\n     *\n     * @public\n     * @abstract\n     */\n    domain () {\n        throw new Error('Not yet implemented');\n    }\n\n    /**\n     * Returns the the field schema.\n     *\n     * @public\n     * @return {string} Returns the field schema.\n     */\n    schema () {\n        return this.partialField.schema;\n    }\n\n    /**\n     * Returns the name of the field.\n     *\n     * @public\n     * @return {string} Returns the name of the field.\n     */\n    name () {\n        return this.partialField.name;\n    }\n\n    /**\n     * Returns the type of the field.\n     *\n     * @public\n     * @return {string} Returns the type of the field.\n     */\n    type () {\n        return this.partialField.schema.type;\n    }\n\n    /**\n     * Returns the subtype of the field.\n     *\n     * @public\n     * @return {string} Returns the subtype of the field.\n     */\n    subtype () {\n        return this.partialField.schema.subtype;\n    }\n\n    /**\n     * Returns the description of the field.\n     *\n     * @public\n     * @return {string} Returns the description of the field.\n     */\n    description () {\n        return this.partialField.schema.description;\n    }\n\n    /**\n     * Returns the display name of the field.\n     *\n     * @public\n     * @return {string} Returns the display name of the field.\n     */\n    displayName () {\n        return this.partialField.schema.displayName || this.partialField.schema.name;\n    }\n\n    /**\n     * Returns the data associated with the field.\n     *\n     * @public\n     * @return {Array} Returns the data.\n     */\n    data () {\n        const data = [];\n        rowDiffsetIterator(this.rowDiffset, (i) => {\n            data.push(this.partialField.data[i]);\n        });\n        return data;\n    }\n\n    /**\n     * Returns the formatted version of the underlying field data.\n     *\n     * @public\n     * @abstract\n     */\n    formattedData () {\n        throw new Error('Not yet implemented');\n    }\n\n    static get BUILDER() {\n        const builder = {\n            _params: {},\n            _context: this,\n            fieldName(name) {\n                this._params.name = name;\n                return this;\n            },\n            schema(schema) {\n                this._params.schema = schema;\n                return this;\n            },\n            data(data) {\n                this._params.data = data;\n                return this;\n            },\n            partialField(partialField) {\n                this._params.partialField = partialField;\n                return this;\n            },\n            rowDiffset(rowDiffset) {\n                this._params.rowDiffset = rowDiffset;\n                return this;\n            },\n            build() {\n                let partialField = null;\n                if (this._params.partialField instanceof PartialField) {\n                    partialField = this._params.partialField;\n                } else if (this._params.schema && this._params.data) {\n                    partialField = new PartialField(this._params.name,\n                                        this._params.data,\n                                        this._params.schema,\n                                        this._context.parser());\n                }\n                else {\n                    throw new Error('Invalid Field parameters');\n                }\n                return new this._context(partialField, this._params.rowDiffset);\n            }\n        };\n        return builder;\n    }\n}\n","import { rowDiffsetIterator } from '../operator/row-diffset-iterator';\nimport InvalidAwareTypes from '../invalid-aware-types';\n\nexport const calculateContinuousDomain = (data, rowDiffset) => {\n    let min = Number.POSITIVE_INFINITY;\n    let max = Number.NEGATIVE_INFINITY;\n\n    // here don't use this.data() as the iteration will be occurred two times on same data.\n    rowDiffsetIterator(rowDiffset, (i) => {\n        const datum = data[i];\n        if (datum instanceof InvalidAwareTypes) {\n            return;\n        }\n\n        if (datum < min) {\n            min = datum;\n        }\n        if (datum > max) {\n            max = datum;\n        }\n    });\n\n    return [min, max];\n};\n","export { default as Dimension } from './dimension';\nexport { default as Measure } from './measure';\nexport { default as FieldParser } from './parsers/field-parser';\nexport { default as fieldRegistry } from './field-registry';\nexport { columnMajor } from '../utils';\n","import { formatNumber } from '../../utils';\nimport { defaultReducerName } from '../../operator/group-by-function';\nimport Field from '../field';\n\n/**\n * Represents measure field type.\n *\n * @public\n * @class\n * @extends Field\n */\nexport default class Measure extends Field {\n  /**\n   * Returns the domain for the measure field.\n   *\n   * @override\n   * @public\n   * @return {any} Returns the calculated domain.\n   */\n    domain () {\n        if (!this._cachedDomain) {\n            this._cachedDomain = this.calculateDataDomain();\n        }\n        return this._cachedDomain;\n    }\n\n  /**\n   * Returns the unit of the measure field.\n   *\n   * @public\n   * @return {string} Returns unit of the field.\n   */\n    unit () {\n        return this.partialField.schema.unit;\n    }\n\n  /**\n   * Returns the aggregation function name of the measure field.\n   *\n   * @public\n   * @return {string} Returns aggregation function name of the field.\n   */\n    defAggFn () {\n        return this.partialField.schema.defAggFn || defaultReducerName;\n    }\n\n  /**\n   * Returns the number format of the measure field.\n   *\n   * @public\n   * @return {Function} Returns number format of the field.\n   */\n    numberFormat () {\n        const { numberFormat } = this.partialField.schema;\n        return numberFormat instanceof Function ? numberFormat : formatNumber;\n    }\n\n  /**\n   * Calculates the corresponding field domain.\n   *\n   * @public\n   * @abstract\n   */\n    calculateDataDomain () {\n        throw new Error('Not yet implemented');\n    }\n\n    /**\n     * Returns the formatted version of the underlying field data.\n     *\n     * @public\n     * @override\n     * @return {Array} Returns the formatted data.\n     */\n    formattedData () {\n        return this.data();\n    }\n}\n","import FieldParser from '../field-parser';\nimport InvalidAwareTypes from '../../../invalid-aware-types';\n\n/**\n * A FieldParser which parses the binned values.\n *\n * @public\n * @class\n * @implements {FieldParser}\n */\nexport default class BinnedParser extends FieldParser {\n  /**\n   * Parses a single binned value of a field and returns the sanitized value.\n   *\n   * @public\n   * @param {string} val - The value of the field.\n   * @return {string} Returns the sanitized value.\n   */\n    parse (val) {\n        const regex = /^\\s*([+-]?\\d+(?:\\.\\d+)?)\\s*-\\s*([+-]?\\d+(?:\\.\\d+)?)\\s*$/;\n        val = String(val);\n        let result;\n        // check if invalid date value\n        if (!InvalidAwareTypes.isInvalid(val)) {\n            let matched = val.match(regex);\n            result = matched ? `${Number.parseFloat(matched[1])}-${Number.parseFloat(matched[2])}`\n                             : InvalidAwareTypes.NA;\n        } else {\n            result = InvalidAwareTypes.getInvalidType(val);\n        }\n        return result;\n    }\n}\n","import FieldParser from '../field-parser';\nimport InvalidAwareTypes from '../../../invalid-aware-types';\n\n/**\n * A FieldParser which parses the categorical values.\n *\n * @public\n * @class\n * @implements {FieldParser}\n */\nexport default class CategoricalParser extends FieldParser {\n  /**\n   * Parses a single value of a field and returns the stringified form.\n   *\n   * @public\n   * @param {string|number} val - The value of the field.\n   * @return {string} Returns the stringified value.\n   */\n    parse (val) {\n        let result;\n        // check if invalid date value\n        if (!InvalidAwareTypes.isInvalid(val)) {\n            result = String(val).trim();\n        } else {\n            result = InvalidAwareTypes.getInvalidType(val);\n        }\n        return result;\n    }\n}\n","import FieldParser from '../field-parser';\nimport InvalidAwareTypes from '../../../invalid-aware-types';\n\n/**\n * A FieldParser which parses the continuous values.\n *\n * @public\n * @class\n * @implements {FieldParser}\n */\nexport default class ContinuousParser extends FieldParser {\n  /**\n   * Parses a single value of a field and returns the number form.\n   *\n   * @public\n   * @param {string|number} val - The value of the field.\n   * @return {string} Returns the number value.\n   */\n    parse (val) {\n        let result;\n        // check if invalid date value\n        if (!InvalidAwareTypes.isInvalid(val)) {\n            let parsedVal = parseFloat(val, 10);\n            result = Number.isNaN(parsedVal) ? InvalidAwareTypes.NA : parsedVal;\n        } else {\n            result = InvalidAwareTypes.getInvalidType(val);\n        }\n        return result;\n    }\n}\n","/**\n * A interface to represent a parser which is responsible to parse the field.\n *\n * @public\n * @interface\n */\nexport default class FieldParser {\n    /**\n     * Parses a single value of a field and return the sanitized form.\n     *\n     * @public\n     * @abstract\n     */\n    parse () {\n        throw new Error('Not yet implemented');\n    }\n}\n","import { DateTimeFormatter } from '../../../utils';\nimport FieldParser from '../field-parser';\nimport InvalidAwareTypes from '../../../invalid-aware-types';\n\n/**\n * A FieldParser which parses the temporal values.\n *\n * @public\n * @class\n * @implements {FieldParser}\n */\nexport default class TemporalParser extends FieldParser {\n\n    /**\n     * Parses a single value of a field and returns the millisecond value.\n     *\n     * @public\n     * @param {string|number} val - The value of the field.\n     * @return {number} Returns the millisecond value.\n     */\n    parse (val, { format }) {\n        let result;\n        // check if invalid date value\n        if (!this._dtf) {\n            this._dtf = new DateTimeFormatter(format);\n        }\n        if (!InvalidAwareTypes.isInvalid(val)) {\n            let nativeDate = this._dtf.getNativeDate(val);\n            result = nativeDate ? nativeDate.getTime() : InvalidAwareTypes.NA;\n        } else {\n            result = InvalidAwareTypes.getInvalidType(val);\n        }\n        return result;\n    }\n}\n","/**\n * Stores the full data and the metadata of a field. It provides\n * a single source of data from which the future Field\n * instance can get a subset of it with a rowDiffset config.\n *\n * @class\n * @public\n */\nexport default class PartialField {\n    /**\n     * Initialize a new instance.\n     *\n     * @public\n     * @param {string} name - The name of the field.\n     * @param {Array} data - The data array.\n     * @param {Object} schema - The schema object of the corresponding field.\n     * @param {FieldParser} parser - The parser instance corresponding to that field.\n     */\n    constructor (name, data, schema, parser) {\n        this.name = name;\n        this.schema = schema;\n        this.parser = parser;\n        this.data = this._sanitize(data);\n    }\n\n    /**\n     * Sanitizes the field data.\n     *\n     * @private\n     * @param {Array} data - The actual input data.\n     * @return {Array} Returns the sanitized data.\n     */\n    _sanitize (data) {\n        return data.map(datum => this.parser.parse(datum, { format: this.schema.format }));\n    }\n}\n","import { rowDiffsetIterator } from '../../operator/row-diffset-iterator';\nimport Dimension from '../dimension';\nimport { DateTimeFormatter } from '../../utils';\nimport InvalidAwareTypes from '../../invalid-aware-types';\nimport TemporalParser from '../parsers/temporal-parser';\nimport { calculateContinuousDomain } from '../helper';\n\n/**\n * Represents temporal field subtype.\n *\n * @public\n * @class\n * @extends Dimension\n */\nexport default class Temporal extends Dimension {\n     /**\n     * Initialize a new instance.\n     *\n     * @public\n     * @param {PartialField} partialField - The partialField instance which holds the whole data.\n     * @param {string} rowDiffset - The data subset definition.\n     */\n    constructor (partialField, rowDiffset) {\n        super(partialField, rowDiffset);\n\n        this._cachedMinDiff = null;\n    }\n\n     /**\n     * Calculates the corresponding field domain.\n     *\n     * @public\n     * @override\n     * @return {Array} Returns the unique values.\n     */\n    calculateDataDomain () {\n        return calculateContinuousDomain(this.partialField.data, this.rowDiffset);\n    }\n\n\n    /**\n     * Calculates the minimum consecutive difference from the associated field data.\n     *\n     * @public\n     * @return {number} Returns the minimum consecutive diff in milliseconds.\n     */\n    minimumConsecutiveDifference () {\n        if (this._cachedMinDiff) {\n            return this._cachedMinDiff;\n        }\n\n        const sortedData = this.data().filter(item => !(item instanceof InvalidAwareTypes)).sort((a, b) => a - b);\n        const arrLn = sortedData.length;\n        let minDiff = Number.POSITIVE_INFINITY;\n        let prevDatum;\n        let nextDatum;\n        let processedCount = 0;\n\n        for (let i = 1; i < arrLn; i++) {\n            prevDatum = sortedData[i - 1];\n            nextDatum = sortedData[i];\n\n            if (nextDatum === prevDatum) {\n                continue;\n            }\n\n            minDiff = Math.min(minDiff, nextDatum - sortedData[i - 1]);\n            processedCount++;\n        }\n\n        if (!processedCount) {\n            minDiff = null;\n        }\n        this._cachedMinDiff = minDiff;\n\n        return this._cachedMinDiff;\n    }\n\n    /**\n     * Returns the format specified in the input schema while creating field.\n     *\n     * @public\n     * @return {string} Returns the datetime format.\n     */\n    format () {\n        return this.partialField.schema.format;\n    }\n\n    /**\n     * Returns the formatted version of the underlying field data\n     * If data is of type invalid or has missing format use the raw value\n     * @public\n     * @override\n     * @return {Array} Returns the formatted data.\n     */\n    formattedData () {\n        const data = [];\n        const dataFormat = this.format();\n\n        rowDiffsetIterator(this.rowDiffset, (i) => {\n            const datum = this.partialField.data[i];\n            // If value is of invalid type or format is missing\n            if (InvalidAwareTypes.isInvalid(datum) || (!dataFormat && Number.isFinite(datum))) {\n                // Use the invalid map value or the raw value\n                const parsedDatum = InvalidAwareTypes.getInvalidType(datum) || datum;\n                data.push(parsedDatum);\n            } else {\n                data.push(DateTimeFormatter.formatAs(datum, dataFormat));\n            }\n        });\n        return data;\n    }\n\n    static parser() {\n        return new TemporalParser();\n    }\n}\n\n","import { FieldType, FilteringMode, DimensionSubtype, MeasureSubtype, DataFormat } from './enums';\nimport fieldStore from './field-store';\nimport Value from './value';\nimport {\n    rowDiffsetIterator\n} from './operator';\nimport { DM_DERIVATIVES, LOGICAL_OPERATORS, ROW_ID } from './constants';\nimport { createFields, createUnitFieldFromPartial } from './field-creator';\nimport defaultConfig from './default-config';\nimport { converterStore } from './converter';\nimport { fieldRegistry } from './fields';\nimport { extend2, detectDataFormat } from './utils';\n\n/**\n * Prepares the selection data.\n */\nfunction prepareSelectionData (fields, formattedData, rawData, i) {\n    const resp = {};\n\n    for (const [key, field] of fields.entries()) {\n        resp[field.name()] = new Value(formattedData[key][i], rawData[key][i], field);\n    }\n    return resp;\n}\n\nexport function prepareJoinData (fields) {\n    const resp = {};\n\n    for (const key in fields) {\n        resp[key] = new Value(fields[key].formattedValue, fields[key].rawValue, key);\n    }\n    return resp;\n}\n\nexport const updateFields = ([rowDiffset, colIdentifier], partialFieldspace, fieldStoreName) => {\n    let collID = colIdentifier.length ? colIdentifier.split(',') : [];\n    let partialFieldMap = partialFieldspace.fieldsObj();\n    let newFields = collID.map(coll => createUnitFieldFromPartial(partialFieldMap[coll].partialField, rowDiffset));\n    return fieldStore.createNamespace(newFields, fieldStoreName);\n};\n\nexport const persistCurrentDerivation = (model, operation, config = {}, criteriaFn) => {\n    if (operation === DM_DERIVATIVES.COMPOSE) {\n        model._derivation.length = 0;\n        model._derivation.push(...criteriaFn);\n    } else {\n        model._derivation.push({\n            op: operation,\n            meta: config,\n            criteria: criteriaFn\n        });\n    }\n};\nexport const persistAncestorDerivation = (sourceDm, newDm) => {\n    newDm._ancestorDerivation.push(...sourceDm._ancestorDerivation, ...sourceDm._derivation);\n};\n\nexport const persistDerivations = (sourceDm, model, operation, config = {}, criteriaFn) => {\n    persistCurrentDerivation(model, operation, config, criteriaFn);\n    persistAncestorDerivation(sourceDm, model);\n};\n\nconst selectModeMap = {\n    [FilteringMode.NORMAL]: {\n        diffIndex: ['rowDiffset'],\n        calcDiff: [true, false]\n    },\n    [FilteringMode.INVERSE]: {\n        diffIndex: ['rejectRowDiffset'],\n        calcDiff: [false, true]\n    },\n    [FilteringMode.ALL]: {\n        diffIndex: ['rowDiffset', 'rejectRowDiffset'],\n        calcDiff: [true, true]\n    }\n};\n\nconst generateRowDiffset = (rowDiffset, i, lastInsertedValue) => {\n    if (lastInsertedValue !== -1 && i === (lastInsertedValue + 1)) {\n        const li = rowDiffset.length - 1;\n\n        rowDiffset[li] = `${rowDiffset[li].split('-')[0]}-${i}`;\n    } else {\n        rowDiffset.push(`${i}`);\n    }\n};\n\nexport const selectRowDiffsetIterator = (rowDiffset, checker, mode) => {\n    let lastInsertedValueSel = -1;\n    let lastInsertedValueRej = -1;\n    const newRowDiffSet = [];\n    const rejRowDiffSet = [];\n\n    const [shouldSelect, shouldReject] = selectModeMap[mode].calcDiff;\n\n    rowDiffsetIterator(rowDiffset, (i) => {\n        const checkerResult = checker(i);\n        checkerResult && shouldSelect && generateRowDiffset(newRowDiffSet, i, lastInsertedValueSel);\n        !checkerResult && shouldReject && generateRowDiffset(rejRowDiffSet, i, lastInsertedValueRej);\n    });\n    return {\n        rowDiffset: newRowDiffSet.join(','),\n        rejectRowDiffset: rejRowDiffSet.join(',')\n    };\n};\n\n\nexport const rowSplitDiffsetIterator = (rowDiffset, checker, mode, dimensionArr, fieldStoreObj) => {\n    let lastInsertedValue = {};\n    const splitRowDiffset = {};\n    const dimensionMap = {};\n\n    rowDiffsetIterator(rowDiffset, (i) => {\n        if (checker(i)) {\n            let hash = '';\n\n            let dimensionSet = { keys: {} };\n\n            dimensionArr.forEach((_) => {\n                const data = fieldStoreObj[_].partialField.data[i];\n                hash = `${hash}-${data}`;\n                dimensionSet.keys[_] = data;\n            });\n\n            if (splitRowDiffset[hash] === undefined) {\n                splitRowDiffset[hash] = [];\n                lastInsertedValue[hash] = -1;\n                dimensionMap[hash] = dimensionSet;\n            }\n\n            generateRowDiffset(splitRowDiffset[hash], i, lastInsertedValue[hash]);\n            lastInsertedValue[hash] = i;\n        }\n    });\n\n    return {\n        splitRowDiffset,\n        dimensionMap\n    };\n};\n\n\nexport const selectHelper = (clonedDm, selectFn, config, sourceDm, iterator) => {\n    let cachedStore = {};\n    let cloneProvider = () => sourceDm.detachedRoot();\n    const { mode } = config;\n    const rowDiffset = clonedDm._rowDiffset;\n    const cachedValueObjects = clonedDm._partialFieldspace._cachedValueObjects;\n\n    const selectorHelperFn = index => selectFn(\n        cachedValueObjects[index],\n        index,\n        cloneProvider,\n        cachedStore\n    );\n\n    return iterator(rowDiffset, selectorHelperFn, mode);\n};\n\nexport const cloneWithAllFields = (model) => {\n    const clonedDm = model.clone(false);\n    const partialFieldspace = model.getPartialFieldspace();\n    clonedDm._colIdentifier = partialFieldspace.fields.map(f => f.name()).join(',');\n\n    // flush out cached namespace values on addition of new fields\n    partialFieldspace._cachedFieldsObj = null;\n    partialFieldspace._cachedDimension = null;\n    partialFieldspace._cachedMeasure = null;\n    clonedDm.__calculateFieldspace().calculateFieldsConfig();\n\n    return clonedDm;\n};\n\nconst getKey = (arr, data, fn, rowId) => {\n    let key = fn(arr, data, 0, rowId);\n\n    for (let i = 1, len = arr.length; i < len; i++) {\n        key = `${key},${fn(arr, data, i, rowId)}`;\n    }\n    return key;\n};\n\nconst keyFn = (arr, fields, idx, rowId) => {\n    const field = arr[idx];\n    const val = field === ROW_ID ? rowId : fields[field].internalValue;\n    return val;\n};\n\nconst domainChecker = (val, domain) => {\n    const domainArr = domain[0] instanceof Array ? domain : [domain];\n    return domainArr.some(dom => val >= dom[0] && val <= dom[1]);\n};\n\nconst boundsChecker = {\n    [MeasureSubtype.CONTINUOUS]: domainChecker,\n    [DimensionSubtype.TEMPORAL]: domainChecker\n};\n\nconst isWithinDomain = (value, domain, fieldType) => boundsChecker[fieldType](value, domain);\n\nexport const filterPropagationModel = (model, propModels, config = {}) => {\n    let fns = [];\n    const operation = config.operation || LOGICAL_OPERATORS.AND;\n    const { filterByDim = true, filterByMeasure = false, clone = true } = config;\n    const clonedModel = clone ? cloneWithAllFields(model) : model;\n    const modelFieldsConfig = clonedModel.getFieldsConfig();\n\n    if (!propModels.length) {\n        fns = [() => false];\n    } else {\n        fns = propModels.map(propModel => (({ criteria = {} }) => {\n            const { identifiers = [[], []], range } = criteria;\n            let [fieldNames = [], values = []] = identifiers;\n            const indices = fieldNames.reduce((map, name, i) => {\n                map[name] = i;\n                return map;\n            }, {});\n            fieldNames = fieldNames.filter(field => (field in modelFieldsConfig &&\n                modelFieldsConfig[field].def.type === FieldType.DIMENSION) || field === ROW_ID);\n            const dLen = fieldNames.length;\n            const valuesMap = {};\n\n            if (dLen) {\n                for (let i = 1, len = identifiers.length; i < len; i++) {\n                    const row = identifiers[i];\n                    const key = `${fieldNames.map((field) => {\n                        const idx = indices[field];\n                        return row[idx];\n                    })}`;\n                    valuesMap[key] = 1;\n                }\n            }\n            let rangeKeys = Object.keys(range || {}).filter(field => field in modelFieldsConfig);\n            const hasData = values.length || rangeKeys.length;\n\n            if (!filterByMeasure) {\n                rangeKeys = rangeKeys.filter(field => modelFieldsConfig[field].def.type !== FieldType.MEASURE);\n            }\n\n            if (!filterByDim) {\n                rangeKeys = rangeKeys.filter(field => modelFieldsConfig[field].def.type !== FieldType.DIMENSION);\n            }\n\n            return hasData ? (fields, i) => {\n                let present = true;\n                if (filterByDim) {\n                    present = dLen ? valuesMap[getKey(fieldNames, fields, keyFn, i)] : true;\n                }\n\n                return rangeKeys.every((field) => {\n                    const val = fields[field].internalValue;\n                    return isWithinDomain(val, range[field], modelFieldsConfig[field].def.subtype);\n                }) && present;\n            } : () => false;\n        })(propModel));\n    }\n\n    let filteredModel;\n    if (operation === LOGICAL_OPERATORS.AND) {\n        filteredModel = clonedModel.select((fields, i) => fns.every(fn => fn(fields, i)), {\n            saveChild: false\n        });\n    } else {\n        filteredModel = clonedModel.select((fields, i) => fns.some(fn => fn(fields, i)), {\n            saveChild: false\n        });\n    }\n\n    return filteredModel;\n};\n\n\nexport const splitWithSelect = (sourceDm, dimensionArr, reducerFn = val => val, config) => {\n    const {\n        saveChild,\n    } = config;\n    const fieldStoreObj = sourceDm.getFieldspace().fieldsObj();\n\n    const {\n        splitRowDiffset,\n        dimensionMap\n    } = selectHelper(\n        sourceDm.clone(saveChild),\n        reducerFn,\n        config,\n        sourceDm,\n        (...params) => rowSplitDiffsetIterator(...params, dimensionArr, fieldStoreObj)\n        );\n\n    const clonedDMs = [];\n    Object.keys(splitRowDiffset).sort().forEach((e) => {\n        if (splitRowDiffset[e]) {\n            const cloned = sourceDm.clone(saveChild);\n            const derivation = dimensionMap[e];\n            cloned._rowDiffset = splitRowDiffset[e].join(',');\n            cloned.__calculateFieldspace().calculateFieldsConfig();\n\n            const derivationFormula = fields => dimensionArr.every(_ => fields[_].internalValue === derivation.keys[_]);\n            // Store reference to child model and selector function\n            if (saveChild) {\n                persistDerivations(sourceDm, cloned, DM_DERIVATIVES.SELECT, config, derivationFormula);\n            }\n            cloned._derivation[cloned._derivation.length - 1].meta = dimensionMap[e];\n\n            clonedDMs.push(cloned);\n        }\n    });\n\n\n    return clonedDMs;\n};\nexport const addDiffsetToClonedDm = (clonedDm, rowDiffset, sourceDm, selectConfig, selectFn) => {\n    clonedDm._rowDiffset = rowDiffset;\n    clonedDm.__calculateFieldspace().calculateFieldsConfig();\n    persistDerivations(\n        sourceDm,\n        clonedDm,\n        DM_DERIVATIVES.SELECT,\n         { config: selectConfig },\n          selectFn\n    );\n};\n\n\nexport const cloneWithSelect = (sourceDm, selectFn, selectConfig, cloneConfig) => {\n    let extraCloneDm = {};\n\n    let { mode } = selectConfig;\n\n    const cloned = sourceDm.clone(cloneConfig.saveChild);\n    const setOfRowDiffsets = selectHelper(\n        cloned,\n        selectFn,\n        selectConfig,\n        sourceDm,\n        selectRowDiffsetIterator\n    );\n    const diffIndex = selectModeMap[mode].diffIndex;\n\n    addDiffsetToClonedDm(cloned, setOfRowDiffsets[diffIndex[0]], sourceDm, selectConfig, selectFn);\n\n    if (diffIndex.length > 1) {\n        extraCloneDm = sourceDm.clone(cloneConfig.saveChild);\n        addDiffsetToClonedDm(extraCloneDm, setOfRowDiffsets[diffIndex[1]], sourceDm, selectConfig, selectFn);\n        return [cloned, extraCloneDm];\n    }\n\n    return cloned;\n};\n\nexport const cloneWithProject = (sourceDm, projField, config, allFields) => {\n    const cloned = sourceDm.clone(config.saveChild);\n    let projectionSet = projField;\n    if (config.mode === FilteringMode.INVERSE) {\n        projectionSet = allFields.filter(fieldName => projField.indexOf(fieldName) === -1);\n    }\n    // cloned._colIdentifier = sourceDm._colIdentifier.split(',')\n    //                         .filter(coll => projectionSet.indexOf(coll) !== -1).join();\n    cloned._colIdentifier = projectionSet.join(',');\n    cloned.__calculateFieldspace().calculateFieldsConfig();\n\n    persistDerivations(\n        sourceDm,\n        cloned,\n        DM_DERIVATIVES.PROJECT,\n        { projField, config, actualProjField: projectionSet },\n        null\n    );\n\n    return cloned;\n};\n\n\nexport const splitWithProject = (sourceDm, projFieldSet, config, allFields) =>\n    projFieldSet.map(projFields =>\n        cloneWithProject(sourceDm, projFields, config, allFields));\n\nexport const sanitizeUnitSchema = (unitSchema) => {\n    // Do deep clone of the unit schema as the user might change it later.\n    unitSchema = extend2({}, unitSchema);\n    if (!unitSchema.type) {\n        unitSchema.type = FieldType.DIMENSION;\n    }\n\n    if (!unitSchema.subtype) {\n        switch (unitSchema.type) {\n        case FieldType.MEASURE:\n            unitSchema.subtype = MeasureSubtype.CONTINUOUS;\n            break;\n        default:\n        case FieldType.DIMENSION:\n            unitSchema.subtype = DimensionSubtype.CATEGORICAL;\n            break;\n        }\n    }\n\n    return unitSchema;\n};\n\nexport const validateUnitSchema = (unitSchema) => {\n    const { type, subtype, name } = unitSchema;\n    if (type === FieldType.DIMENSION || type === FieldType.MEASURE) {\n        if (!fieldRegistry.has(subtype)) {\n            throw new Error(`DataModel doesn't support measure field subtype ${subtype} used for ${name} field`);\n        }\n    } else {\n        throw new Error(`DataModel doesn't support field type ${type} used for ${name} field`);\n    }\n};\n\nexport const sanitizeAndValidateSchema = schema => schema.map((unitSchema) => {\n    unitSchema = sanitizeUnitSchema(unitSchema);\n    validateUnitSchema(unitSchema);\n    return unitSchema;\n});\n\nexport const resolveFieldName = (schema, dataHeader) => {\n    schema.forEach((unitSchema) => {\n        const fieldNameAs = unitSchema.as;\n        if (!fieldNameAs) { return; }\n\n        const idx = dataHeader.indexOf(unitSchema.name);\n        dataHeader[idx] = fieldNameAs;\n        unitSchema.name = fieldNameAs;\n        delete unitSchema.as;\n    });\n};\n\nexport const updateData = (relation, data, schema, options) => {\n    schema = sanitizeAndValidateSchema(schema);\n    options = Object.assign(Object.assign({}, defaultConfig), options);\n    const converter = converterStore.get(options.dataFormat);\n\n\n    if (!converter) {\n        throw new Error(`No converter function found for ${options.dataFormat} format`);\n    }\n\n    const [header, formattedData] = converter.convert(data, schema, options);\n    resolveFieldName(schema, header);\n    const fieldArr = createFields(formattedData, schema, header);\n\n    // This will create a new fieldStore with the fields\n    const nameSpace = fieldStore.createNamespace(fieldArr, options.name);\n    relation._partialFieldspace = nameSpace;\n\n    // If data is provided create the default colIdentifier and rowDiffset\n    relation._rowDiffset = formattedData.length && formattedData[0].length ? `0-${formattedData[0].length - 1}` : '';\n\n    // This stores the value objects which is passed to the filter method when selection operation is done.\n    const valueObjects = [];\n    const { fields } = nameSpace;\n    const rawFieldsData = fields.map(field => field.data());\n    const formattedFieldsData = fields.map(field => field.formattedData());\n    rowDiffsetIterator(relation._rowDiffset, (i) => {\n        valueObjects[i] = prepareSelectionData(fields, formattedFieldsData, rawFieldsData, i);\n    });\n    nameSpace._cachedValueObjects = valueObjects;\n\n    relation._colIdentifier = (schema.map(_ => _.name)).join();\n    relation._dataFormat = options.dataFormat === DataFormat.AUTO ? detectDataFormat(data) : options.dataFormat;\n    return relation;\n};\n\nexport const fieldInSchema = (schema, field) => {\n    let i = 0;\n\n    for (; i < schema.length; ++i) {\n        if (field === schema[i].name) {\n            return {\n                name: field,\n                type: schema[i].subtype || schema[i].type,\n                index: i,\n            };\n        }\n    }\n    return null;\n};\n\nexport const getDerivationArguments = (derivation) => {\n    let params = [];\n    let operation;\n    operation = derivation.op;\n    switch (operation) {\n    case DM_DERIVATIVES.SELECT:\n        params = [derivation.criteria];\n        break;\n    case DM_DERIVATIVES.PROJECT:\n        params = [derivation.meta.actualProjField];\n        break;\n    case DM_DERIVATIVES.SORT:\n        params = [derivation.criteria];\n        break;\n    case DM_DERIVATIVES.GROUPBY:\n        operation = 'groupBy';\n        params = [derivation.meta.groupByString.split(','), derivation.criteria];\n        break;\n    default:\n        operation = null;\n    }\n\n    return {\n        operation,\n        params\n    };\n};\n\nconst applyExistingOperationOnModel = (propModel, dataModel) => {\n    const derivations = dataModel.getDerivations();\n    let selectionModel = propModel;\n\n    derivations.forEach((derivation) => {\n        if (!derivation) {\n            return;\n        }\n\n        const { operation, params } = getDerivationArguments(derivation);\n        if (operation) {\n            selectionModel = selectionModel[operation](...params, {\n                saveChild: false\n            });\n        }\n    });\n\n    return selectionModel;\n};\n\nconst getFilteredModel = (propModel, path) => {\n    for (let i = 0, len = path.length; i < len; i++) {\n        const model = path[i];\n        propModel = applyExistingOperationOnModel(propModel, model);\n    }\n    return propModel;\n};\n\nconst propagateIdentifiers = (dataModel, propModel, config = {}, propModelInf = {}) => {\n    const excludeModels = propModelInf.excludeModels || [];\n    const criterias = propModelInf.criteria;\n\n    const propagate = excludeModels.length ? excludeModels.indexOf(dataModel) === -1 : true;\n\n    propagate && dataModel.handlePropagation(propModel, config);\n\n    const children = dataModel._children;\n    children.forEach((child) => {\n        const matchingCriteria = criterias.filter(val => val.groupedModel === child);\n        let selectionModel = applyExistingOperationOnModel(propModel, child);\n\n        if (matchingCriteria.length) {\n            selectionModel = filterPropagationModel(selectionModel, matchingCriteria, {\n                filterByDim: false,\n                filterByMeasure: true,\n                clone: false\n            });\n        }\n        propagateIdentifiers(child, selectionModel, config, propModelInf);\n    });\n};\n\nexport const getRootGroupByModel = (model) => {\n    while (model._parent && model._derivation.find(d => d.op !== DM_DERIVATIVES.GROUPBY)) {\n        model = model._parent;\n    }\n    return model;\n};\n\nexport const getRootDataModel = (model) => {\n    while (model._parent) {\n        model = model._parent;\n    }\n    return model;\n};\n\nexport const getPathToRootModel = (model, path = []) => {\n    while (model._parent) {\n        path.push(model);\n        model = model._parent;\n    }\n    return path;\n};\n\nexport const propagateToAllDataModels = (identifiers, rootModels, propagationInf, config) => {\n    let criteria;\n    const { propagationNameSpace, propagateToSource } = propagationInf;\n    const propagationSourceId = propagationInf.sourceId;\n    const filterFn = (entry) => {\n        const filter = config.filterFn || (() => true);\n        return filter(entry, config);\n    };\n\n    const addGroupedModel = ({ config: conf, model }) => {\n        const { criteria: crit } = conf;\n        let groupedModel;\n\n        if (crit !== null && crit.fields.some(d => d.type === FieldType.MEASURE)) {\n            groupedModel = getRootGroupByModel(model);\n        }\n        return Object.assign({}, conf, {\n            groupedModel\n        });\n    };\n\n    let criterias = [];\n\n    if (identifiers === null) {\n        criterias = [{\n            criteria: []\n        }];\n        criteria = [];\n    } else {\n        let actionCriterias = Object.values(propagationNameSpace.mutableActions);\n        if (propagateToSource !== false) {\n            actionCriterias = actionCriterias.filter(d => d.config.sourceId !== propagationSourceId);\n        }\n\n        const filteredCriteria = actionCriterias.filter(filterFn);\n\n        const excludeModels = [];\n\n        if (propagateToSource !== false) {\n            const sourceActionCriterias = Object.values(propagationNameSpace.mutableActions);\n\n            sourceActionCriterias.forEach((actionInf) => {\n                const actionConf = actionInf.config;\n                if (actionConf.applyOnSource === false && actionConf.action === config.action &&\n                        actionConf.sourceId !== propagationSourceId) {\n                    excludeModels.push(actionInf.model);\n                    criteria = sourceActionCriterias.filter(d => d !== actionInf).map(addGroupedModel);\n                    criteria.length && criterias.push({\n                        criteria,\n                        models: actionInf.model,\n                        path: getPathToRootModel(actionInf.model)\n                    });\n                }\n            });\n        }\n\n\n        criteria = [].concat(...[...filteredCriteria.map(addGroupedModel), {\n            criteria: identifiers,\n            groupedModel: identifiers !== null && identifiers.fields.some(d => d.type === FieldType.MEASURE) ?\n                getRootGroupByModel(propagationInf.propagationSource) : null\n        }]).filter(d => d !== null);\n        criterias.push({\n            criteria,\n            excludeModels: [...excludeModels, ...config.excludeModels || []]\n        });\n    }\n\n    const rootModel = rootModels.model;\n\n    const propConfig = Object.assign({\n        sourceIdentifiers: identifiers,\n        propagationSourceId\n    }, config);\n\n    criterias.forEach((inf) => {\n        const { criteria: crit } = inf;\n        const propagationModel = filterPropagationModel(rootModel, crit, {\n            filterByMeasure: !!crit.find(d => d.groupedModel === rootModel)\n        });\n        const path = inf.path;\n\n        if (path) {\n            const filteredModel = getFilteredModel(propagationModel, path.reverse());\n            inf.models.handlePropagation(filteredModel, propConfig);\n        } else {\n            propagateIdentifiers(rootModel, propagationModel, propConfig, {\n                excludeModels: inf.excludeModels,\n                criteria: crit\n            });\n        }\n    });\n};\n\nexport const propagateImmutableActions = (propagationNameSpace, rootModel, propagationInf) => {\n    const immutableActions = propagationNameSpace.immutableActions;\n\n    for (const action in immutableActions) {\n        const actionInf = immutableActions[action];\n        const actionConf = actionInf.config;\n        const propagationSourceId = propagationInf.config.sourceId;\n        const filterImmutableAction = propagationInf.propConfig.filterImmutableAction ?\n            propagationInf.propConfig.filterImmutableAction(actionConf, propagationInf.config) : true;\n        if (actionConf.sourceId !== propagationSourceId && filterImmutableAction) {\n            const criteriaModel = actionConf.criteria;\n            propagateToAllDataModels(criteriaModel, {\n                model: rootModel,\n                groupByModel: getRootGroupByModel(actionInf.model)\n            }, {\n                propagationNameSpace,\n                propagateToSource: false,\n                sourceId: propagationSourceId,\n                propagationSource: actionInf.model\n            }, actionConf);\n        }\n    }\n};\n\nexport const addToPropNamespace = (propagationNameSpace, config = {}, model) => {\n    let sourceNamespace;\n    const isMutableAction = config.isMutableAction;\n    const criteria = config.criteria;\n    const key = `${config.action}-${config.sourceId}`;\n\n    if (isMutableAction) {\n        sourceNamespace = propagationNameSpace.mutableActions;\n    } else {\n        sourceNamespace = propagationNameSpace.immutableActions;\n    }\n\n    if (criteria === null) {\n        delete sourceNamespace[key];\n    } else {\n        sourceNamespace[key] = {\n            model,\n            config\n        };\n    }\n\n    return this;\n};\n\n\nexport const getNormalizedProFields = (projField, allFields, fieldConfig) => {\n    const normalizedProjField = projField.reduce((acc, field) => {\n        if (field.constructor.name === 'RegExp') {\n            acc.push(...allFields.filter(fieldName => fieldName.search(field) !== -1));\n        } else if (field in fieldConfig) {\n            acc.push(field);\n        }\n        return acc;\n    }, []);\n    return Array.from(new Set(normalizedProjField)).map(field => field.trim());\n};\n\n/**\n * Get the numberFormatted value if numberFormat present,\n * else returns the supplied value.\n * @param {Object} field Field Instance\n * @param {Number|String} value\n * @return {Number|String}\n */\nexport const getNumberFormattedVal = (field, value) => {\n    if (field.numberFormat) {\n        return field.numberFormat()(value);\n    }\n    return value;\n};\n","const DataModel = require('./export');\n\nmodule.exports = DataModel.default ? DataModel.default : DataModel;\n","/**\n * A parser to parser null, undefined, invalid and NIL values.\n *\n * @public\n * @class\n */\nclass InvalidAwareTypes {\n    /**\n     * Static method which gets/sets the invalid value registry.\n     *\n     * @public\n     * @param {Object} config - The custom configuration supplied by user.\n     * @return {Object} Returns the invalid values registry.\n     */\n    static invalidAwareVals (config) {\n        if (!config) {\n            return InvalidAwareTypes._invalidAwareValsMap;\n        }\n        return Object.assign(InvalidAwareTypes._invalidAwareValsMap, config);\n    }\n\n    /**\n     * Initialize a new instance.\n     *\n     * @public\n     * @param {string} value - The value of the invalid data type.\n     */\n    constructor (value) {\n        this._value = value;\n    }\n\n    /**\n     * Returns the current value of the instance.\n     *\n     * @public\n     * @return {string} Returns the value of the invalid data type.\n     */\n    value () {\n        return this._value;\n    }\n\n    /**\n     * Returns the current value of the instance in string format.\n     *\n     * @public\n     * @return {string} Returns the value of the invalid data type.\n     */\n    toString () {\n        return String(this._value);\n    }\n\n    static isInvalid(val) {\n        return (val instanceof InvalidAwareTypes) || !!InvalidAwareTypes.invalidAwareVals()[val];\n    }\n\n    static getInvalidType(val) {\n        return val instanceof InvalidAwareTypes ? val : InvalidAwareTypes.invalidAwareVals()[val];\n    }\n}\n\n/**\n * Enums for Invalid types.\n */\nInvalidAwareTypes.NULL = new InvalidAwareTypes('null');\nInvalidAwareTypes.NA = new InvalidAwareTypes('na');\nInvalidAwareTypes.NIL = new InvalidAwareTypes('nil');\n\n/**\n * Default Registry for mapping the invalid values.\n *\n * @private\n */\nInvalidAwareTypes._invalidAwareValsMap = {\n    invalid: InvalidAwareTypes.NA,\n    nil: InvalidAwareTypes.NIL,\n    null: InvalidAwareTypes.NULL,\n    undefined: InvalidAwareTypes.NA\n};\n\nexport default InvalidAwareTypes;\n","import { rowDiffsetIterator } from './row-diffset-iterator';\nimport InvalidAwareTypes from '../invalid-aware-types';\n\nconst generateBuckets = (binSize, start, end) => {\n    const buckets = [];\n    let next = start;\n\n    while (next < end) {\n        buckets.push(next);\n        next += binSize;\n    }\n    buckets.push(next);\n\n    return buckets;\n};\n\nconst findBucketRange = (bucketRanges, value) => {\n    let leftIdx = 0;\n    let rightIdx = bucketRanges.length - 1;\n    let midIdx;\n    let range;\n\n    // Here use binary search as the bucketRanges is a sorted array\n    while (leftIdx <= rightIdx) {\n        midIdx = leftIdx + Math.floor((rightIdx - leftIdx) / 2);\n        range = bucketRanges[midIdx];\n\n        if (value >= range.start && value < range.end) {\n            return range;\n        } else if (value >= range.end) {\n            leftIdx = midIdx + 1;\n        } else if (value < range.start) {\n            rightIdx = midIdx - 1;\n        }\n    }\n\n    return null;\n};\n\n /**\n  * Creates the bin data from input measure field and supplied configs.\n  *\n  * @param {Measure} measureField - The Measure field instance.\n  * @param {string} rowDiffset - The datamodel rowDiffset values.\n  * @param {Object} config - The config object.\n  * @return {Object} Returns the binned data and the corresponding bins.\n  */\nexport function createBinnedFieldData (measureField, rowDiffset, config) {\n    let { buckets, binsCount, binSize, start, end } = config;\n    const [dMin, dMax] = measureField.domain();\n\n    if (!buckets) {\n        start = (start !== 0 && (!start || start > dMin)) ? dMin : start;\n        end = (end !== 0 && (!end || end < dMax)) ? (dMax + 1) : end;\n\n        if (binsCount) {\n            binSize = Math.ceil(Math.abs(end - start) / binsCount);\n        }\n\n        buckets = generateBuckets(binSize, start, end);\n    }\n\n    if (buckets[0] > dMin) {\n        buckets.unshift(dMin);\n    }\n    if (buckets[buckets.length - 1] <= dMax) {\n        buckets.push(dMax + 1);\n    }\n\n    const bucketRanges = [];\n    for (let i = 0; i < buckets.length - 1; i++) {\n        bucketRanges.push({\n            start: buckets[i],\n            end: buckets[i + 1]\n        });\n    }\n\n    const binnedData = [];\n    rowDiffsetIterator(rowDiffset, (i) => {\n        const datum = measureField.partialField.data[i];\n        if (datum instanceof InvalidAwareTypes) {\n            binnedData.push(datum);\n            return;\n        }\n\n        const range = findBucketRange(bucketRanges, datum);\n        binnedData.push(`${range.start}-${range.end}`);\n    });\n\n    return { binnedData, bins: buckets };\n}\n","import { persistDerivations } from '../helper';\nimport { DM_DERIVATIVES } from '../constants';\n\n/**\n * DataModel's opearators are exposed as composable functional operators as well as chainable operators. Chainable\n * operators are called on the instances of {@link Datamodel} and {@link Relation} class.\n *\n * Those same operators can be used as composable operators from `DataModel.Operators` namespace.\n *\n * All these operators have similar behaviour. All these operators when called with the argument returns a function\n * which expects a DataModel instance.\n *\n * @public\n * @module Operators\n * @namespace DataModel\n */\n\n/**\n * This is functional version of selection operator. {@link link_to_selection | Selection} is a row filtering operation.\n * It takes {@link SelectionPredicate | predicate} for filtering criteria and returns a function.\n * The returned function is called with the DataModel instance on which the action needs to be performed.\n *\n * {@link SelectionPredicate} is a function which returns a boolean value. For selection opearation the selection\n * function is called for each row of DataModel instance with the current row passed as argument.\n *\n * After executing {@link SelectionPredicate} the rows are labeled as either an entry of selection set or an entry\n * of rejection set.\n *\n * {@link FilteringMode} operates on the selection and rejection set to determine which one would reflect in the\n * resulatant datamodel.\n *\n * @warning\n * [Warn] Selection and rejection set is only a logical idea for concept explanation purpose.\n *\n * @error\n * [Error] `FilteringMode.ALL` is not a valid working mode for functional version of `select`. Its only avialable on the\n * chained version.\n *\n * @example\n * const select = DataModel.Operators.select;\n * usaCarsFn = select(fields => fields.Origin.value === 'USA');\n * usaCarsDm = usaCarsFn(dm);\n * console.log(usaCarsDm);\n *\n * @public\n * @namespace DataModel\n * @module Operators\n *\n * @param {SelectionPredicate} selectFn - Predicate funciton which is called for each row with the current row\n *      ```\n *          function (row, i)  { ... }\n *      ```\n * @param {Object} [config] - The configuration object to control the inclusion exclusion of a row in resultant\n *      DataModel instance\n * @param {FilteringMode} [config.mode=FilteringMode.NORMAL] - The mode of the selection\n *\n * @return {PreparatorFunction} Function which expects an instance of DataModel on which the operator needs to be\n *      applied.\n */\nexport const select = (...args) => dm => dm.select(...args);\n\n/**\n * This is functional version of projection operator. {@link link_to_projection | Projection} is a column filtering\n * operation.It expects list of fields name and either include those or exclude those based on {@link FilteringMode} on\n * the  resultant variable.It returns a function which is called with the DataModel instance on which the action needs\n * to be performed.\n *\n * Projection expects array of fields name based on which it creates the selection and rejection set. All the field\n * whose name is present in array goes in selection set and rest of the fields goes in rejection set.\n *\n * {@link FilteringMode} operates on the selection and rejection set to determine which one would reflect in the\n * resulatant datamodel.\n *\n * @warning\n * Selection and rejection set is only a logical idea for concept explanation purpose.\n *\n * @error\n * `FilteringMode.ALL` is not a valid working mode for functional version of `select`. Its only avialable on the\n * chained version.\n *\n * @public\n * @namespace DataModel\n * @module Operators\n *\n * @param {Array.<string | Regexp>} projField - An array of column names in string or regular expression.\n * @param {Object} [config] - An optional config to control the creation of new DataModel\n * @param {FilteringMode} [config.mode=FilteringMode.NORMAL] - Mode of the projection\n *\n * @return {PreparatorFunction} Function which expects an instance of DataModel on which the operator needs to be\n *      applied.\n */\nexport const project = (...args) => dm => dm.project(...args);\n\n/**\n * This is functional version of binnig operator. Binning happens on a measure field based on a binning configuration.\n * Binning in DataModel does not aggregate the number of rows present in DataModel instance after binning, it just adds\n * a new field with the binned value. Refer binning {@link example_of_binning | example} to have a intuition of what\n * binning is and the use case.\n *\n * Binning can be configured by\n * - providing custom bin configuration with non uniform buckets\n * - providing bin count\n * - providing each bin size\n *\n * When custom buckets are provided as part of binning configuration\n * @example\n *  // DataModel already prepared and assigned to dm vairable\n *  const buckets = {\n *      start: 30\n *      stops: [80, 100, 110]\n *  };\n *  const config = { buckets, name: 'binnedHP' }\n *  const binFn = bin('horsepower', config);\n *  const binnedDm = binFn(dm);\n *\n * @text\n * When `binCount` is defined as part of binning configuration\n * @example\n *  // DataModel already prepared and assigned to dm vairable\n *  const config = { binCount: 5, name: 'binnedHP' }\n *  const binFn = bin('horsepower', config);\n *  const binnedDm = binFn(Dm);\n *\n * @text\n * When `binSize` is defined as part of binning configuration\n * @example\n *  // DataModel already prepared and assigned to dm vairable\n *  const config = { binSize: 200, name: 'binnedHorsepower' }\n *  const binnedDm = dataModel.bin('horsepower', config);\n *  const binnedDm = binFn(Dm);\n *\n * @public\n * @namespace DataModel\n * @module Operators\n *\n * @param {String} name Name of measure which will be used to create bin\n * @param {Object} config Config required for bin creation\n * @param {Array.<Number>} config.bucketObj.stops Defination of bucket ranges. Two subsequent number from arrays\n *      are picked and a range is created. The first number from range is inclusive and the second number from range\n *      is exclusive.\n * @param {Number} [config.bucketObj.startAt] Force the start of the bin from a particular number.\n *      If not mentioned, the start of the bin or the lower domain of the data if stops is not mentioned, else its\n *      the first value of the stop.\n * @param {Number} config.binSize Bucket size for each bin\n * @param {Number} config.binCount Number of bins which will be created\n * @param {String} config.name Name of the new binned field to be created\n *\n * @return {PreparatorFunction} Function which expects an instance of DataModel on which the operator needs to be\n *      applied.\n */\nexport const bin = (...args) => dm => dm.bin(...args);\n\n/**\n * This is functional version of `groupBy` operator.Groups the data using particular dimensions and by reducing\n * measures. It expects a list of dimensions using which it projects the datamodel and perform aggregations to reduce\n * the duplicate tuples. Refer this {@link link_to_one_example_with_group_by | document} to know the intuition behind\n * groupBy.\n *\n * DataModel by default provides definition of few {@link reducer | Reducers}.\n * {@link ReducerStore | User defined reducers} can also be registered.\n *\n * This is the chained implementation of `groupBy`.\n * `groupBy` also supports {@link link_to_compose_groupBy | composability}\n *\n * @example\n * const groupBy = DataModel.Operators.groupBy;\n * const groupedFn = groupBy(['Year'], { horsepower: 'max' } );\n * groupedDM = groupByFn(dm);\n *\n * @public\n *\n * @param {Array.<string>} fieldsArr - Array containing the name of dimensions\n * @param {Object} [reducers={}] - A map whose key is the variable name and value is the name of the reducer. If its\n *      not passed, or any variable is ommitted from the object, default aggregation function is used from the\n *      schema of the variable.\n *\n * @return {PreparatorFunction} Function which expects an instance of DataModel on which the operator needs to be\n *      applied.\n */\nexport const groupBy = (...args) => dm => dm.groupBy(...args);\n\n/**\n * Enables composing operators to run multiple operations and save group of operataion as named opration on a DataModel.\n * The resulting DataModel will be the result of all the operation provided. The operations provided will be executed in\n * a serial manner ie. result of one operation will be the input for the next operations (like pipe operator in unix).\n *\n * Suported operations in compose are\n * - `select`\n * - `project`\n * - `groupBy`\n * - `bin`\n * - `compose`\n *\n * @example\n * const compose = DataModel.Operators.compose;\n * const select = DataModel.Operators.select;\n * const project = DataModel.Operators.project;\n *\n * let composedFn = compose(\n *    select(fields => fields.netprofit.value <= 15),\n *    project(['netprofit', 'netsales']));\n *\n * const dataModel = new DataModel(data1, schema1);\n *\n * let composedDm = composedFn(dataModel);\n *\n * @public\n * @namespace DataModel\n * @module Operators\n *\n * @param {Array.<Operators>} operators: An array of operation that will be applied on the\n * datatable.\n *\n * @returns {DataModel} Instance of resultant DataModel\n */\nexport const compose = (...operations) =>\n    (dm, config = { saveChild: true }) => {\n        let currentDM = dm;\n        let firstChild;\n        const derivations = [];\n\n        operations.forEach((operation) => {\n            currentDM = operation(currentDM);\n            derivations.push(...currentDM._derivation);\n            if (!firstChild) {\n                firstChild = currentDM;\n            }\n        });\n\n        if (firstChild && firstChild !== currentDM) {\n            firstChild.dispose();\n        }\n\n        // reset all ancestorDerivation saved in-between compose\n        currentDM._ancestorDerivation = [];\n        persistDerivations(\n            dm,\n            currentDM,\n            DM_DERIVATIVES.COMPOSE,\n            null,\n            derivations\n        );\n\n        if (config.saveChild) {\n            currentDM.setParent(dm);\n        } else {\n            currentDM.setParent(null);\n        }\n\n        return currentDM;\n    };\n","import DataModel from '../datamodel';\nimport { extend2 } from '../utils';\nimport { getCommonSchema } from './get-common-schema';\nimport { rowDiffsetIterator } from './row-diffset-iterator';\nimport { JOINS } from '../constants';\nimport { prepareJoinData } from '../helper';\n/**\n * Default filter function for crossProduct.\n *\n * @return {boolean} Always returns true.\n */\nfunction defaultFilterFn() { return true; }\n\n/**\n * Implementation of cross product operation between two DataModel instances.\n * It internally creates the data and schema for the new DataModel.\n *\n * @param {DataModel} dataModel1 - The left DataModel instance.\n * @param {DataModel} dataModel2 - The right DataModel instance.\n * @param {Function} filterFn - The filter function which is used to filter the tuples.\n * @param {boolean} [replaceCommonSchema=false] - The flag if the common name schema should be there.\n * @return {DataModel} Returns The newly created DataModel instance from the crossProduct operation.\n */\nexport function crossProduct (dm1, dm2, filterFn, replaceCommonSchema = false, jointype = JOINS.CROSS) {\n    const schema = [];\n    const data = [];\n    const applicableFilterFn = filterFn || defaultFilterFn;\n    const dm1FieldStore = dm1.getFieldspace();\n    const dm2FieldStore = dm2.getFieldspace();\n    const dm1FieldStoreName = dm1FieldStore.name;\n    const dm2FieldStoreName = dm2FieldStore.name;\n    const name = `${dm1FieldStore.name}.${dm2FieldStore.name}`;\n    const commonSchemaList = getCommonSchema(dm1FieldStore, dm2FieldStore);\n\n    if (dm1FieldStoreName === dm2FieldStoreName) {\n        throw new Error('DataModels must have different alias names');\n    }\n    // Here prepare the schema\n    dm1FieldStore.fields.forEach((field) => {\n        const tmpSchema = extend2({}, field.schema());\n        if (commonSchemaList.indexOf(tmpSchema.name) !== -1 && !replaceCommonSchema) {\n            tmpSchema.name = `${dm1FieldStore.name}.${tmpSchema.name}`;\n        }\n        schema.push(tmpSchema);\n    });\n    dm2FieldStore.fields.forEach((field) => {\n        const tmpSchema = extend2({}, field.schema());\n        if (commonSchemaList.indexOf(tmpSchema.name) !== -1) {\n            if (!replaceCommonSchema) {\n                tmpSchema.name = `${dm2FieldStore.name}.${tmpSchema.name}`;\n                schema.push(tmpSchema);\n            }\n        } else {\n            schema.push(tmpSchema);\n        }\n    });\n\n    // Here prepare Data\n    rowDiffsetIterator(dm1._rowDiffset, (i) => {\n        let rowAdded = false;\n        let rowPosition;\n        rowDiffsetIterator(dm2._rowDiffset, (ii) => {\n            const tuple = [];\n            const userArg = {};\n            userArg[dm1FieldStoreName] = {};\n            userArg[dm2FieldStoreName] = {};\n            dm1FieldStore.fields.forEach((field) => {\n                tuple.push(field.partialField.data[i]);\n                userArg[dm1FieldStoreName][field.name()] = {\n                    rawValue: field.partialField.data[i],\n                    formattedValue: field.formattedData()[i],\n                };\n            });\n            dm2FieldStore.fields.forEach((field) => {\n                if (!(commonSchemaList.indexOf(field.schema().name) !== -1 && replaceCommonSchema)) {\n                    tuple.push(field.partialField.data[ii]);\n                }\n                userArg[dm2FieldStoreName][field.name()] = {\n                    rawValue: field.partialField.data[ii],\n                    formattedValue: field.formattedData()[ii],\n                };\n            });\n\n            let cachedStore = {};\n            let cloneProvider1 = () => dm1.detachedRoot();\n            let cloneProvider2 = () => dm2.detachedRoot();\n\n            const dm1Fields = prepareJoinData(userArg[dm1FieldStoreName]);\n            const dm2Fields = prepareJoinData(userArg[dm2FieldStoreName]);\n            if (applicableFilterFn(dm1Fields, dm2Fields, cloneProvider1, cloneProvider2, cachedStore)) {\n                const tupleObj = {};\n                tuple.forEach((cellVal, iii) => {\n                    tupleObj[schema[iii].name] = cellVal;\n                });\n                if (rowAdded && JOINS.CROSS !== jointype) {\n                    data[rowPosition] = tupleObj;\n                }\n                else {\n                    data.push(tupleObj);\n                    rowAdded = true;\n                    rowPosition = i;\n                }\n            } else if ((jointype === JOINS.LEFTOUTER || jointype === JOINS.RIGHTOUTER) && !rowAdded) {\n                const tupleObj = {};\n                let len = dm1FieldStore.fields.length - 1;\n                tuple.forEach((cellVal, iii) => {\n                    if (iii <= len) {\n                        tupleObj[schema[iii].name] = cellVal;\n                    }\n                    else {\n                        tupleObj[schema[iii].name] = null;\n                    }\n                });\n                rowAdded = true;\n                rowPosition = i;\n                data.push(tupleObj);\n            }\n        });\n    });\n\n    return new DataModel(data, schema, { name });\n}\n","import { rowDiffsetIterator } from './row-diffset-iterator';\nimport { sortData } from './sort';\nimport { FieldType } from '../enums';\nimport { ROW_ID } from '../constants';\n\n/**\n * Builds the actual data array.\n *\n * @param {Array} fieldStore - An array of field.\n * @param {string} rowDiffset - A string consisting of which rows to be included eg. '0-2,4,6';\n * @param {string} colIdentifier - A string consisting of the details of which column\n * to be included eg 'date,sales,profit';\n * @param {Object} sortingDetails - An object containing the sorting details of the DataModel instance.\n * @param {Object} options - The options required to create the type of the data.\n * @return {Object} Returns an object containing the multidimensional array and the relative schema.\n */\nexport function dataBuilder (fieldStore, rowDiffset, colIdentifier, sortingDetails, options) {\n    const defOptions = {\n        addUid: false,\n        columnWise: false\n    };\n    options = Object.assign({}, defOptions, options);\n\n    const retObj = {\n        schema: [],\n        data: [],\n        uids: []\n    };\n    const addUid = options.addUid;\n    const reqSorting = sortingDetails && sortingDetails.length > 0;\n    // It stores the fields according to the colIdentifier argument\n    const tmpDataArr = [];\n    // Stores the fields according to the colIdentifier argument\n    const colIArr = colIdentifier.split(',');\n\n    colIArr.forEach((colName) => {\n        for (let i = 0; i < fieldStore.length; i += 1) {\n            if (fieldStore[i].name() === colName) {\n                tmpDataArr.push(fieldStore[i]);\n                break;\n            }\n        }\n    });\n\n    // Inserts the schema to the schema object\n    tmpDataArr.forEach((field) => {\n        /** @todo Need to use extend2 here otherwise user can overwrite the schema. */\n        retObj.schema.push(field.schema());\n    });\n\n    if (addUid) {\n        retObj.schema.push({\n            name: ROW_ID,\n            type: FieldType.DIMENSION\n        });\n    }\n\n    rowDiffsetIterator(rowDiffset, (i) => {\n        retObj.data.push([]);\n        const insertInd = retObj.data.length - 1;\n        let start = 0;\n        tmpDataArr.forEach((field, ii) => {\n            retObj.data[insertInd][ii + start] = field.partialField.data[i];\n        });\n        if (addUid) {\n            retObj.data[insertInd][tmpDataArr.length] = i;\n        }\n        // Creates an array of unique identifiers for each row\n        retObj.uids.push(i);\n\n        // If sorting needed then there is the need to expose the index\n        // mapping from the old index to its new index\n        if (reqSorting) { retObj.data[insertInd].push(i); }\n    });\n\n    // Handles the sort functionality\n    if (reqSorting) {\n        sortData(retObj, sortingDetails);\n    }\n\n    if (options.columnWise) {\n        const tmpData = Array(...Array(retObj.schema.length)).map(() => []);\n        retObj.data.forEach((tuple) => {\n            tuple.forEach((data, i) => {\n                tmpData[i].push(data);\n            });\n        });\n        retObj.data = tmpData;\n    }\n\n    return retObj;\n}\n","import DataModel from '../datamodel';\nimport { extend2 } from '../utils';\nimport { rowDiffsetIterator } from './row-diffset-iterator';\nimport { isArrEqual } from '../utils/helper';\n\n/**\n * Performs the union operation between two dm instances.\n *\n * @todo Fix the conflicts between union and difference terminology here.\n *\n * @param {dm} dm1 - The first dm instance.\n * @param {dm} dm2 - The second dm instance.\n * @return {dm} Returns the newly created dm after union operation.\n */\nexport function difference (dm1, dm2) {\n    const hashTable = {};\n    const schema = [];\n    const schemaNameArr = [];\n    const data = [];\n    const dm1FieldStore = dm1.getFieldspace();\n    const dm2FieldStore = dm2.getFieldspace();\n    const dm1FieldStoreFieldObj = dm1FieldStore.fieldsObj();\n    const dm2FieldStoreFieldObj = dm2FieldStore.fieldsObj();\n    const name = `${dm1FieldStore.name} union ${dm2FieldStore.name}`;\n\n   // For union the columns should match otherwise return a clone of the dm1\n    if (!isArrEqual(dm1._colIdentifier.split(',').sort(), dm2._colIdentifier.split(',').sort())) {\n        return null;\n    }\n\n    // Prepare the schema\n    (dm1._colIdentifier.split(',')).forEach((fieldName) => {\n        const field = dm1FieldStoreFieldObj[fieldName];\n        schema.push(extend2({}, field.schema()));\n        schemaNameArr.push(field.schema().name);\n    });\n\n    /**\n     * The helper function to create the data.\n     *\n     * @param {dm} dm - The dm instance for which the data is inserted.\n     * @param {Object} fieldsObj - The fieldStore object format.\n     * @param {boolean} addData - If true only tuple will be added to the data.\n     */\n    function prepareDataHelper(dm, fieldsObj, addData) {\n        rowDiffsetIterator(dm._rowDiffset, (i) => {\n            const tuple = {};\n            let hashData = '';\n            schemaNameArr.forEach((schemaName) => {\n                const value = fieldsObj[schemaName].partialField.data[i];\n                hashData += `-${value}`;\n                tuple[schemaName] = value;\n            });\n            if (!hashTable[hashData]) {\n                if (addData) { data.push(tuple); }\n                hashTable[hashData] = true;\n            }\n        });\n    }\n\n    // Prepare the data\n    prepareDataHelper(dm2, dm2FieldStoreFieldObj, false);\n    prepareDataHelper(dm1, dm1FieldStoreFieldObj, true);\n\n    return new DataModel(data, schema, { name });\n}\n\n","/**\n * The helper function that returns an array of common schema\n * from two fieldStore instances.\n *\n * @param {FieldStore} fs1 - The first FieldStore instance.\n * @param {FieldStore} fs2 - The second FieldStore instance.\n * @return {Array} An array containing the common schema.\n */\nexport function getCommonSchema (fs1, fs2) {\n    const retArr = [];\n    const fs1Arr = [];\n    fs1.fields.forEach((field) => {\n        fs1Arr.push(field.schema().name);\n    });\n    fs2.fields.forEach((field) => {\n        if (fs1Arr.indexOf(field.schema().name) !== -1) {\n            retArr.push(field.schema().name);\n        }\n    });\n    return retArr;\n}\n","import { isArray } from '../utils';\nimport InvalidAwareTypes from '../invalid-aware-types';\nimport { GROUP_BY_FUNCTIONS } from '../enums';\n\nconst { SUM, AVG, FIRST, LAST, COUNT, STD, MIN, MAX } = GROUP_BY_FUNCTIONS;\n\nfunction getFilteredValues(arr) {\n    return arr.filter(item => !(item instanceof InvalidAwareTypes));\n}\n/**\n * Reducer function that returns the sum of all the values.\n *\n * @public\n * @param  {Array.<number>} arr - The input array.\n * @return {number} Returns the sum of the array.\n */\nfunction sum (arr) {\n    if (isArray(arr) && !(arr[0] instanceof Array)) {\n        const filteredNumber = getFilteredValues(arr);\n        const totalSum = filteredNumber.length ?\n                            filteredNumber.reduce((acc, curr) => acc + curr, 0)\n                            : InvalidAwareTypes.NULL;\n        return totalSum;\n    }\n    return InvalidAwareTypes.NULL;\n}\n\n/**\n * Reducer function that returns the average of all the values.\n *\n * @public\n * @param  {Array.<number>} arr - The input array.\n * @return {number} Returns the mean value of the array.\n */\nfunction avg (arr) {\n    if (isArray(arr) && !(arr[0] instanceof Array)) {\n        const totalSum = sum(arr);\n        const len = arr.length || 1;\n        return (Number.isNaN(totalSum) || totalSum instanceof InvalidAwareTypes) ?\n                 InvalidAwareTypes.NULL : totalSum / len;\n    }\n    return InvalidAwareTypes.NULL;\n}\n\n/**\n * Reducer function that gives the min value amongst all the values.\n *\n * @public\n * @param  {Array.<number>} arr - The input array.\n * @return {number} Returns the minimum value of the array.\n */\nfunction min (arr) {\n    if (isArray(arr) && !(arr[0] instanceof Array)) {\n        // Filter out undefined, null and NaN values\n        const filteredValues = getFilteredValues(arr);\n\n        return (filteredValues.length) ? Math.min(...filteredValues) : InvalidAwareTypes.NULL;\n    }\n    return InvalidAwareTypes.NULL;\n}\n\n/**\n * Reducer function that gives the max value amongst all the values.\n *\n * @public\n * @param  {Array.<number>} arr - The input array.\n * @return {number} Returns the maximum value of the array.\n */\nfunction max (arr) {\n    if (isArray(arr) && !(arr[0] instanceof Array)) {\n        // Filter out undefined, null and NaN values\n        const filteredValues = getFilteredValues(arr);\n\n        return (filteredValues.length) ? Math.max(...filteredValues) : InvalidAwareTypes.NULL;\n    }\n    return InvalidAwareTypes.NULL;\n}\n\n/**\n * Reducer function that gives the first value of the array.\n *\n * @public\n * @param  {Array} arr - The input array.\n * @return {number} Returns the first value of the array.\n */\nfunction first (arr) {\n    return arr[0];\n}\n\n/**\n * Reducer function that gives the last value of the array.\n *\n * @public\n * @param  {Array} arr - The input array.\n * @return {number} Returns the last value of the array.\n */\nfunction last (arr) {\n    return arr[arr.length - 1];\n}\n\n/**\n * Reducer function that gives the count value of the array.\n *\n * @public\n * @param  {Array} arr - The input array.\n * @return {number} Returns the length of the array.\n */\nfunction count (arr) {\n    if (isArray(arr)) {\n        return arr.length;\n    }\n    return InvalidAwareTypes.NULL;\n}\n\n/**\n * Calculates the variance of the input array.\n *\n * @param  {Array.<number>} arr - The input array.\n * @return {number} Returns the variance of the input array.\n */\nfunction variance (arr) {\n    let mean = avg(arr);\n    return avg(arr.map(num => (num - mean) ** 2));\n}\n\n/**\n * Calculates the square root of the variance of the input array.\n *\n * @public\n * @param  {Array.<number>} arr - The input array.\n * @return {number} Returns the square root of the variance.\n */\nfunction std (arr) {\n    return Math.sqrt(variance(arr));\n}\n\n\nconst fnList = {\n    [SUM]: sum,\n    [AVG]: avg,\n    [MIN]: min,\n    [MAX]: max,\n    [FIRST]: first,\n    [LAST]: last,\n    [COUNT]: count,\n    [STD]: std\n};\n\nconst defaultReducerName = SUM;\n\nexport {\n    defaultReducerName,\n    sum as defReducer,\n    fnList,\n};\n","import { extend2 } from '../utils';\nimport { rowDiffsetIterator } from './row-diffset-iterator';\nimport DataModel from '../export';\nimport reducerStore from '../utils/reducer-store';\nimport { defaultReducerName } from './group-by-function';\nimport { FieldType } from '../enums';\n\n/**\n * This function sanitize the user given field and return a common Array structure field\n * list\n * @param  {DataModel} dataModel the dataModel operating on\n * @param  {Array} fieldArr  user input of field Array\n * @return {Array}           arrays of field name\n */\nfunction getFieldArr (dataModel, fieldArr) {\n    const retArr = [];\n    const fieldStore = dataModel.getFieldspace();\n    const dimensions = fieldStore.getDimension();\n\n    Object.entries(dimensions).forEach(([key]) => {\n        if (fieldArr && fieldArr.length) {\n            if (fieldArr.indexOf(key) !== -1) {\n                retArr.push(key);\n            }\n        } else {\n            retArr.push(key);\n        }\n    });\n\n    return retArr;\n}\n\n/**\n * This sanitize the reducer provide by the user and create a common type of object.\n * user can give function Also\n * @param  {DataModel} dataModel     dataModel to worked on\n * @param  {Object|function} [reducers={}] reducer provided by the users\n * @return {Object}               object containing reducer function for every measure\n */\nfunction getReducerObj (dataModel, reducers = {}) {\n    const retObj = {};\n    const fieldStore = dataModel.getFieldspace();\n    const measures = fieldStore.getMeasure();\n    const defReducer = reducerStore.defaultReducer();\n\n    Object.keys(measures).forEach((measureName) => {\n        if (typeof reducers[measureName] !== 'string') {\n            reducers[measureName] = measures[measureName].defAggFn();\n        }\n        const reducerFn = reducerStore.resolve(reducers[measureName]);\n        if (reducerFn) {\n            retObj[measureName] = reducerFn;\n        } else {\n            retObj[measureName] = defReducer;\n            reducers[measureName] = defaultReducerName;\n        }\n    });\n    return retObj;\n}\n\n/**\n * main function which perform the group-by operations which reduce the measures value is the\n * fields are common according to the reducer function provided\n * @param  {DataModel} dataModel the dataModel to worked\n * @param  {Array} fieldArr  fields according to which the groupby should be worked\n * @param  {Object|Function} reducers  reducers function\n * @param {DataModel} existingDataModel Existing datamodel instance\n * @return {DataModel} new dataModel with the group by\n */\nfunction groupBy (dataModel, fieldArr, reducers, existingDataModel) {\n    const sFieldArr = getFieldArr(dataModel, fieldArr);\n    const reducerObj = getReducerObj(dataModel, reducers);\n    const fieldStore = dataModel.getFieldspace();\n    const fieldStoreObj = fieldStore.fieldsObj();\n    const dbName = fieldStore.name;\n    const dimensionArr = [];\n    const measureArr = [];\n    const schema = [];\n    const hashMap = {};\n    const data = [];\n    let newDataModel;\n\n    // Prepare the schema\n    Object.entries(fieldStoreObj).forEach(([key, value]) => {\n        if (sFieldArr.indexOf(key) !== -1 || reducerObj[key]) {\n            schema.push(extend2({}, value.schema()));\n\n            switch (value.schema().type) {\n            case FieldType.MEASURE:\n                measureArr.push(key);\n                break;\n            default:\n            case FieldType.DIMENSION:\n                dimensionArr.push(key);\n            }\n        }\n    });\n    // Prepare the data\n    let rowCount = 0;\n    rowDiffsetIterator(dataModel._rowDiffset, (i) => {\n        let hash = '';\n        dimensionArr.forEach((_) => {\n            hash = `${hash}-${fieldStoreObj[_].partialField.data[i]}`;\n        });\n        if (hashMap[hash] === undefined) {\n            hashMap[hash] = rowCount;\n            data.push({});\n            dimensionArr.forEach((_) => {\n                data[rowCount][_] = fieldStoreObj[_].partialField.data[i];\n            });\n            measureArr.forEach((_) => {\n                data[rowCount][_] = [fieldStoreObj[_].partialField.data[i]];\n            });\n            rowCount += 1;\n        } else {\n            measureArr.forEach((_) => {\n                data[hashMap[hash]][_].push(fieldStoreObj[_].partialField.data[i]);\n            });\n        }\n    });\n\n    // reduction\n    let cachedStore = {};\n    let cloneProvider = () => dataModel.detachedRoot();\n    data.forEach((row) => {\n        const tuple = row;\n        measureArr.forEach((_) => {\n            tuple[_] = reducerObj[_](row[_], cloneProvider, cachedStore);\n        });\n    });\n    if (existingDataModel) {\n        existingDataModel.__calculateFieldspace();\n        newDataModel = existingDataModel;\n    }\n    else {\n        newDataModel = new DataModel(data, schema, { name: dbName });\n    }\n    return newDataModel;\n}\n\nexport { groupBy, getFieldArr, getReducerObj };\n","export { createBinnedFieldData } from './bucket-creator';\nexport { compose, bin, select, project, groupBy as groupby } from './compose';\nexport { calculateVariable, sort } from './pure-operators';\nexport { crossProduct } from './cross-product';\nexport { dataBuilder } from './data-builder';\nexport { difference } from './difference';\nexport { getCommonSchema } from './get-common-schema';\nexport { defReducer, fnList } from './group-by-function';\nexport { groupBy, getFieldArr, getReducerObj } from './group-by';\nexport { mergeSort } from './merge-sort';\nexport { naturalJoinFilter } from './natural-join-filter-function';\nexport { naturalJoin } from './natural-join';\nexport { leftOuterJoin, rightOuterJoin, fullOuterJoin } from './outer-join';\nexport { rowDiffsetIterator } from './row-diffset-iterator';\nexport { union } from './union';\n","/**\n * The default sort function.\n *\n * @param {*} a - The first value.\n * @param {*} b - The second value.\n * @return {number} Returns the comparison result e.g. 1 or 0 or -1.\n */\nfunction defSortFn (a, b) {\n    const a1 = `${a}`;\n    const b1 = `${b}`;\n    if (a1 < b1) {\n        return -1;\n    }\n    if (a1 > b1) {\n        return 1;\n    }\n    return 0;\n}\n\n/**\n * The helper function for merge sort which creates the sorted array\n * from the two halves of the input array.\n *\n * @param {Array} arr - The target array which needs to be merged.\n * @param {number} lo - The starting index of the first array half.\n * @param {number} mid - The ending index of the first array half.\n * @param {number} hi - The ending index of the second array half.\n * @param {Function} sortFn - The sort function.\n */\nfunction merge (arr, lo, mid, hi, sortFn) {\n    const mainArr = arr;\n    const auxArr = [];\n    for (let i = lo; i <= hi; i += 1) {\n        auxArr[i] = mainArr[i];\n    }\n    let a = lo;\n    let b = mid + 1;\n\n    for (let i = lo; i <= hi; i += 1) {\n        if (a > mid) {\n            mainArr[i] = auxArr[b];\n            b += 1;\n        } else if (b > hi) {\n            mainArr[i] = auxArr[a];\n            a += 1;\n        } else if (sortFn(auxArr[a], auxArr[b]) <= 0) {\n            mainArr[i] = auxArr[a];\n            a += 1;\n        } else {\n            mainArr[i] = auxArr[b];\n            b += 1;\n        }\n    }\n}\n\n/**\n * The helper function for merge sort which would be called\n * recursively for sorting the array halves.\n *\n * @param {Array} arr - The target array which needs to be sorted.\n * @param {number} lo - The starting index of the array half.\n * @param {number} hi - The ending index of the array half.\n * @param {Function} sortFn - The sort function.\n * @return {Array} Returns the target array itself.\n */\nfunction sort (arr, lo, hi, sortFn) {\n    if (hi === lo) { return arr; }\n\n    const mid = lo + Math.floor((hi - lo) / 2);\n    sort(arr, lo, mid, sortFn);\n    sort(arr, mid + 1, hi, sortFn);\n    merge(arr, lo, mid, hi, sortFn);\n\n    return arr;\n}\n\n/**\n * The implementation of merge sort.\n * It is used in DataModel for stable sorting as it is not sure\n * what the sorting algorithm used by browsers is stable or not.\n *\n * @param {Array} arr - The target array which needs to be sorted.\n * @param {Function} [sortFn=defSortFn] - The sort function.\n * @return {Array} Returns the input array itself in sorted order.\n */\nexport function mergeSort (arr, sortFn = defSortFn) {\n    if (arr.length > 1) {\n        sort(arr, 0, arr.length - 1, sortFn);\n    }\n    return arr;\n}\n","import { getCommonSchema } from './get-common-schema';\n\n/**\n * The filter function used in natural join.\n * It generates a function that will have the logic to join two\n * DataModel instances by the process of natural join.\n *\n * @param {DataModel} dm1 - The left DataModel instance.\n * @param {DataModel} dm2 - The right DataModel instance.\n * @return {Function} Returns a function that is used in cross-product operation.\n */\nexport function naturalJoinFilter (dm1, dm2) {\n    const dm1FieldStore = dm1.getFieldspace();\n    const dm2FieldStore = dm2.getFieldspace();\n    // const dm1FieldStoreName = dm1FieldStore.name;\n    // const dm2FieldStoreName = dm2FieldStore.name;\n    const commonSchemaArr = getCommonSchema(dm1FieldStore, dm2FieldStore);\n\n    return (dm1Fields, dm2Fields) => {\n        let retainTuple = true;\n        commonSchemaArr.forEach((fieldName) => {\n            if (dm1Fields[fieldName].internalValue ===\n                dm2Fields[fieldName].internalValue && retainTuple) {\n                retainTuple = true;\n            } else {\n                retainTuple = false;\n            }\n        });\n        return retainTuple;\n    };\n}\n","import { crossProduct } from './cross-product';\nimport { naturalJoinFilter } from './natural-join-filter-function';\n\nexport function naturalJoin (dataModel1, dataModel2) {\n    return crossProduct(dataModel1, dataModel2, naturalJoinFilter(dataModel1, dataModel2), true);\n}\n","import { crossProduct } from './cross-product';\nimport { JOINS } from '../constants';\nimport { union } from './union';\n\n\nexport function leftOuterJoin (dataModel1, dataModel2, filterFn) {\n    return crossProduct(dataModel1, dataModel2, filterFn, false, JOINS.LEFTOUTER);\n}\n\nexport function rightOuterJoin (dataModel1, dataModel2, filterFn) {\n    return crossProduct(dataModel2, dataModel1, filterFn, false, JOINS.RIGHTOUTER);\n}\n\nexport function fullOuterJoin (dataModel1, dataModel2, filterFn) {\n    return union(leftOuterJoin(dataModel1, dataModel2, filterFn), rightOuterJoin(dataModel1, dataModel2, filterFn));\n}\n","/**\n * Wrapper on calculateVariable() method of DataModel to behave\n * the pure-function functionality.\n *\n * @param {Array} args - The argument list.\n * @return {any} Returns the returned value of calling function.\n */\nexport const calculateVariable = (...args) => dm => dm.calculateVariable(...args);\n\n/**\n * Wrapper on sort() method of DataModel to behave\n * the pure-function functionality.\n *\n * @param {Array} args - The argument list.\n * @return {any} Returns the returned value of calling function.\n */\nexport const sort = (...args) => dm => dm.sort(...args);\n","/**\n * Iterates through the diffSet array and call the callback with the current\n * index.\n *\n * @param {string} rowDiffset - The row diffset string e.g. '0-4,6,10-13'.\n * @param {Function} callback - The callback function to be called with every index.\n */\nexport function rowDiffsetIterator (rowDiffset, callback) {\n    if (rowDiffset.length > 0) {\n        const rowDiffArr = rowDiffset.split(',');\n        rowDiffArr.forEach((diffStr) => {\n            const diffStsArr = diffStr.split('-');\n            const start = +(diffStsArr[0]);\n            const end = +(diffStsArr[1] || diffStsArr[0]);\n            if (end >= start) {\n                for (let i = start; i <= end; i += 1) {\n                    callback(i);\n                }\n            }\n        });\n    }\n}\n","import { DimensionSubtype, MeasureSubtype } from '../enums';\nimport { mergeSort } from './merge-sort';\nimport { fieldInSchema } from '../helper';\nimport { isCallable, isArray } from '../utils';\n\n/**\n * Generates the sorting functions to sort the data of a DataModel instance\n * according to the input data type.\n *\n * @param {string} dataType - The data type e.g. 'measure', 'datetime' etc.\n * @param {string} sortType - The sorting order i.e. 'asc' or 'desc'.\n * @return {Function} Returns the the sorting function.\n */\nfunction getSortFn (dataType, sortType) {\n    let retFunc;\n\n    switch (dataType) {\n    case MeasureSubtype.CONTINUOUS:\n    case DimensionSubtype.TEMPORAL:\n        if (sortType === 'asc') {\n            retFunc = (a, b) => a - b;\n        } else {\n            retFunc = (a, b) => b - a;\n        }\n        break;\n    default:\n        if (sortType === 'asc') {\n            retFunc = (a, b) => {\n                a = `${a}`;\n                b = `${b}`;\n                if (a === b) {\n                    return 0;\n                }\n                return a > b ? 1 : -1;\n            };\n        } else {\n            retFunc = (a, b) => {\n                a = `${a}`;\n                b = `${b}`;\n                if (a === b) {\n                    return 0;\n                }\n                return a > b ? -1 : 1;\n            };\n        }\n    }\n\n    return retFunc;\n}\n\n/**\n * Resolves the actual sorting function based on sorting string value.\n *\n * @param {Object} fDetails - The target field info.\n * @param {string} strSortOrder - The sort order value.\n * @return {Function} Returns the sorting function.\n */\nfunction resolveStrSortOrder (fDetails, strSortOrder) {\n    const sortOrder = String(strSortOrder).toLowerCase() === 'desc' ? 'desc' : 'asc';\n    return getSortFn(fDetails.type, sortOrder);\n}\n\n/**\n * Groups the data according to the specified target field.\n *\n * @param {Array} data - The input data array.\n * @param {number} fieldIndex - The target field index within schema array.\n * @return {Array} Returns an array containing the grouped data.\n */\nfunction groupData (data, fieldIndex) {\n    const hashMap = new Map();\n    const groupedData = [];\n\n    data.forEach((datum) => {\n        const fieldVal = datum[fieldIndex];\n        if (hashMap.has(fieldVal)) {\n            groupedData[hashMap.get(fieldVal)][1].push(datum);\n        } else {\n            groupedData.push([fieldVal, [datum]]);\n            hashMap.set(fieldVal, groupedData.length - 1);\n        }\n    });\n\n    return groupedData;\n}\n\n/**\n * Creates the argument value used for sorting function when sort is done\n * with another fields.\n *\n * @param {Array} groupedDatum - The grouped datum for a single dimension field value.\n * @param {Array} targetFields - An array of the sorting fields.\n * @param {Array} targetFieldDetails - An array of the sorting field details in schema.\n * @return {Object} Returns an object containing the value of sorting fields and the target field name.\n */\nfunction createSortingFnArg (groupedDatum, targetFields, targetFieldDetails) {\n    const arg = {\n        label: groupedDatum[0]\n    };\n\n    targetFields.reduce((acc, next, idx) => {\n        acc[next] = groupedDatum[1].map(datum => datum[targetFieldDetails[idx].index]);\n        return acc;\n    }, arg);\n\n    return arg;\n}\n\n/**\n * Sorts the data by applying the standard sorting mechanism.\n *\n * @param {Array} data - The input data array.\n * @param {Array} schema - The data schema.\n * @param {Array} sortingDetails - An array containing the sorting configs.\n */\nfunction applyStandardSort (data, schema, sortingDetails) {\n    let fieldName;\n    let sortMeta;\n    let fDetails;\n    let i = sortingDetails.length - 1;\n\n    for (; i >= 0; i--) {\n        fieldName = sortingDetails[i][0];\n        sortMeta = sortingDetails[i][1];\n        fDetails = fieldInSchema(schema, fieldName);\n\n        if (!fDetails) {\n            // eslint-disable-next-line no-continue\n            continue;\n        }\n\n        if (isCallable(sortMeta)) {\n            // eslint-disable-next-line no-loop-func\n            mergeSort(data, (a, b) => sortMeta(a[fDetails.index], b[fDetails.index]));\n        } else if (isArray(sortMeta)) {\n            const groupedData = groupData(data, fDetails.index);\n            const sortingFn = sortMeta[sortMeta.length - 1];\n            const targetFields = sortMeta.slice(0, sortMeta.length - 1);\n            const targetFieldDetails = targetFields.map(f => fieldInSchema(schema, f));\n\n            groupedData.forEach((groupedDatum) => {\n                groupedDatum.push(createSortingFnArg(groupedDatum, targetFields, targetFieldDetails));\n            });\n\n            mergeSort(groupedData, (a, b) => {\n                const m = a[2];\n                const n = b[2];\n                return sortingFn(m, n);\n            });\n\n            // Empty the array\n            data.length = 0;\n            groupedData.forEach((datum) => {\n                data.push(...datum[1]);\n            });\n        } else {\n            const sortFn = resolveStrSortOrder(fDetails, sortMeta);\n            // eslint-disable-next-line no-loop-func\n            mergeSort(data, (a, b) => sortFn(a[fDetails.index], b[fDetails.index]));\n        }\n    }\n}\n\n/**\n * Creates a map based on grouping.\n *\n * @param {Array} depColumns - The dependency columns' info.\n * @param {Array} data - The input data.\n * @param {Array} schema - The data schema.\n * @param {Array} sortingDetails - The sorting details for standard sorting.\n * @return {Map} Returns a map.\n */\nconst makeGroupMapAndSort = (depColumns, data, schema, sortingDetails) => {\n    if (depColumns.length === 0) { return data; }\n\n    const targetCol = depColumns[0];\n    const map = new Map();\n\n    data.reduce((acc, currRow) => {\n        const fVal = currRow[targetCol.index];\n        if (acc.has(fVal)) {\n            acc.get(fVal).push(currRow);\n        } else {\n            acc.set(fVal, [currRow]);\n        }\n        return acc;\n    }, map);\n\n    for (let [key, val] of map) {\n        const nMap = makeGroupMapAndSort(depColumns.slice(1), val, schema, sortingDetails);\n        map.set(key, nMap);\n        if (Array.isArray(nMap)) {\n            applyStandardSort(nMap, schema, sortingDetails);\n        }\n    }\n\n    return map;\n};\n\n/**\n * Sorts the data by retaining the position/order of a particular field.\n *\n * @param {Array} data - The input data array.\n * @param {Array} schema - The data schema.\n * @param {Array} sortingDetails - An array containing the sorting configs.\n * @param {Array} depColumns - The dependency column list.\n * @return {Array} Returns the sorted data.\n */\nfunction applyGroupSort (data, schema, sortingDetails, depColumns) {\n    sortingDetails = sortingDetails.filter((detail) => {\n        if (detail[1] === null) {\n            depColumns.push(detail[0]);\n            return false;\n        }\n        return true;\n    });\n    if (sortingDetails.length === 0) { return data; }\n\n    depColumns = depColumns.map(c => fieldInSchema(schema, c));\n\n    const sortedGroupMap = makeGroupMapAndSort(depColumns, data, schema, sortingDetails);\n    return data.map((row) => {\n        let i = 0;\n        let nextMap = sortedGroupMap;\n\n        while (!Array.isArray(nextMap)) {\n            nextMap = nextMap.get(row[depColumns[i++].index]);\n        }\n\n        return nextMap.shift();\n    });\n}\n\n/**\n * Sorts the data.\n *\n * @param {Object} dataObj - An object containing the data and schema.\n * @param {Array} sortingDetails - An array containing the sorting configs.\n */\nexport function sortData (dataObj, sortingDetails) {\n    let { schema, data } = dataObj;\n\n    sortingDetails = sortingDetails.filter(sDetial => !!fieldInSchema(schema, sDetial[0]));\n    if (sortingDetails.length === 0) { return; }\n\n    let groupSortingIdx = sortingDetails.findIndex(sDetial => sDetial[1] === null);\n    groupSortingIdx = groupSortingIdx !== -1 ? groupSortingIdx : sortingDetails.length;\n\n    const standardSortingDetails = sortingDetails.slice(0, groupSortingIdx);\n    const groupSortingDetails = sortingDetails.slice(groupSortingIdx);\n\n    applyStandardSort(data, schema, standardSortingDetails);\n    data = applyGroupSort(data, schema, groupSortingDetails, standardSortingDetails.map(detail => detail[0]));\n\n    dataObj.uids = data.map(row => row.pop());\n    dataObj.data = data;\n}\n","import DataModel from '../export';\nimport { extend2 } from '../utils';\nimport { rowDiffsetIterator } from './row-diffset-iterator';\nimport { isArrEqual } from '../utils/helper';\n/**\n * Performs the union operation between two dm instances.\n *\n * @param {dm} dm1 - The first dm instance.\n * @param {dm} dm2 - The second dm instance.\n * @return {dm} Returns the newly created dm after union operation.\n */\nexport function union (dm1, dm2) {\n    const hashTable = {};\n    const schema = [];\n    const schemaNameArr = [];\n    const data = [];\n    const dm1FieldStore = dm1.getFieldspace();\n    const dm2FieldStore = dm2.getFieldspace();\n    const dm1FieldStoreFieldObj = dm1FieldStore.fieldsObj();\n    const dm2FieldStoreFieldObj = dm2FieldStore.fieldsObj();\n    const name = `${dm1FieldStore.name} union ${dm2FieldStore.name}`;\n\n    // For union the columns should match otherwise return a clone of the dm1\n    if (!isArrEqual(dm1._colIdentifier.split(',').sort(), dm2._colIdentifier.split(',').sort())) {\n        return null;\n    }\n\n    // Prepare the schema\n    (dm1._colIdentifier.split(',')).forEach((fieldName) => {\n        const field = dm1FieldStoreFieldObj[fieldName];\n        schema.push(extend2({}, field.schema()));\n        schemaNameArr.push(field.schema().name);\n    });\n\n    /**\n     * The helper function to create the data.\n     *\n     * @param {dm} dm - The dm instance for which the data is inserted.\n     * @param {Object} fieldsObj - The fieldStore object format.\n     */\n    function prepareDataHelper (dm, fieldsObj) {\n        rowDiffsetIterator(dm._rowDiffset, (i) => {\n            const tuple = {};\n            let hashData = '';\n            schemaNameArr.forEach((schemaName) => {\n                const value = fieldsObj[schemaName].partialField.data[i];\n                hashData += `-${value}`;\n                tuple[schemaName] = value;\n            });\n            if (!hashTable[hashData]) {\n                data.push(tuple);\n                hashTable[hashData] = true;\n            }\n        });\n    }\n\n    // Prepare the data\n    prepareDataHelper(dm1, dm1FieldStoreFieldObj);\n    prepareDataHelper(dm2, dm2FieldStoreFieldObj);\n\n    return new DataModel(data, schema, { name });\n}\n","import { FilteringMode } from './enums';\nimport { getUniqueId } from './utils';\nimport {\n    updateFields,\n    cloneWithSelect,\n    cloneWithProject,\n    updateData,\n    getNormalizedProFields\n} from './helper';\nimport { crossProduct, difference, naturalJoinFilter, union } from './operator';\n\n/**\n * Relation provides the definitions of basic operators of relational algebra like *selection*, *projection*, *union*,\n * *difference* etc.\n *\n * It is extended by {@link DataModel} to inherit the functionalities of relational algebra concept.\n *\n * @class\n * @public\n * @module Relation\n * @namespace DataModel\n */\nclass Relation {\n\n    /**\n     * Creates a new Relation instance by providing underlying data and schema.\n     *\n     * @private\n     *\n     * @param {Object | string | Relation} data - The input tabular data in dsv or json format or\n     * an existing Relation instance object.\n     * @param {Array} schema - An array of data schema.\n     * @param {Object} [options] - The optional options.\n     */\n    constructor (...params) {\n        let source;\n\n        this._parent = null;\n        this._derivation = [];\n        this._ancestorDerivation = [];\n        this._children = [];\n\n        if (params.length === 1 && ((source = params[0]) instanceof Relation)) {\n            // parent datamodel was passed as part of source\n            this._colIdentifier = source._colIdentifier;\n            this._rowDiffset = source._rowDiffset;\n            this._dataFormat = source._dataFormat;\n            this._parent = source;\n            this._partialFieldspace = this._parent._partialFieldspace;\n            this._fieldStoreName = getUniqueId();\n            this.__calculateFieldspace().calculateFieldsConfig();\n        } else {\n            updateData(this, ...params);\n            this._fieldStoreName = this._partialFieldspace.name;\n            this.__calculateFieldspace().calculateFieldsConfig();\n            this._propagationNameSpace = {\n                mutableActions: {},\n                immutableActions: {}\n            };\n        }\n    }\n\n    /**\n     * Retrieves the {@link Schema | schema} details for every {@link Field | field} as an array.\n     *\n     * @public\n     *\n     * @return {Array.<Schema>} Array of fields schema.\n     *      ```\n     *      [\n     *          { name: 'Name', type: 'dimension' },\n     *          { name: 'Miles_per_Gallon', type: 'measure', numberFormat: (val) => `${val} miles / gallon` },\n     *          { name: 'Cylinder', type: 'dimension' },\n     *          { name: 'Displacement', type: 'measure', defAggFn: 'max' },\n     *          { name: 'HorsePower', type: 'measure', defAggFn: 'max' },\n     *          { name: 'Weight_in_lbs', type: 'measure', defAggFn: 'avg',  },\n     *          { name: 'Acceleration', type: 'measure', defAggFn: 'avg' },\n     *          { name: 'Year', type: 'dimension', subtype: 'datetime', format: '%Y' },\n     *          { name: 'Origin' }\n     *      ]\n     *      ```\n     */\n    getSchema () {\n        return this.getFieldspace().fields.map(d => d.schema());\n    }\n\n    /**\n     * Returns the name of the {@link DataModel} instance. If no name was specified during {@link DataModel}\n     * initialization, then it returns a auto-generated name.\n     *\n     * @public\n     *\n     * @return {string} Name of the DataModel instance.\n     */\n    getName() {\n        return this._fieldStoreName;\n    }\n\n    getFieldspace () {\n        return this._fieldspace;\n    }\n\n    __calculateFieldspace () {\n        this._fieldspace = updateFields([this._rowDiffset, this._colIdentifier],\n             this.getPartialFieldspace(), this._fieldStoreName);\n        return this;\n    }\n\n    getPartialFieldspace () {\n        return this._partialFieldspace;\n    }\n\n    /**\n     * Performs {@link link_of_cross_product | cross-product} between two {@link DataModel} instances and returns a\n     * new {@link DataModel} instance containing the results. This operation is also called theta join.\n     *\n     * Cross product takes two set and create one set where each value of one set is paired with each value of another\n     * set.\n     *\n     * This method takes an optional predicate which filters the generated result rows. If the predicate returns true\n     * the combined row is included in the resulatant table.\n     *\n     * @example\n     *  let originDM = dm.project(['Origin','Origin_Formal_Name']);\n     *  let carsDM = dm.project(['Name','Miles_per_Gallon','Origin'])\n     *\n     *  console.log(carsDM.join(originDM)));\n     *\n     *  console.log(carsDM.join(originDM,\n     *      obj => obj.[originDM.getName()].Origin === obj.[carsDM.getName()].Origin));\n     *\n     * @text\n     * This is chained version of `join` operator. `join` can also be used as\n     * {@link link_to_join_op | functional operator}.\n     *\n     * @public\n     *\n     * @param {DataModel} joinWith - The DataModel to be joined with the current instance DataModel.\n     * @param {SelectionPredicate} filterFn - The predicate function that will filter the result of the crossProduct.\n     *\n     * @return {DataModel} New DataModel instance created after joining.\n     */\n    join (joinWith, filterFn) {\n        return crossProduct(this, joinWith, filterFn);\n    }\n\n    /**\n     * {@link natural_join | Natural join} is a special kind of cross-product join where filtering of rows are performed\n     * internally by resolving common fields are from both table and the rows with common value are included.\n     *\n     * @example\n     *  let originDM = dm.project(['Origin','Origin_Formal_Name']);\n     *  let carsDM = dm.project(['Name','Miles_per_Gallon','Origin'])\n     *\n     *  console.log(carsDM.naturalJoin(originDM));\n     *\n     * @text\n     * This is chained version of `naturalJoin` operator. `naturalJoin` can also be used as\n     * {@link link_to_join_op | functional operator}.\n     *\n     * @public\n     *\n     * @param {DataModel} joinWith - The DataModel with which the current instance of DataModel on which the method is\n     *      called will be joined.\n     * @return {DataModel} New DataModel instance created after joining.\n     */\n    naturalJoin (joinWith) {\n        return crossProduct(this, joinWith, naturalJoinFilter(this, joinWith), true);\n    }\n\n    /**\n     * {@link link_to_union | Union} operation can be termed as vertical stacking of all rows from both the DataModel\n     * instances, provided that both of the {@link DataModel} instances should have same column names.\n     *\n     * @example\n     * console.log(EuropeanMakerDM.union(USAMakerDM));\n     *\n     * @text\n     * This is chained version of `naturalJoin` operator. `naturalJoin` can also be used as\n     * {@link link_to_join_op | functional operator}.\n     *\n     * @public\n     *\n     * @param {DataModel} unionWith - DataModel instance for which union has to be applied with the instance on which\n     *      the method is called\n     *\n     * @return {DataModel} New DataModel instance with the result of the operation\n     */\n    union (unionWith) {\n        return union(this, unionWith);\n    }\n\n    /**\n     * {@link link_to_difference | Difference } operation only include rows which are present in the datamodel on which\n     * it was called but not on the one passed as argument.\n     *\n     * @example\n     * console.log(highPowerDM.difference(highExpensiveDM));\n     *\n     * @text\n     * This is chained version of `naturalJoin` operator. `naturalJoin` can also be used as\n     * {@link link_to_join_op | functional operator}.\n     *\n     * @public\n     *\n     * @param {DataModel} differenceWith - DataModel instance for which difference has to be applied with the instance\n     *      on which the method is called\n     * @return {DataModel} New DataModel instance with the result of the operation\n     */\n    difference (differenceWith) {\n        return difference(this, differenceWith);\n    }\n\n    /**\n     * {@link link_to_selection | Selection} is a row filtering operation. It expects a predicate and an optional mode\n     * which control which all rows should be included in the resultant DataModel instance.\n     *\n     * {@link SelectionPredicate} is a function which returns a boolean value. For selection operation the selection\n     * function is called for each row of DataModel instance with the current row passed as argument.\n     *\n     * After executing {@link SelectionPredicate} the rows are labeled as either an entry of selection set or an entry\n     * of rejection set.\n     *\n     * {@link FilteringMode} operates on the selection and rejection set to determine which one would reflect in the\n     * resultant datamodel.\n     *\n     * @warning\n     * Selection and rejection set is only a logical idea for concept explanation purpose.\n     *\n     * @example\n     *  // with selection mode NORMAL:\n     *  const normDt = dt.select(fields => fields.Origin.value === \"USA\")\n     *  console.log(normDt));\n     *\n     * // with selection mode INVERSE:\n     * const inverDt = dt.select(fields => fields.Origin.value === \"USA\", { mode: DataModel.FilteringMode.INVERSE })\n     * console.log(inverDt);\n     *\n     * // with selection mode ALL:\n     * const dtArr = dt.select(fields => fields.Origin.value === \"USA\", { mode: DataModel.FilteringMode.ALL })\n     * // print the selected parts\n     * console.log(dtArr[0]);\n     * // print the inverted parts\n     * console.log(dtArr[1]);\n     *\n     * @text\n     * This is chained version of `select` operator. `select` can also be used as\n     * {@link link_to_join_op | functional operator}.\n     *\n     * @public\n     *\n     * @param {Function} selectFn - The predicate function which is called for each row with the current row.\n     * ```\n     *  function (row, i, cloneProvider, store)  { ... }\n     * ```\n     * @param {Object} config - The configuration object to control the inclusion exclusion of a row in resultant\n     * DataModel instance.\n     * @param {FilteringMode} [config.mode=FilteringMode.NORMAL] - The mode of the selection.\n     * @return {DataModel} Returns the new DataModel instance(s) after operation.\n     */\n    select (selectFn, config) {\n        const defConfig = {\n            mode: FilteringMode.NORMAL,\n            saveChild: true\n        };\n        config = Object.assign({}, defConfig, config);\n        config.mode = config.mode || defConfig.mode;\n\n        const cloneConfig = { saveChild: config.saveChild };\n        return cloneWithSelect(\n            this,\n            selectFn,\n            config,\n            cloneConfig\n        );\n    }\n\n    /**\n     * Retrieves a boolean value if the current {@link DataModel} instance has data.\n     *\n     * @example\n     * const schema = [\n     *    { name: 'CarName', type: 'dimension' },\n     *    { name: 'HorsePower', type: 'measure' },\n     *    { name: \"Origin\", type: 'dimension' }\n     * ];\n     * const data = [];\n     *\n     * const dt = new DataModel(data, schema);\n     * console.log(dt.isEmpty());\n     *\n     * @public\n     *\n     * @return {Boolean} True if the datamodel has no data, otherwise false.\n     */\n    isEmpty () {\n        return !this._rowDiffset.length || !this._colIdentifier.length;\n    }\n\n    /**\n     * Creates a clone from the current DataModel instance with child parent relationship.\n     *\n     * @private\n     * @param {boolean} [saveChild=true] - Whether the cloned instance would be recorded in the parent instance.\n     * @return {DataModel} - Returns the newly cloned DataModel instance.\n     */\n    clone (saveChild = true) {\n        const clonedDm = new this.constructor(this);\n        if (saveChild) {\n            clonedDm.setParent(this);\n        } else {\n            clonedDm.setParent(null);\n        }\n        return clonedDm;\n    }\n\n    /**\n     * {@link Projection} is filter column (field) operation. It expects list of fields' name and either include those\n     * or exclude those based on {@link FilteringMode} on the resultant variable.\n     *\n     * Projection expects array of fields name based on which it creates the selection and rejection set. All the field\n     * whose name is present in array goes in selection set and rest of the fields goes in rejection set.\n     *\n     * {@link FilteringMode} operates on the selection and rejection set to determine which one would reflect in the\n     * resulatant datamodel.\n     *\n     * @warning\n     * Selection and rejection set is only a logical idea for concept explanation purpose.\n     *\n     * @example\n     *  const dm = new DataModel(data, schema);\n     *\n     *  // with projection mode NORMAL:\n     *  const normDt = dt.project([\"Name\", \"HorsePower\"]);\n     *  console.log(normDt.getData());\n     *\n     *  // with projection mode INVERSE:\n     *  const inverDt = dt.project([\"Name\", \"HorsePower\"], { mode: DataModel.FilteringMode.INVERSE })\n     *  console.log(inverDt.getData());\n     *\n     *  // with selection mode ALL:\n     *  const dtArr = dt.project([\"Name\", \"HorsePower\"], { mode: DataModel.FilteringMode.ALL })\n     *  // print the normal parts\n     *  console.log(dtArr[0].getData());\n     *  // print the inverted parts\n     *  console.log(dtArr[1].getData());\n     *\n     * @text\n     * This is chained version of `select` operator. `select` can also be used as\n     * {@link link_to_join_op | functional operator}.\n     *\n     * @public\n     *\n     * @param {Array.<string | Regexp>} projField - An array of column names in string or regular expression.\n     * @param {Object} [config] - An optional config to control the creation of new DataModel\n     * @param {FilteringMode} [config.mode=FilteringMode.NORMAL] - Mode of the projection\n     *\n     * @return {DataModel} Returns the new DataModel instance after operation.\n     */\n    project (projField, config) {\n        const defConfig = {\n            mode: FilteringMode.NORMAL,\n            saveChild: true\n        };\n        config = Object.assign({}, defConfig, config);\n        const fieldConfig = this.getFieldsConfig();\n        const allFields = Object.keys(fieldConfig);\n        const { mode } = config;\n        const normalizedProjField = getNormalizedProFields(projField, allFields, fieldConfig);\n\n        let dataModel;\n\n        if (mode === FilteringMode.ALL) {\n            let projectionClone = cloneWithProject(this, normalizedProjField, {\n                mode: FilteringMode.NORMAL,\n                saveChild: config.saveChild\n            }, allFields);\n            let rejectionClone = cloneWithProject(this, normalizedProjField, {\n                mode: FilteringMode.INVERSE,\n                saveChild: config.saveChild\n            }, allFields);\n            dataModel = [projectionClone, rejectionClone];\n        } else {\n            let projectionClone = cloneWithProject(this, normalizedProjField, config, allFields);\n            dataModel = projectionClone;\n        }\n\n        return dataModel;\n    }\n\n    getFieldsConfig () {\n        return this._fieldConfig;\n    }\n\n    calculateFieldsConfig () {\n        this._fieldConfig = this._fieldspace.fields.reduce((acc, fieldObj, i) => {\n            acc[fieldObj.name()] = {\n                index: i,\n                def: fieldObj.schema(),\n            };\n            return acc;\n        }, {});\n        return this;\n    }\n\n\n    /**\n     * Frees up the resources associated with the current DataModel instance and breaks all the links instance has in\n     * the DAG.\n     *\n     * @public\n     */\n    dispose () {\n        this._parent && this._parent.removeChild(this);\n        this._parent = null;\n        this._children.forEach((child) => {\n            child._parent = null;\n        });\n        this._children = [];\n    }\n\n    /**\n     * Removes the specified child {@link DataModel} from the child list of the current {@link DataModel} instance.\n     *\n     * @example\n     * const schema = [\n     *    { name: 'Name', type: 'dimension' },\n     *    { name: 'HorsePower', type: 'measure' },\n     *    { name: \"Origin\", type: 'dimension' }\n     * ];\n     *\n     * const data = [\n     *    { Name: \"chevrolet chevelle malibu\", Horsepower: 130, Origin: \"USA\" },\n     *    { Name: \"citroen ds-21 pallas\", Horsepower: 115, Origin: \"Europe\" },\n     *    { Name: \"datsun pl510\", Horsepower: 88, Origin: \"Japan\" },\n     *    { Name: \"amc rebel sst\", Horsepower: 150, Origin: \"USA\"},\n     * ]\n     *\n     * const dt = new DataModel(data, schema);\n     *\n     * const dt2 = dt.select(fields => fields.Origin.value === \"USA\")\n     * dt.removeChild(dt2);\n     *\n     * @private\n     *\n     * @param {DataModel} child - Delegates the parent to remove this child.\n     */\n    removeChild (child) {\n        let idx = this._children.findIndex(sibling => sibling === child);\n        idx !== -1 ? this._children.splice(idx, 1) : true;\n    }\n\n    /**\n     * Sets the specified {@link DataModel} as a parent for the current {@link DataModel} instance.\n     *\n     * @param {DataModel} parent - The datamodel instance which will act as parent.\n     */\n    setParent (parent) {\n        this._parent && this._parent.removeChild(this);\n        this._parent = parent;\n        parent && parent._children.push(this);\n    }\n\n    /**\n     * Returns the parent {@link DataModel} instance.\n     *\n     * @example\n     * const schema = [\n     *    { name: 'Name', type: 'dimension' },\n     *    { name: 'HorsePower', type: 'measure' },\n     *    { name: \"Origin\", type: 'dimension' }\n     * ];\n     *\n     * const data = [\n     *    { Name: \"chevrolet chevelle malibu\", Horsepower: 130, Origin: \"USA\" },\n     *    { Name: \"citroen ds-21 pallas\", Horsepower: 115, Origin: \"Europe\" },\n     *    { Name: \"datsun pl510\", Horsepower: 88, Origin: \"Japan\" },\n     *    { Name: \"amc rebel sst\", Horsepower: 150, Origin: \"USA\"},\n     * ]\n     *\n     * const dt = new DataModel(data, schema);\n     *\n     * const dt2 = dt.select(fields => fields.Origin.value === \"USA\");\n     * const parentDm = dt2.getParent();\n     *\n     * @return {DataModel} Returns the parent DataModel instance.\n     */\n    getParent () {\n        return this._parent;\n    }\n\n    /**\n     * Returns the immediate child {@link DataModel} instances.\n     *\n     * @example\n     * const schema = [\n     *    { name: 'Name', type: 'dimension' },\n     *    { name: 'HorsePower', type: 'measure' },\n     *    { name: \"Origin\", type: 'dimension' }\n     * ];\n     *\n     * const data = [\n     *    { Name: \"chevrolet chevelle malibu\", Horsepower: 130, Origin: \"USA\" },\n     *    { Name: \"citroen ds-21 pallas\", Horsepower: 115, Origin: \"Europe\" },\n     *    { Name: \"datsun pl510\", Horsepower: 88, Origin: \"Japan\" },\n     *    { Name: \"amc rebel sst\", Horsepower: 150, Origin: \"USA\"},\n     * ]\n     *\n     * const dt = new DataModel(data, schema);\n     *\n     * const childDm1 = dt.select(fields => fields.Origin.value === \"USA\");\n     * const childDm2 = dt.select(fields => fields.Origin.value === \"Japan\");\n     * const childDm3 = dt.groupBy([\"Origin\"]);\n     *\n     * @return {DataModel[]} Returns the immediate child DataModel instances.\n     */\n    getChildren () {\n        return this._children;\n    }\n\n    /**\n     * Returns the in-between operation meta data while creating the current {@link DataModel} instance.\n     *\n     * @example\n     * const schema = [\n     *   { name: 'Name', type: 'dimension' },\n     *   { name: 'HorsePower', type: 'measure' },\n     *   { name: \"Origin\", type: 'dimension' }\n     * ];\n     *\n     * const data = [\n     *   { Name: \"chevrolet chevelle malibu\", Horsepower: 130, Origin: \"USA\" },\n     *   { Name: \"citroen ds-21 pallas\", Horsepower: 115, Origin: \"Europe\" },\n     *   { Name: \"datsun pl510\", Horsepower: 88, Origin: \"Japan\" },\n     *   { Name: \"amc rebel sst\", Horsepower: 150, Origin: \"USA\"},\n     * ]\n     *\n     * const dt = new DataModel(data, schema);\n     * const dt2 = dt.select(fields => fields.Origin.value === \"USA\");\n     * const dt3 = dt2.groupBy([\"Origin\"]);\n     * const derivations = dt3.getDerivations();\n     *\n     * @return {Any[]} Returns the derivation meta data.\n     */\n    getDerivations () {\n        return this._derivation;\n    }\n\n    /**\n     * Returns the in-between operation meta data happened from root {@link DataModel} to current instance.\n     *\n     * @example\n     * const schema = [\n     *   { name: 'Name', type: 'dimension' },\n     *   { name: 'HorsePower', type: 'measure' },\n     *   { name: \"Origin\", type: 'dimension' }\n     * ];\n     *\n     * const data = [\n     *   { Name: \"chevrolet chevelle malibu\", Horsepower: 130, Origin: \"USA\" },\n     *   { Name: \"citroen ds-21 pallas\", Horsepower: 115, Origin: \"Europe\" },\n     *   { Name: \"datsun pl510\", Horsepower: 88, Origin: \"Japan\" },\n     *   { Name: \"amc rebel sst\", Horsepower: 150, Origin: \"USA\"},\n     * ]\n     *\n     * const dt = new DataModel(data, schema);\n     * const dt2 = dt.select(fields => fields.Origin.value === \"USA\");\n     * const dt3 = dt2.groupBy([\"Origin\"]);\n     * const ancDerivations = dt3.getAncestorDerivations();\n     *\n     * @return {Any[]} Returns the previous derivation meta data.\n     */\n    getAncestorDerivations () {\n        return this._ancestorDerivation;\n    }\n}\n\nexport default Relation;\n","import { fnList } from '../operator/group-by-function';\n\nexport const { sum, avg, min, max, first, last, count, std: sd } = fnList;\n","/**\n * The utility function to calculate major column.\n *\n * @param {Object} store - The store object.\n * @return {Function} Returns the push function.\n */\nexport default (store) => {\n    let i = 0;\n    return (...fields) => {\n        fields.forEach((val, fieldIndex) => {\n            if (!(store[fieldIndex] instanceof Array)) {\n                store[fieldIndex] = Array.from({ length: i });\n            }\n            store[fieldIndex].push(val);\n        });\n        i++;\n    };\n};\n","/**\n * Creates a JS native date object from input\n *\n * @param {string | number | Date} date Input using which date object to be created\n * @return {Date} : JS native date object\n */\nfunction convertToNativeDate (date) {\n    if (date instanceof Date) {\n        return date;\n    }\n\n    return new Date(date);\n}\n/**\n * Apply padding before a number if its less than 1o. This is used when constant digit's number to be returned\n * between 0 - 99\n *\n * @param {number} n Input to be padded\n * @return {string} Padded number\n */\nfunction pad (n) {\n    return (n < 10) ? (`0${n}`) : n;\n}\n/*\n * DateFormatter utility to convert any date format to any other date format\n * DateFormatter parse a date time stamp specified by a user abiding by rules which are defined\n * by user in terms of token. It creates JS native date object from the user specified format.\n * That native date can also be displayed\n * in any specified format.\n * This utility class only takes care of format conversion only\n */\n\n/*\n * Escapes all the special character that are used in regular expression.\n * Like\n * RegExp.escape('sgfd-$') // Output: sgfd\\-\\$\n *\n * @param text {String} : text which is to be escaped\n */\nRegExp.escape = function (text) {\n    return text.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n};\n\n/**\n * DateTimeFormatter class to convert any user format of date time stamp to any other format\n * of date time stamp.\n *\n * @param {string} format Format of the date given. For the above date,\n * 'year: %Y, month: %b, day: %d'.\n * @class\n */\n/* istanbul ignore next */ function DateTimeFormatter (format) {\n    this.format = format;\n    this.dtParams = undefined;\n    this.nativeDate = undefined;\n}\n\n// The identifier of the tokens\nDateTimeFormatter.TOKEN_PREFIX = '%';\n\n// JS native Date constructor takes the date params (year, month, etc) in a certail sequence.\n// This defines the sequence of the date parameters in the constructor.\nDateTimeFormatter.DATETIME_PARAM_SEQUENCE = {\n    YEAR: 0,\n    MONTH: 1,\n    DAY: 2,\n    HOUR: 3,\n    MINUTE: 4,\n    SECOND: 5,\n    MILLISECOND: 6\n};\n\n/*\n * This is a default number parsing utility. It tries to parse a number in integer, if parsing is unsuccessful, it\n * gives back a default value.\n *\n * @param: defVal {Number} : Default no if the parsing to integer is not successful\n * @return {Function} : An closure function which is to be called by passing an the value which needs to be parsed.\n */\nDateTimeFormatter.defaultNumberParser = function (defVal) {\n    return function (val) {\n        let parsedVal;\n        if (isFinite(parsedVal = parseInt(val, 10))) {\n            return parsedVal;\n        }\n\n        return defVal;\n    };\n};\n\n/*\n * This is a default number range utility. It tries to find an element in the range. If not found it returns a\n * default no as an index.\n *\n * @param: range {Array} : The list which is to be serached\n * @param: defVal {Number} : Default no if the serach and find does not return anything\n * @return {Function} : An closure function which is to be called by passing an the value which needs to be found\n */\nDateTimeFormatter.defaultRangeParser = function (range, defVal) {\n    return (val) => {\n        let i;\n        let l;\n\n        if (!val) { return defVal; }\n\n        const nVal = val.toLowerCase();\n\n        for (i = 0, l = range.length; i < l; i++) {\n            if (range[i].toLowerCase() === nVal) {\n                return i;\n            }\n        }\n\n        if (i === undefined) {\n            return defVal;\n        }\n        return null;\n    };\n};\n\n/*\n * Defines the tokens which are supporter by the dateformatter. Using this definitation a value gets extracted from\n * the user specifed date string. This also formats the value for display purpose from native JS date.\n * The definition of each token contains the following named properties\n * {\n *     %token_name% : {\n *         name: name of the token, this is used in reverse lookup,\n *         extract: a function that returns the regular expression to extract that piece of information. All the\n *                  regex should be gouped by using ()\n *         parser: a function which receives value extracted by the above regex and parse it to get the date params\n *         formatter: a formatter function that takes milliseconds or JS Date object and format the param\n *                  represented by the token only.\n *     }\n * }\n *\n * @return {Object} : Definition of the all the supported tokens.\n */\nDateTimeFormatter.getTokenDefinitions = function () {\n    const daysDef = {\n        short: [\n            'Sun',\n            'Mon',\n            'Tue',\n            'Wed',\n            'Thu',\n            'Fri',\n            'Sat'\n        ],\n        long: [\n            'Sunday',\n            'Monday',\n            'Tuesday',\n            'Wednesday',\n            'Thursday',\n            'Friday',\n            'Saturday'\n        ]\n    };\n    const monthsDef = {\n        short: [\n            'Jan',\n            'Feb',\n            'Mar',\n            'Apr',\n            'May',\n            'Jun',\n            'Jul',\n            'Aug',\n            'Sep',\n            'Oct',\n            'Nov',\n            'Dec'\n        ],\n        long: [\n            'January',\n            'February',\n            'March',\n            'April',\n            'May',\n            'June',\n            'July',\n            'August',\n            'September',\n            'October',\n            'November',\n            'December'\n        ]\n    };\n\n    const definitions = {\n        H: {\n            // 24 hours format\n            name: 'H',\n            index: 3,\n            extract () { return '(\\\\d+)'; },\n            parser: DateTimeFormatter.defaultNumberParser(),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n\n                return d.getHours().toString();\n            }\n        },\n        l: {\n            // 12 hours format\n            name: 'l',\n            index: 3,\n            extract () { return '(\\\\d+)'; },\n            parser: DateTimeFormatter.defaultNumberParser(),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const hours = d.getHours() % 12;\n\n                return (hours === 0 ? 12 : hours).toString();\n            }\n        },\n        p: {\n            // AM or PM\n            name: 'p',\n            index: 3,\n            extract () { return '(AM|PM)'; },\n            parser: (val) => {\n                if (val) {\n                    return val.toLowerCase();\n                }\n                return null;\n            },\n            formatter: (val) => {\n                const d = convertToNativeDate(val);\n                const hours = d.getHours();\n\n                return (hours < 12 ? 'AM' : 'PM');\n            }\n        },\n        P: {\n            // am or pm\n            name: 'P',\n            index: 3,\n            extract () { return '(am|pm)'; },\n            parser: (val) => {\n                if (val) {\n                    return val.toLowerCase();\n                }\n                return null;\n            },\n            formatter: (val) => {\n                const d = convertToNativeDate(val);\n                const hours = d.getHours();\n\n                return (hours < 12 ? 'am' : 'pm');\n            }\n        },\n        M: {\n            // Two digit minutes 00 - 59\n            name: 'M',\n            index: 4,\n            extract () { return '(\\\\d+)'; },\n            parser: DateTimeFormatter.defaultNumberParser(),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const mins = d.getMinutes();\n\n                return pad(mins);\n            }\n        },\n        S: {\n            // Two digit seconds 00 - 59\n            name: 'S',\n            index: 5,\n            extract () { return '(\\\\d+)'; },\n            parser: DateTimeFormatter.defaultNumberParser(),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const seconds = d.getSeconds();\n\n                return pad(seconds);\n            }\n        },\n        K: {\n            // Milliseconds\n            name: 'K',\n            index: 6,\n            extract () { return '(\\\\d+)'; },\n            parser: DateTimeFormatter.defaultNumberParser(),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const ms = d.getMilliseconds();\n\n                return ms.toString();\n            }\n        },\n        a: {\n            // Short name of day, like Mon\n            name: 'a',\n            index: 2,\n            extract () { return `(${daysDef.short.join('|')})`; },\n            parser: DateTimeFormatter.defaultRangeParser(daysDef.short),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const day = d.getDay();\n\n                return (daysDef.short[day]).toString();\n            }\n        },\n        A: {\n            // Long name of day, like Monday\n            name: 'A',\n            index: 2,\n            extract () { return `(${daysDef.long.join('|')})`; },\n            parser: DateTimeFormatter.defaultRangeParser(daysDef.long),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const day = d.getDay();\n\n                return (daysDef.long[day]).toString();\n            }\n        },\n        e: {\n            // 8 of March, 11 of November\n            name: 'e',\n            index: 2,\n            extract () { return '(\\\\d+)'; },\n            parser: DateTimeFormatter.defaultNumberParser(),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const day = d.getDate();\n\n                return day.toString();\n            }\n        },\n        d: {\n            // 08 of March, 11 of November\n            name: 'd',\n            index: 2,\n            extract () { return '(\\\\d+)'; },\n            parser: DateTimeFormatter.defaultNumberParser(),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const day = d.getDate();\n\n                return pad(day);\n            }\n        },\n        b: {\n            // Short month, like Jan\n            name: 'b',\n            index: 1,\n            extract () { return `(${monthsDef.short.join('|')})`; },\n            parser: DateTimeFormatter.defaultRangeParser(monthsDef.short),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const month = d.getMonth();\n\n                return (monthsDef.short[month]).toString();\n            }\n        },\n        B: {\n            // Long month, like January\n            name: 'B',\n            index: 1,\n            extract () { return `(${monthsDef.long.join('|')})`; },\n            parser: DateTimeFormatter.defaultRangeParser(monthsDef.long),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const month = d.getMonth();\n\n                return (monthsDef.long[month]).toString();\n            }\n        },\n        m: {\n            // Two digit month of year like 01 for January\n            name: 'm',\n            index: 1,\n            extract () { return '(\\\\d+)'; },\n            parser (val) { return DateTimeFormatter.defaultNumberParser()(val) - 1; },\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const month = d.getMonth();\n\n                return pad(month + 1);\n            }\n        },\n        y: {\n            // Short year like 90 for 1990\n            name: 'y',\n            index: 0,\n            extract () { return '(\\\\d{2})'; },\n            parser (val) {\n                let result;\n                if (val) {\n                    const l = val.length;\n                    val = val.substring(l - 2, l);\n                }\n                let parsedVal = DateTimeFormatter.defaultNumberParser()(val);\n                let presentDate = new Date();\n                let presentYear = Math.trunc((presentDate.getFullYear()) / 100);\n\n                result = `${presentYear}${parsedVal}`;\n\n                if (convertToNativeDate(result).getFullYear() > presentDate.getFullYear()) {\n                    result = `${presentYear - 1}${parsedVal}`;\n                }\n                return convertToNativeDate(result).getFullYear();\n            },\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                let year = d.getFullYear().toString();\n                let l;\n\n                if (year) {\n                    l = year.length;\n                    year = year.substring(l - 2, l);\n                }\n\n                return year;\n            }\n        },\n        Y: {\n            // Long year like 1990\n            name: 'Y',\n            index: 0,\n            extract () { return '(\\\\d{4})'; },\n            parser: DateTimeFormatter.defaultNumberParser(),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const year = d.getFullYear().toString();\n\n                return year;\n            }\n        }\n    };\n\n    return definitions;\n};\n\n/*\n * The tokens which works internally is not user friendly in terms of memorizing the names. This gives a formal\n * definition to the informal notations.\n *\n * @return {Object} : Formal definition of the tokens\n */\nDateTimeFormatter.getTokenFormalNames = function () {\n    const definitions = DateTimeFormatter.getTokenDefinitions();\n\n    return {\n        HOUR: definitions.H,\n        HOUR_12: definitions.l,\n        AMPM_UPPERCASE: definitions.p,\n        AMPM_LOWERCASE: definitions.P,\n        MINUTE: definitions.M,\n        SECOND: definitions.S,\n        SHORT_DAY: definitions.a,\n        LONG_DAY: definitions.A,\n        DAY_OF_MONTH: definitions.e,\n        DAY_OF_MONTH_CONSTANT_WIDTH: definitions.d,\n        SHORT_MONTH: definitions.b,\n        LONG_MONTH: definitions.B,\n        MONTH_OF_YEAR: definitions.m,\n        SHORT_YEAR: definitions.y,\n        LONG_YEAR: definitions.Y\n    };\n};\n\n/*\n * This defines the rules and declares dependencies that resolves a date parameter (year, month etc) from\n * the date time parameter array.\n *\n * @return {Object} : An object that contains dependencies and a resolver function. The dependencies values are fed\n *                  to the resolver function in that particular sequence only.\n */\nDateTimeFormatter.tokenResolver = function () {\n    const definitions = DateTimeFormatter.getTokenDefinitions();\n    const defaultResolver = (...args) => { // eslint-disable-line require-jsdoc\n        let i = 0;\n        let arg;\n        let targetParam;\n        const l = args.length;\n\n        for (; i < l; i++) {\n            arg = args[i];\n            if (args[i]) {\n                targetParam = arg;\n            }\n        }\n\n        if (!targetParam) { return null; }\n\n        return targetParam[0].parser(targetParam[1]);\n    };\n\n    return {\n        YEAR: [definitions.y, definitions.Y,\n            defaultResolver\n        ],\n        MONTH: [definitions.b, definitions.B, definitions.m,\n            defaultResolver\n        ],\n        DAY: [definitions.a, definitions.A, definitions.e, definitions.d,\n            defaultResolver\n        ],\n        HOUR: [definitions.H, definitions.l, definitions.p, definitions.P,\n            function (hourFormat24, hourFormat12, ampmLower, ampmUpper) {\n                let targetParam;\n                let amOrpm;\n                let isPM;\n                let val;\n\n                if (hourFormat12 && (amOrpm = (ampmLower || ampmUpper))) {\n                    if (amOrpm[0].parser(amOrpm[1]) === 'pm') {\n                        isPM = true;\n                    }\n\n                    targetParam = hourFormat12;\n                } else if (hourFormat12) {\n                    targetParam = hourFormat12;\n                } else {\n                    targetParam = hourFormat24;\n                }\n\n                if (!targetParam) { return null; }\n\n                val = targetParam[0].parser(targetParam[1]);\n                if (isPM) {\n                    val += 12;\n                }\n                return val;\n            }\n        ],\n        MINUTE: [definitions.M,\n            defaultResolver\n        ],\n        SECOND: [definitions.S,\n            defaultResolver\n        ]\n    };\n};\n\n/*\n * Finds token from the format rule specified by a user.\n * @param format {String} : The format of the input date specified by the user\n * @return {Array} : An array of objects which contains the available token and their occurence index in the format\n */\nDateTimeFormatter.findTokens = function (format) {\n    const tokenPrefix = DateTimeFormatter.TOKEN_PREFIX;\n    const definitions = DateTimeFormatter.getTokenDefinitions();\n    const tokenLiterals = Object.keys(definitions);\n    const occurrence = [];\n    let i;\n    let forwardChar;\n\n    while ((i = format.indexOf(tokenPrefix, i + 1)) >= 0) {\n        forwardChar = format[i + 1];\n        if (tokenLiterals.indexOf(forwardChar) === -1) { continue; }\n\n        occurrence.push({\n            index: i,\n            token: forwardChar\n        });\n    }\n\n    return occurrence;\n};\n\n/*\n * Format any JS date to a specified date given by user.\n *\n * @param date {Number | Date} : The date object which is to be formatted\n * @param format {String} : The format using which the date will be formatted for display\n */\nDateTimeFormatter.formatAs = function (date, format) {\n    const nDate = convertToNativeDate(date);\n    const occurrence = DateTimeFormatter.findTokens(format);\n    const definitions = DateTimeFormatter.getTokenDefinitions();\n    let formattedStr = String(format);\n    const tokenPrefix = DateTimeFormatter.TOKEN_PREFIX;\n    let token;\n    let formattedVal;\n    let i;\n    let l;\n\n    for (i = 0, l = occurrence.length; i < l; i++) {\n        token = occurrence[i].token;\n        formattedVal = definitions[token].formatter(nDate);\n        formattedStr = formattedStr.replace(new RegExp(tokenPrefix + token, 'g'), formattedVal);\n    }\n\n    return formattedStr;\n};\n\n/*\n * Parses the user specified date string to extract the date time params.\n *\n * @return {Array} : Value of date time params in an array [year, month, day, hour, minutes, seconds, milli]\n */\nDateTimeFormatter.prototype.parse = function (dateTimeStamp, options) {\n    const tokenResolver = DateTimeFormatter.tokenResolver();\n    const dtParams = this.extractTokenValue(dateTimeStamp);\n    const dtParamSeq = DateTimeFormatter.DATETIME_PARAM_SEQUENCE;\n    const noBreak = options && options.noBreak;\n    const dtParamArr = [];\n    const args = [];\n    let resolverKey;\n    let resolverParams;\n    let resolverFn;\n    let val;\n    let i;\n    let param;\n    let resolvedVal;\n    let l;\n    let result = [];\n\n    for (resolverKey in tokenResolver) {\n        if (!{}.hasOwnProperty.call(tokenResolver, resolverKey)) { continue; }\n\n        args.length = 0;\n        resolverParams = tokenResolver[resolverKey];\n        resolverFn = resolverParams.splice(resolverParams.length - 1, 1)[0];\n\n        for (i = 0, l = resolverParams.length; i < l; i++) {\n            param = resolverParams[i];\n            val = dtParams[param.name];\n\n            if (val === undefined) {\n                args.push(null);\n            } else {\n                args.push([param, val]);\n            }\n        }\n\n        resolvedVal = resolverFn.apply(this, args);\n\n        if ((resolvedVal === undefined || resolvedVal === null) && !noBreak) {\n            break;\n        }\n\n        dtParamArr[dtParamSeq[resolverKey]] = resolvedVal;\n    }\n\n    if (dtParamArr.length && this.checkIfOnlyYear(dtParamArr.length))\n     {\n        result.unshift(dtParamArr[0], 0, 1); }\n    else {\n        result.unshift(...dtParamArr);\n    }\n\n    return result;\n};\n\n/*\n * Extract the value of the token from user specified date time string.\n *\n * @return {Object} : An key value pair which contains the tokens as key and value as pair\n */\nDateTimeFormatter.prototype.extractTokenValue = function (dateTimeStamp) {\n    const format = this.format;\n    const definitions = DateTimeFormatter.getTokenDefinitions();\n    const tokenPrefix = DateTimeFormatter.TOKEN_PREFIX;\n    const occurrence = DateTimeFormatter.findTokens(format);\n    const tokenObj = {};\n\n    let lastOccurrenceIndex;\n    let occObj;\n    let occIndex;\n    let targetText;\n    let regexFormat;\n\n    let l;\n    let i;\n\n    regexFormat = String(format);\n\n    const tokenArr = occurrence.map(obj => obj.token);\n    const occurrenceLength = occurrence.length;\n    for (i = occurrenceLength - 1; i >= 0; i--) {\n        occIndex = occurrence[i].index;\n\n        if (occIndex + 1 === regexFormat.length - 1) {\n            lastOccurrenceIndex = occIndex;\n            continue;\n        }\n\n        if (lastOccurrenceIndex === undefined) {\n            lastOccurrenceIndex = regexFormat.length;\n        }\n\n        targetText = regexFormat.substring(occIndex + 2, lastOccurrenceIndex);\n        regexFormat = regexFormat.substring(0, occIndex + 2) +\n            RegExp.escape(targetText) +\n            regexFormat.substring(lastOccurrenceIndex, regexFormat.length);\n\n        lastOccurrenceIndex = occIndex;\n    }\n\n    for (i = 0; i < occurrenceLength; i++) {\n        occObj = occurrence[i];\n        regexFormat = regexFormat.replace(tokenPrefix + occObj.token, definitions[occObj.token].extract());\n    }\n\n    const extractValues = dateTimeStamp.match(new RegExp(regexFormat)) || [];\n    extractValues.shift();\n\n    for (i = 0, l = tokenArr.length; i < l; i++) {\n        tokenObj[tokenArr[i]] = extractValues[i];\n    }\n    return tokenObj;\n};\n\n/*\n * Give back the JS native date formed from  user specified date string\n *\n * @return {Date} : Native JS Date\n */\nDateTimeFormatter.prototype.getNativeDate = function (dateTimeStamp) {\n    let date = null;\n    if (Number.isFinite(dateTimeStamp)) {\n        date = new Date(dateTimeStamp);\n    } else if (!this.format && Date.parse(dateTimeStamp)) {\n        date = new Date(dateTimeStamp);\n    }\n    else {\n        const dtParams = this.dtParams = this.parse(dateTimeStamp);\n        if (dtParams.length) {\n            this.nativeDate = new Date(...dtParams);\n            date = this.nativeDate;\n        }\n    }\n    return date;\n};\n\nDateTimeFormatter.prototype.checkIfOnlyYear = function(len) {\n    return len === 1 && this.format.match(/y|Y/g).length;\n};\n\n/*\n * Represents JS native date to a user specified format.\n *\n * @param format {String} : The format according to which the date is to be represented\n * @return {String} : The formatted date string\n */\nDateTimeFormatter.prototype.formatAs = function (format, dateTimeStamp) {\n    let nativeDate;\n\n    if (dateTimeStamp) {\n        nativeDate = this.nativeDate = this.getNativeDate(dateTimeStamp);\n    } else if (!(nativeDate = this.nativeDate)) {\n        nativeDate = this.getNativeDate(dateTimeStamp);\n    }\n\n    return DateTimeFormatter.formatAs(nativeDate, format);\n};\n\nexport { DateTimeFormatter as default };\n","/**\n * Generates domain for measure field.\n *\n * @param {Array} data - The array of data.\n * @return {Array} Returns the measure domain.\n */\nexport default (data) => {\n    let min = Number.POSITIVE_INFINITY;\n    let max = Number.NEGATIVE_INFINITY;\n\n    data.forEach((d) => {\n        if (d < min) {\n            min = d;\n        }\n        if (d > max) {\n            max = d;\n        }\n    });\n\n    return [min, max];\n};\n","/* eslint-disable */\nconst OBJECTSTRING = 'object';\nconst objectToStrFn = Object.prototype.toString;\nconst objectToStr = '[object Object]';\nconst arrayToStr = '[object Array]';\n\nfunction checkCyclicRef(obj, parentArr) {\n    let i = parentArr.length;\n    let bIndex = -1;\n\n    while (i) {\n        if (obj === parentArr[i]) {\n            bIndex = i;\n            return bIndex;\n        }\n        i -= 1;\n    }\n\n    return bIndex;\n}\n\nfunction merge(obj1, obj2, skipUndef, tgtArr, srcArr) {\n    var item,\n        srcVal,\n        tgtVal,\n        str,\n        cRef;\n    // check whether obj2 is an array\n    // if array then iterate through it's index\n    // **** MOOTOOLS precution\n\n    if (!srcArr) {\n        tgtArr = [obj1];\n        srcArr = [obj2];\n    }\n    else {\n        tgtArr.push(obj1);\n        srcArr.push(obj2);\n    }\n\n    if (obj2 instanceof Array) {\n        for (item = 0; item < obj2.length; item += 1) {\n            try {\n                srcVal = obj1[item];\n                tgtVal = obj2[item];\n            }\n            catch (e) {\n                continue;\n            }\n\n            if (typeof tgtVal !== OBJECTSTRING) {\n                if (!(skipUndef && tgtVal === undefined)) {\n                    obj1[item] = tgtVal;\n                }\n            }\n            else {\n                if (srcVal === null || typeof srcVal !== OBJECTSTRING) {\n                    srcVal = obj1[item] = tgtVal instanceof Array ? [] : {};\n                }\n                cRef = checkCyclicRef(tgtVal, srcArr);\n                if (cRef !== -1) {\n                    srcVal = obj1[item] = tgtArr[cRef];\n                }\n                else {\n                    merge(srcVal, tgtVal, skipUndef, tgtArr, srcArr);\n                }\n            }\n        }\n    }\n    else {\n        for (item in obj2) {\n            try {\n                srcVal = obj1[item];\n                tgtVal = obj2[item];\n            }\n            catch (e) {\n                continue;\n            }\n\n            if (tgtVal !== null && typeof tgtVal === OBJECTSTRING) {\n                // Fix for issue BUG: FWXT-602\n                // IE < 9 Object.prototype.toString.call(null) gives\n                // '[object Object]' instead of '[object Null]'\n                // that's why null value becomes Object in IE < 9\n                str = objectToStrFn.call(tgtVal);\n                if (str === objectToStr) {\n                    if (srcVal === null || typeof srcVal !== OBJECTSTRING) {\n                        srcVal = obj1[item] = {};\n                    }\n                    cRef = checkCyclicRef(tgtVal, srcArr);\n                    if (cRef !== -1) {\n                        srcVal = obj1[item] = tgtArr[cRef];\n                    }\n                    else {\n                        merge(srcVal, tgtVal, skipUndef, tgtArr, srcArr);\n                    }\n                }\n                else if (str === arrayToStr) {\n                    if (srcVal === null || !(srcVal instanceof Array)) {\n                        srcVal = obj1[item] = [];\n                    }\n                    cRef = checkCyclicRef(tgtVal, srcArr);\n                    if (cRef !== -1) {\n                        srcVal = obj1[item] = tgtArr[cRef];\n                    }\n                    else {\n                        merge(srcVal, tgtVal, skipUndef, tgtArr, srcArr);\n                    }\n                }\n                else {\n                    obj1[item] = tgtVal;\n                }\n            }\n            else {\n                if (skipUndef && tgtVal === undefined) {\n                    continue;\n                }\n                obj1[item] = tgtVal;\n            }\n        }\n    }\n    return obj1;\n}\n\n\nfunction extend2 (obj1, obj2, skipUndef) {\n    //if none of the arguments are object then return back\n    if (typeof obj1 !== OBJECTSTRING && typeof obj2 !== OBJECTSTRING) {\n        return null;\n    }\n\n    if (typeof obj2 !== OBJECTSTRING || obj2 === null) {\n        return obj1;\n    }\n\n    if (typeof obj1 !== OBJECTSTRING) {\n        obj1 = obj2 instanceof Array ? [] : {};\n    }\n    merge(obj1, obj2, skipUndef);\n    return obj1;\n}\n\nexport { extend2 as default };\n","import { DataFormat } from '../enums';\n\n/**\n * Checks whether the value is an array.\n *\n * @param  {*} val - The value to be checked.\n * @return {boolean} Returns true if the value is an array otherwise returns false.\n */\nexport function isArray (val) {\n    return Array.isArray(val);\n}\n\n/**\n * Checks whether the value is an object.\n *\n * @param  {*} val - The value to be checked.\n * @return {boolean} Returns true if the value is an object otherwise returns false.\n */\nexport function isObject (val) {\n    return val === Object(val);\n}\n\n/**\n * Checks whether the value is a string value.\n *\n * @param  {*} val - The value to be checked.\n * @return {boolean} Returns true if the value is a string value otherwise returns false.\n */\nexport function isString (val) {\n    return typeof val === 'string';\n}\n\n/**\n * Checks whether the value is callable.\n *\n * @param {*} val - The value to be checked.\n * @return {boolean} Returns true if the value is callable otherwise returns false.\n */\nexport function isCallable (val) {\n    return typeof val === 'function';\n}\n\n/**\n * Returns the unique values from the input array.\n *\n * @param {Array} data - The input array.\n * @return {Array} Returns a new array of unique values.\n */\nexport function uniqueValues (data) {\n    return [...new Set(data)];\n}\n\nexport const getUniqueId = () => `id-${new Date().getTime()}${Math.round(Math.random() * 10000)}`;\n\n/**\n * Checks Whether two arrays have same content.\n *\n * @param {Array} arr1 - The first array.\n * @param {Array} arr2 - The 2nd array.\n * @return {boolean} Returns whether two array have same content.\n */\nexport function isArrEqual(arr1, arr2) {\n    if (!isArray(arr1) || !isArray(arr2)) {\n        return arr1 === arr2;\n    }\n\n    if (arr1.length !== arr2.length) {\n        return false;\n    }\n\n    for (let i = 0; i < arr1.length; i++) {\n        if (arr1[i] !== arr2[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * It is the default number format function for the measure field type.\n *\n * @param {any} val - The input value.\n * @return {number} Returns a number value.\n */\nexport function formatNumber(val) {\n    return val;\n}\n\n/**\n * Returns the detected data format.\n *\n * @param {any} data - The input data to be tested.\n * @return {string} Returns the data format name.\n */\nexport const detectDataFormat = (data) => {\n    if (isString(data)) {\n        return DataFormat.DSV_STR;\n    } else if (isArray(data) && isArray(data[0])) {\n        return DataFormat.DSV_ARR;\n    } else if (isArray(data) && (data.length === 0 || isObject(data[0]))) {\n        return DataFormat.FLAT_JSON;\n    }\n    return null;\n};\n","export { default as DateTimeFormatter } from './date-time-formatter';\nexport { default as columnMajor } from './column-major';\nexport { default as generateMeasureDomain } from './domain-generator';\nexport { default as extend2 } from './extend2';\nexport * from './helper';\n","import { defReducer, fnList } from '../operator';\n\n/**\n * A page level storage which stores, registers, unregisters reducers for all the datamodel instances. There is only one\n * reducer store available in a page. All the datamodel instances receive same instance of reducer store. DataModel\n * out of the box provides handful of {@link reducer | reducers} which can be used as reducer funciton.\n *\n * @public\n * @namespace DataModel\n */\nclass ReducerStore {\n    constructor () {\n        this.store = new Map();\n        this.store.set('defReducer', defReducer);\n\n        Object.entries(fnList).forEach((key) => {\n            this.store.set(key[0], key[1]);\n        });\n    }\n\n    /**\n     * Changes the `defaultReducer` globally. For all the fields which does not have `defAggFn` mentioned in schema, the\n     * value of `defaultReducer` is used for aggregation.\n     *\n     * @public\n     * @param {string} [reducer='sum'] - The name of the default reducer. It picks up the definition from store by doing\n     * name lookup. If no name is found then it takes `sum` as the default reducer.\n     * @return {ReducerStore} Returns instance of the singleton store in page.\n     */\n    defaultReducer (...params) {\n        if (!params.length) {\n            return this.store.get('defReducer');\n        }\n\n        let reducer = params[0];\n\n        if (typeof reducer === 'function') {\n            this.store.set('defReducer', reducer);\n        } else {\n            reducer = String(reducer);\n            if (Object.keys(fnList).indexOf(reducer) !== -1) {\n                this.store.set('defReducer', fnList[reducer]);\n            } else {\n                throw new Error(`Reducer ${reducer} not found in registry`);\n            }\n        }\n        return this;\n    }\n\n    /**\n     *\n     * Registers a {@link reducer | reducer}.\n     * A {@link reducer | reducer} has to be registered before it is used.\n     *\n     * @example\n     *  // find the mean squared value of a given set\n     *  const reducerStore = DataModel.Reducers();\n     *\n     *  reducers.register('meanSquared', (arr) => {\n     *      const squaredVal = arr.map(item => item * item);\n     *      let sum = 0;\n     *      for (let i = 0, l = squaredVal.length; i < l; i++) {\n     *          sum += squaredVal[i++];\n     *      }\n     *\n     *      return sum;\n     *  })\n     *\n     *  // datamodel (dm) is already prepared with cars.json\n     *  const dm1 = dm.groupBy(['origin'], {\n     *      accleration: 'meanSquared'\n     *  });\n     *\n     * @public\n     *\n     * @param {string} name formal name for a reducer. If the given name already exists in store it is overridden by new\n     *      definition.\n     * @param {Function} reducer definition of {@link reducer} function.\n     *\n     * @return {Function} function for unregistering the reducer.\n     */\n    register (name, reducer) {\n        if (typeof reducer !== 'function') {\n            throw new Error('Reducer should be a function');\n        }\n\n        name = String(name);\n        this.store.set(name, reducer);\n\n        return () => { this.__unregister(name); };\n    }\n\n    __unregister (name) {\n        if (this.store.has(name)) {\n            this.store.delete(name);\n        }\n    }\n\n    resolve (name) {\n        if (name instanceof Function) {\n            return name;\n        }\n        return this.store.get(name);\n    }\n}\n\nconst reducerStore = (function () {\n    let store = null;\n\n    function getStore () {\n        if (store === null) {\n            store = new ReducerStore();\n        }\n        return store;\n    }\n    return getStore();\n}());\n\nexport default reducerStore;\n","import { getNumberFormattedVal } from './helper';\n\n/**\n * The wrapper class on top of the primitive value of a field.\n *\n * @todo Need to have support for StringValue, NumberValue, DateTimeValue\n * and GeoValue. These types should expose predicate API mostly.\n */\nclass Value {\n\n  /**\n   * Creates new Value instance.\n   *\n   * @param {*} val - the primitive value from the field cell.\n   * @param {string | Field} field - The field from which the value belongs.\n   */\n    constructor (value, rawValue, field) {\n        const formattedValue = getNumberFormattedVal(field, value);\n\n        Object.defineProperties(this, {\n            _value: {\n                enumerable: false,\n                configurable: false,\n                writable: false,\n                value\n            },\n            _formattedValue: {\n                enumerable: false,\n                configurable: false,\n                writable: false,\n                value: formattedValue\n            },\n            _internalValue: {\n                enumerable: false,\n                configurable: false,\n                writable: false,\n                value: rawValue\n            }\n        });\n\n        this.field = field;\n    }\n\n  /**\n   * Returns the field value.\n   *\n   * @return {*} Returns the current value.\n   */\n    get value () {\n        return this._value;\n    }\n\n    /**\n     * Returns the parsed value of field\n     */\n    get formattedValue () {\n        return this._formattedValue;\n    }\n\n    /**\n     * Returns the internal value of field\n     */\n    get internalValue () {\n        return this._internalValue;\n    }\n\n  /**\n   * Converts to human readable string.\n   *\n   * @override\n   * @return {string} Returns a human readable string of the field value.\n   *\n   */\n    toString () {\n        return String(this.value);\n    }\n\n  /**\n   * Returns the value of the field.\n   *\n   * @override\n   * @return {*} Returns the field value.\n   */\n    valueOf () {\n        return this.value;\n    }\n}\n\nexport default Value;\n"],"sourceRoot":""}