{"version":3,"sources":["webpack://DataModel/webpack/universalModuleDefinition","webpack://DataModel/webpack/bootstrap","webpack://DataModel/./node_modules/d3-dsv/src/autoType.js","webpack://DataModel/./node_modules/d3-dsv/src/csv.js","webpack://DataModel/./node_modules/d3-dsv/src/dsv.js","webpack://DataModel/./node_modules/d3-dsv/src/index.js","webpack://DataModel/./node_modules/d3-dsv/src/tsv.js","webpack://DataModel/./src/constants/index.js","webpack://DataModel/./src/converter/dataConverterStore.js","webpack://DataModel/./src/converter/defaultConverters/autoConverter.js","webpack://DataModel/./src/converter/defaultConverters/dsvArrayConverter.js","webpack://DataModel/./src/converter/defaultConverters/dsvStringConverter.js","webpack://DataModel/./src/converter/defaultConverters/index.js","webpack://DataModel/./src/converter/defaultConverters/jsonConverter.js","webpack://DataModel/./src/converter/index.js","webpack://DataModel/./src/converter/model/dataConverter.js","webpack://DataModel/./src/converter/utils/auto-resolver.js","webpack://DataModel/./src/converter/utils/dsv-arr.js","webpack://DataModel/./src/converter/utils/dsv-str.js","webpack://DataModel/./src/converter/utils/flat-json.js","webpack://DataModel/./src/datamodel.js","webpack://DataModel/./src/default-config.js","webpack://DataModel/./src/enums/data-format.js","webpack://DataModel/./src/enums/dimension-subtype.js","webpack://DataModel/./src/enums/field-type.js","webpack://DataModel/./src/enums/filtering-mode.js","webpack://DataModel/./src/enums/group-by-functions.js","webpack://DataModel/./src/enums/index.js","webpack://DataModel/./src/enums/measure-subtype.js","webpack://DataModel/./src/export.js","webpack://DataModel/./src/field-creator.js","webpack://DataModel/./src/field-store.js","webpack://DataModel/./src/fields/binned/index.js","webpack://DataModel/./src/fields/categorical/index.js","webpack://DataModel/./src/fields/continuous/index.js","webpack://DataModel/./src/fields/dimension/index.js","webpack://DataModel/./src/fields/field-registry.js","webpack://DataModel/./src/fields/field/index.js","webpack://DataModel/./src/fields/index.js","webpack://DataModel/./src/fields/measure/index.js","webpack://DataModel/./src/fields/parsers/binned-parser/index.js","webpack://DataModel/./src/fields/parsers/categorical-parser/index.js","webpack://DataModel/./src/fields/parsers/continuous-parser/index.js","webpack://DataModel/./src/fields/parsers/field-parser/index.js","webpack://DataModel/./src/fields/parsers/temporal-parser/index.js","webpack://DataModel/./src/fields/partial-field/index.js","webpack://DataModel/./src/fields/temporal/index.js","webpack://DataModel/./src/helper.js","webpack://DataModel/./src/index.js","webpack://DataModel/./src/invalid-aware-types.js","webpack://DataModel/./src/operator/bucket-creator.js","webpack://DataModel/./src/operator/compose.js","webpack://DataModel/./src/operator/cross-product.js","webpack://DataModel/./src/operator/data-builder.js","webpack://DataModel/./src/operator/difference.js","webpack://DataModel/./src/operator/get-common-schema.js","webpack://DataModel/./src/operator/group-by-function.js","webpack://DataModel/./src/operator/group-by.js","webpack://DataModel/./src/operator/index.js","webpack://DataModel/./src/operator/merge-sort.js","webpack://DataModel/./src/operator/natural-join-filter-function.js","webpack://DataModel/./src/operator/natural-join.js","webpack://DataModel/./src/operator/outer-join.js","webpack://DataModel/./src/operator/pure-operators.js","webpack://DataModel/./src/operator/row-diffset-iterator.js","webpack://DataModel/./src/operator/sort.js","webpack://DataModel/./src/operator/union.js","webpack://DataModel/./src/relation.js","webpack://DataModel/./src/stats/index.js","webpack://DataModel/./src/utils/column-major.js","webpack://DataModel/./src/utils/date-time-formatter.js","webpack://DataModel/./src/utils/domain-generator.js","webpack://DataModel/./src/utils/extend2.js","webpack://DataModel/./src/utils/helper.js","webpack://DataModel/./src/utils/index.js","webpack://DataModel/./src/utils/reducer-store.js","webpack://DataModel/./src/value.js"],"names":["autoType","object","key","value","trim","number","NaN","isNaN","test","Date","csv","dsv","csvParse","parse","csvParseRows","parseRows","csvFormat","format","csvFormatBody","formatBody","csvFormatRows","formatRows","EOL","EOF","QUOTE","NEWLINE","RETURN","objectConverter","columns","Function","map","name","i","JSON","stringify","join","customConverter","f","row","inferColumns","rows","columnSet","Object","create","forEach","column","push","pad","width","s","length","Array","formatYear","year","formatDate","date","hours","getUTCHours","minutes","getUTCMinutes","seconds","getUTCSeconds","milliseconds","getUTCMilliseconds","getUTCFullYear","getUTCMonth","getUTCDate","delimiter","reFormat","RegExp","DELIMITER","charCodeAt","text","convert","N","I","n","t","eof","eol","token","j","c","slice","replace","preformatBody","formatValue","concat","formatRow","tsv","tsvParse","tsvParseRows","tsvFormat","tsvFormatBody","tsvFormatRows","PROPAGATION","ROW_ID","DM_DERIVATIVES","SELECT","PROJECT","GROUPBY","COMPOSE","CAL_VAR","BIN","SORT","JOINS","CROSS","LEFTOUTER","RIGHTOUTER","NATURAL","FULLOUTER","LOGICAL_OPERATORS","AND","OR","DataConverterStore","store","Map","converters","_getDefaultConverters","DSVStringConverter","DSVArrayConverter","JSONConverter","AutoDataConverter","set","converter","type","DataConverter","delete","has","get","converterStore","getStore","DataFormat","AUTO","data","schema","options","DSV_ARR","DSVArr","DSV_STR","DSVStr","FLAT_JSON","FlatJSON","_type","Error","Auto","dataFormat","detectDataFormat","arr","isArray","defaultOption","firstRowHeader","schemaFields","unitSchema","assign","columnMajor","headers","splice","headerMap","reduce","acc","h","fields","field","schemaField","headIndex","str","fieldSeparator","d3Dsv","header","insertionIndex","schemaFieldsName","item","keys","DataModel","args","_onPropagation","defOptions","order","formatter","withUid","getAllFields","sort","getPartialFieldspace","dataGenerated","dataBuilder","call","_rowDiffset","d","_colIdentifier","columnWise","addUid","uids","fieldNames","e","fmtFieldNames","fmtFieldIdx","next","idx","indexOf","elem","fIdx","fmtFn","datum","datumIdx","undefined","rowDiffset","ids","diffSets","split","Number","start","end","fill","_","fieldsArr","reducers","config","saveChild","groupByString","params","newDataModel","groupBy","persistDerivations","defaultReducer","reducerStore","setParent","sortingDetails","rawData","getData","dataInCSVArr","sortedDm","constructor","_dataFormat","getFieldspace","colData","formattedData","rowsCount","serializedData","rowIdx","colIdx","fieldName","partialFieldspace","_partialFieldspace","cachedValueObjects","_cachedValueObjects","partialField","fieldsObj","obj","Value","fieldIndex","findIndex","fieldinst","_cachedFieldsObj","_cachedDimension","_cachedMeasure","__calculateFieldspace","calculateFieldsConfig","dependency","sanitizeUnitSchema","replaceVar","fieldsConfig","getFieldsConfig","depVars","retrieveFn","depFieldIndices","fieldSpec","index","clone","fs","suppliedFields","cachedStore","cloneProvider","detachedRoot","computedValues","rowDiffsetIterator","fieldsData","createFields","addField","identifiers","addToNameSpace","propConfig","isMutableAction","propagationSourceId","sourceId","payload","rootModel","getRootDataModel","propagationNameSpace","_propagationNameSpace","rootGroupByModel","getRootGroupByModel","rootModels","groupByModel","model","addToPropNamespace","propagateToAllDataModels","propagateImmutableActions","eventName","callback","propModel","propListeners","fn","measureFieldName","binFieldName","measureField","createBinnedFieldData","binnedData","bins","binField","FieldType","DIMENSION","subtype","DimensionSubtype","BINNED","serialize","getSchema","dimensionArr","reducerFn","defConfig","mode","FilteringMode","NORMAL","splitWithSelect","uniqueFields","commonFields","fieldConfig","allFields","normalizedProjFieldSets","fieldSet","getNormalizedProFields","splitWithProject","InvalidAwareTypes","invalidAwareVals","fieldRegistry","Relation","CATEGORICAL","TEMPORAL","MEASURE","INVERSE","ALL","GROUP_BY_FUNCTIONS","SUM","AVG","MIN","MAX","FIRST","LAST","COUNT","STD","MeasureSubtype","CONTINUOUS","Operators","compose","bin","select","project","calculateVariable","crossProduct","difference","naturalJoin","leftOuterJoin","rightOuterJoin","fullOuterJoin","union","version","pkg","Stats","DateTimeFormatter","FieldsUtility","enums","createUnitField","BUILDER","build","createUnitFieldFromPartial","dataColumn","headersObj","fieldStore","createNamespace","fieldArr","dataId","getUniqueId","getMeasure","measureFields","getDimension","dimensionFields","Binned","binsArr","BinnedParser","Dimension","Categorical","hash","Set","domain","add","CategoricalParser","Continuous","min","POSITIVE_INFINITY","max","NEGATIVE_INFINITY","ContinuousParser","Measure","_cachedDomain","calculateDataDomain","Field","FieldTypeRegistry","_fieldType","dimension","registerDefaultFields","registerFieldType","Temporal","description","displayName","builder","_params","_context","PartialField","parser","unit","defAggFn","defaultReducerName","numberFormat","formatNumber","val","regex","String","result","isInvalid","matched","match","parseFloat","NA","getInvalidType","FieldParser","parsedVal","TemporalParser","_dtf","nativeDate","getNativeDate","getTime","_sanitize","_cachedMinDiff","sortedData","filter","a","b","arrLn","minDiff","prevDatum","nextDatum","processedCount","Math","isFinite","parsedDatum","formatAs","prepareSelectionData","resp","entries","prepareJoinData","formattedValue","rawValue","updateFields","fieldStoreName","colIdentifier","collID","partialFieldMap","newFields","coll","persistCurrentDerivation","operation","criteriaFn","_derivation","op","meta","criteria","persistAncestorDerivation","sourceDm","newDm","_ancestorDerivation","selectModeMap","diffIndex","calcDiff","generateRowDiffset","lastInsertedValue","li","selectRowDiffsetIterator","checker","lastInsertedValueSel","lastInsertedValueRej","newRowDiffSet","rejRowDiffSet","shouldSelect","shouldReject","checkerResult","rejectRowDiffset","rowSplitDiffsetIterator","fieldStoreObj","splitRowDiffset","dimensionMap","dimensionSet","selectHelper","clonedDm","selectFn","iterator","selectorHelperFn","cloneWithAllFields","getKey","len","keyFn","rowId","internalValue","boundsChecker","domainArr","some","dom","isWithinDomain","fieldType","filterPropagationModel","propModels","fns","filterByMeasure","clonedModel","modelFieldsConfig","range","values","dLen","valuesMap","rangeKeys","present","every","def","filteredModel","clonedDMs","cloned","derivation","derivationFormula","addDiffsetToClonedDm","selectConfig","cloneWithSelect","cloneConfig","extraCloneDm","setOfRowDiffsets","cloneWithProject","projField","projectionSet","actualProjField","projFieldSet","projFields","extend2","validateUnitSchema","sanitizeAndValidateSchema","resolveFieldName","dataHeader","fieldNameAs","as","updateData","relation","defaultConfig","nameSpace","valueObjects","rawFieldsData","formattedFieldsData","fieldInSchema","getDerivationArguments","applyExistingOperationOnModel","dataModel","derivations","getDerivations","selectionModel","getFilteredModel","path","propagateIdentifiers","propModelInf","nonTraversingModel","excludeModels","propagate","handlePropagation","children","_children","child","_parent","find","getPathToRootModel","propagationInf","propagateToSource","propagateInterpolatedValues","filterFn","entry","criterias","persistent","actionCriterias","mutableActions","filteredCriteria","action","sourceActionCriterias","actionInf","actionConf","applyOnSource","models","sourceIdentifiers","inf","propagationModel","reverse","immutableActions","filterImmutableAction","criteriaModel","sourceNamespace","normalizedProjField","search","from","getNumberFormattedVal","require","module","exports","default","_invalidAwareValsMap","_value","NULL","NIL","invalid","nil","null","generateBuckets","binSize","buckets","findBucketRange","bucketRanges","leftIdx","rightIdx","midIdx","floor","binsCount","dMin","dMax","ceil","abs","unshift","dm","operations","currentDM","firstChild","dispose","defaultFilterFn","dm1","dm2","replaceCommonSchema","jointype","applicableFilterFn","dm1FieldStore","dm2FieldStore","dm1FieldStoreName","dm2FieldStoreName","commonSchemaList","getCommonSchema","tmpSchema","rowAdded","rowPosition","ii","tuple","userArg","cloneProvider1","cloneProvider2","dm1Fields","dm2Fields","tupleObj","cellVal","iii","retObj","reqSorting","tmpDataArr","colIArr","colName","insertInd","sortData","tmpData","hashTable","schemaNameArr","dm1FieldStoreFieldObj","dm2FieldStoreFieldObj","isArrEqual","prepareDataHelper","addData","hashData","schemaName","fs1","fs2","retArr","fs1Arr","getFilteredValues","sum","filteredNumber","totalSum","curr","avg","filteredValues","first","last","count","variance","mean","num","std","sqrt","fnList","getFieldArr","dimensions","getReducerObj","measures","defReducer","measureName","resolve","existingDataModel","sFieldArr","reducerObj","dbName","measureArr","hashMap","rowCount","defSortFn","a1","b1","merge","lo","mid","hi","sortFn","mainArr","auxArr","mergeSort","naturalJoinFilter","commonSchemaArr","retainTuple","dataModel1","dataModel2","rowDiffArr","diffStr","diffStsArr","getSortFn","dataType","sortType","retFunc","resolveStrSortOrder","fDetails","strSortOrder","sortOrder","toLowerCase","groupData","groupedData","fieldVal","createSortingFnArg","groupedDatum","targetFields","targetFieldDetails","arg","label","applyStandardSort","sortMeta","isCallable","sortingFn","m","makeGroupMapAndSort","depColumns","targetCol","currRow","fVal","nMap","applyGroupSort","detail","sortedGroupMap","nextMap","shift","dataObj","sDetial","groupSortingIdx","standardSortingDetails","groupSortingDetails","pop","source","_fieldStoreName","_fieldspace","joinWith","unionWith","differenceWith","projectionClone","rejectionClone","_fieldConfig","fieldObj","removeChild","sibling","parent","sd","convertToNativeDate","escape","dtParams","TOKEN_PREFIX","DATETIME_PARAM_SEQUENCE","YEAR","MONTH","DAY","HOUR","MINUTE","SECOND","MILLISECOND","defaultNumberParser","defVal","parseInt","defaultRangeParser","l","nVal","getTokenDefinitions","daysDef","short","long","monthsDef","definitions","H","extract","getHours","toString","p","P","M","mins","getMinutes","S","getSeconds","K","ms","getMilliseconds","day","getDay","A","getDate","month","getMonth","B","y","substring","presentDate","presentYear","trunc","getFullYear","Y","getTokenFormalNames","HOUR_12","AMPM_UPPERCASE","AMPM_LOWERCASE","SHORT_DAY","LONG_DAY","DAY_OF_MONTH","DAY_OF_MONTH_CONSTANT_WIDTH","SHORT_MONTH","LONG_MONTH","MONTH_OF_YEAR","SHORT_YEAR","LONG_YEAR","tokenResolver","defaultResolver","targetParam","hourFormat24","hourFormat12","ampmLower","ampmUpper","amOrpm","isPM","findTokens","tokenPrefix","tokenLiterals","occurrence","forwardChar","nDate","formattedStr","formattedVal","prototype","dateTimeStamp","extractTokenValue","dtParamSeq","noBreak","dtParamArr","resolverKey","resolverParams","resolverFn","param","resolvedVal","hasOwnProperty","apply","checkIfOnlyYear","tokenObj","lastOccurrenceIndex","occObj","occIndex","targetText","regexFormat","tokenArr","occurrenceLength","extractValues","OBJECTSTRING","objectToStrFn","objectToStr","arrayToStr","checkCyclicRef","parentArr","bIndex","obj1","obj2","skipUndef","tgtArr","srcArr","srcVal","tgtVal","cRef","isObject","isString","uniqueValues","round","random","arr1","arr2","ReducerStore","reducer","__unregister","defineProperties","enumerable","configurable","writable","_formattedValue","_internalValue"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAe,SAASA,QAAT,CAAkBC,MAAlB,EAA0B;AACvC,OAAK,IAAIC,GAAT,IAAgBD,MAAhB,EAAwB;AACtB,QAAIE,QAAQF,OAAOC,GAAP,EAAYE,IAAZ,EAAZ;AAAA,QAAgCC,MAAhC;AACA,QAAI,CAACF,KAAL,EAAYA,QAAQ,IAAR,CAAZ,KACK,IAAIA,UAAU,MAAd,EAAsBA,QAAQ,IAAR,CAAtB,KACA,IAAIA,UAAU,OAAd,EAAuBA,QAAQ,KAAR,CAAvB,KACA,IAAIA,UAAU,KAAd,EAAqBA,QAAQG,GAAR,CAArB,KACA,IAAI,CAACC,MAAMF,SAAS,CAACF,KAAhB,CAAL,EAA6BA,QAAQE,MAAR,CAA7B,KACA,IAAI,8FAA8FG,IAA9F,CAAmGL,KAAnG,CAAJ,EAA+GA,QAAQ,IAAIM,IAAJ,CAASN,KAAT,CAAR,CAA/G,KACA;AACLF,WAAOC,GAAP,IAAcC,KAAd;AACD;AACD,SAAOF,MAAP;AACD,C;;;;;;;;;;;;ACbD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA,IAAIS,MAAMC,oDAAGA,CAAC,GAAJ,CAAV;;AAEO,IAAIC,WAAWF,IAAIG,KAAnB;AACA,IAAIC,eAAeJ,IAAIK,SAAvB;AACA,IAAIC,YAAYN,IAAIO,MAApB;AACA,IAAIC,gBAAgBR,IAAIS,UAAxB;AACA,IAAIC,gBAAgBV,IAAIW,UAAxB,C;;;;;;;;;;;;ACRP;AAAA,IAAIC,MAAM,EAAV;AAAA,IACIC,MAAM,EADV;AAAA,IAEIC,QAAQ,EAFZ;AAAA,IAGIC,UAAU,EAHd;AAAA,IAIIC,SAAS,EAJb;;AAMA,SAASC,eAAT,CAAyBC,OAAzB,EAAkC;AAChC,SAAO,IAAIC,QAAJ,CAAa,GAAb,EAAkB,aAAaD,QAAQE,GAAR,CAAY,UAASC,IAAT,EAAeC,CAAf,EAAkB;AAClE,WAAOC,KAAKC,SAAL,CAAeH,IAAf,IAAuB,MAAvB,GAAgCC,CAAhC,GAAoC,GAA3C;AACD,GAFqC,EAEnCG,IAFmC,CAE9B,GAF8B,CAAb,GAEV,GAFR,CAAP;AAGD;;AAED,SAASC,eAAT,CAAyBR,OAAzB,EAAkCS,CAAlC,EAAqC;AACnC,MAAIpC,SAAS0B,gBAAgBC,OAAhB,CAAb;AACA,SAAO,UAASU,GAAT,EAAcN,CAAd,EAAiB;AACtB,WAAOK,EAAEpC,OAAOqC,GAAP,CAAF,EAAeN,CAAf,EAAkBJ,OAAlB,CAAP;AACD,GAFD;AAGD;;AAED;AACA,SAASW,YAAT,CAAsBC,IAAtB,EAA4B;AAC1B,MAAIC,YAAYC,OAAOC,MAAP,CAAc,IAAd,CAAhB;AAAA,MACIf,UAAU,EADd;;AAGAY,OAAKI,OAAL,CAAa,UAASN,GAAT,EAAc;AACzB,SAAK,IAAIO,MAAT,IAAmBP,GAAnB,EAAwB;AACtB,UAAI,EAAEO,UAAUJ,SAAZ,CAAJ,EAA4B;AAC1Bb,gBAAQkB,IAAR,CAAaL,UAAUI,MAAV,IAAoBA,MAAjC;AACD;AACF;AACF,GAND;;AAQA,SAAOjB,OAAP;AACD;;AAED,SAASmB,GAAT,CAAa5C,KAAb,EAAoB6C,KAApB,EAA2B;AACzB,MAAIC,IAAI9C,QAAQ,EAAhB;AAAA,MAAoB+C,SAASD,EAAEC,MAA/B;AACA,SAAOA,SAASF,KAAT,GAAiB,IAAIG,KAAJ,CAAUH,QAAQE,MAAR,GAAiB,CAA3B,EAA8Bf,IAA9B,CAAmC,CAAnC,IAAwCc,CAAzD,GAA6DA,CAApE;AACD;;AAED,SAASG,UAAT,CAAoBC,IAApB,EAA0B;AACxB,SAAOA,OAAO,CAAP,GAAW,MAAMN,IAAI,CAACM,IAAL,EAAW,CAAX,CAAjB,GACHA,OAAO,IAAP,GAAc,MAAMN,IAAIM,IAAJ,EAAU,CAAV,CAApB,GACAN,IAAIM,IAAJ,EAAU,CAAV,CAFJ;AAGD;;AAED,SAASC,UAAT,CAAoBC,IAApB,EAA0B;AACxB,MAAIC,QAAQD,KAAKE,WAAL,EAAZ;AAAA,MACIC,UAAUH,KAAKI,aAAL,EADd;AAAA,MAEIC,UAAUL,KAAKM,aAAL,EAFd;AAAA,MAGIC,eAAeP,KAAKQ,kBAAL,EAHnB;AAIA,SAAOxD,MAAMgD,IAAN,IAAc,cAAd,GACDH,WAAWG,KAAKS,cAAL,EAAX,EAAkC,CAAlC,IAAuC,GAAvC,GAA6CjB,IAAIQ,KAAKU,WAAL,KAAqB,CAAzB,EAA4B,CAA5B,CAA7C,GAA8E,GAA9E,GAAoFlB,IAAIQ,KAAKW,UAAL,EAAJ,EAAuB,CAAvB,CAApF,IACCJ,eAAe,MAAMf,IAAIS,KAAJ,EAAW,CAAX,CAAN,GAAsB,GAAtB,GAA4BT,IAAIW,OAAJ,EAAa,CAAb,CAA5B,GAA8C,GAA9C,GAAoDX,IAAIa,OAAJ,EAAa,CAAb,CAApD,GAAsE,GAAtE,GAA4Eb,IAAIe,YAAJ,EAAkB,CAAlB,CAA5E,GAAmG,GAAlH,GACDF,UAAU,MAAMb,IAAIS,KAAJ,EAAW,CAAX,CAAN,GAAsB,GAAtB,GAA4BT,IAAIW,OAAJ,EAAa,CAAb,CAA5B,GAA8C,GAA9C,GAAoDX,IAAIa,OAAJ,EAAa,CAAb,CAApD,GAAsE,GAAhF,GACAF,WAAWF,KAAX,GAAmB,MAAMT,IAAIS,KAAJ,EAAW,CAAX,CAAN,GAAsB,GAAtB,GAA4BT,IAAIW,OAAJ,EAAa,CAAb,CAA5B,GAA8C,GAAjE,GACA,EAJA,CADN;AAMD;;AAEc,yEAASS,SAAT,EAAoB;AACjC,MAAIC,WAAW,IAAIC,MAAJ,CAAW,QAAQF,SAAR,GAAoB,OAA/B,CAAf;AAAA,MACIG,YAAYH,UAAUI,UAAV,CAAqB,CAArB,CADhB;;AAGA,WAAS1D,KAAT,CAAe2D,IAAf,EAAqBnC,CAArB,EAAwB;AACtB,QAAIoC,OAAJ;AAAA,QAAa7C,OAAb;AAAA,QAAsBY,OAAOzB,UAAUyD,IAAV,EAAgB,UAASlC,GAAT,EAAcN,CAAd,EAAiB;AAC5D,UAAIyC,OAAJ,EAAa,OAAOA,QAAQnC,GAAR,EAAaN,IAAI,CAAjB,CAAP;AACbJ,gBAAUU,GAAV,EAAemC,UAAUpC,IAAID,gBAAgBE,GAAhB,EAAqBD,CAArB,CAAJ,GAA8BV,gBAAgBW,GAAhB,CAAvD;AACD,KAH4B,CAA7B;AAIAE,SAAKZ,OAAL,GAAeA,WAAW,EAA1B;AACA,WAAOY,IAAP;AACD;;AAED,WAASzB,SAAT,CAAmByD,IAAnB,EAAyBnC,CAAzB,EAA4B;AAC1B,QAAIG,OAAO,EAAX;AAAA,QAAe;AACXkC,QAAIF,KAAKtB,MADb;AAAA,QAEIyB,IAAI,CAFR;AAAA,QAEW;AACPC,QAAI,CAHR;AAAA,QAGW;AACPC,KAJJ;AAAA,QAIO;AACHC,UAAMJ,KAAK,CALf;AAAA,QAKkB;AACdK,UAAM,KANV,CAD0B,CAOT;;AAEjB;AACA,QAAIP,KAAKD,UAAL,CAAgBG,IAAI,CAApB,MAA2BjD,OAA/B,EAAwC,EAAEiD,CAAF;AACxC,QAAIF,KAAKD,UAAL,CAAgBG,IAAI,CAApB,MAA2BhD,MAA/B,EAAuC,EAAEgD,CAAF;;AAEvC,aAASM,KAAT,GAAiB;AACf,UAAIF,GAAJ,EAAS,OAAOvD,GAAP;AACT,UAAIwD,GAAJ,EAAS,OAAOA,MAAM,KAAN,EAAazD,GAApB;;AAET;AACA,UAAIU,CAAJ;AAAA,UAAOiD,IAAIN,CAAX;AAAA,UAAcO,CAAd;AACA,UAAIV,KAAKD,UAAL,CAAgBU,CAAhB,MAAuBzD,KAA3B,EAAkC;AAChC,eAAOmD,MAAMD,CAAN,IAAWF,KAAKD,UAAL,CAAgBI,CAAhB,MAAuBnD,KAAlC,IAA2CgD,KAAKD,UAAL,CAAgB,EAAEI,CAAlB,MAAyBnD,KAA3E;AACA,YAAI,CAACQ,IAAI2C,CAAL,KAAWD,CAAf,EAAkBI,MAAM,IAAN,CAAlB,KACK,IAAI,CAACI,IAAIV,KAAKD,UAAL,CAAgBI,GAAhB,CAAL,MAA+BlD,OAAnC,EAA4CsD,MAAM,IAAN,CAA5C,KACA,IAAIG,MAAMxD,MAAV,EAAkB;AAAEqD,gBAAM,IAAN,CAAY,IAAIP,KAAKD,UAAL,CAAgBI,CAAhB,MAAuBlD,OAA3B,EAAoC,EAAEkD,CAAF;AAAM;AAC/E,eAAOH,KAAKW,KAAL,CAAWF,IAAI,CAAf,EAAkBjD,IAAI,CAAtB,EAAyBoD,OAAzB,CAAiC,KAAjC,EAAwC,IAAxC,CAAP;AACD;;AAED;AACA,aAAOT,IAAID,CAAX,EAAc;AACZ,YAAI,CAACQ,IAAIV,KAAKD,UAAL,CAAgBvC,IAAI2C,GAApB,CAAL,MAAmClD,OAAvC,EAAgDsD,MAAM,IAAN,CAAhD,KACK,IAAIG,MAAMxD,MAAV,EAAkB;AAAEqD,gBAAM,IAAN,CAAY,IAAIP,KAAKD,UAAL,CAAgBI,CAAhB,MAAuBlD,OAA3B,EAAoC,EAAEkD,CAAF;AAAM,SAA1E,MACA,IAAIO,MAAMZ,SAAV,EAAqB;AAC1B,eAAOE,KAAKW,KAAL,CAAWF,CAAX,EAAcjD,CAAd,CAAP;AACD;;AAED;AACA,aAAO8C,MAAM,IAAN,EAAYN,KAAKW,KAAL,CAAWF,CAAX,EAAcP,CAAd,CAAnB;AACD;;AAED,WAAO,CAACG,IAAIG,OAAL,MAAkBzD,GAAzB,EAA8B;AAC5B,UAAIe,MAAM,EAAV;AACA,aAAOuC,MAAMvD,GAAN,IAAauD,MAAMtD,GAA1B;AAA+Be,YAAIQ,IAAJ,CAAS+B,CAAT,GAAaA,IAAIG,OAAjB;AAA/B,OACA,IAAI3C,KAAK,CAACC,MAAMD,EAAEC,GAAF,EAAOsC,GAAP,CAAP,KAAuB,IAAhC,EAAsC;AACtCpC,WAAKM,IAAL,CAAUR,GAAV;AACD;;AAED,WAAOE,IAAP;AACD;;AAED,WAAS6C,aAAT,CAAuB7C,IAAvB,EAA6BZ,OAA7B,EAAsC;AACpC,WAAOY,KAAKV,GAAL,CAAS,UAASQ,GAAT,EAAc;AAC5B,aAAOV,QAAQE,GAAR,CAAY,UAASe,MAAT,EAAiB;AAClC,eAAOyC,YAAYhD,IAAIO,MAAJ,CAAZ,CAAP;AACD,OAFM,EAEJV,IAFI,CAECgC,SAFD,CAAP;AAGD,KAJM,CAAP;AAKD;;AAED,WAASlD,MAAT,CAAgBuB,IAAhB,EAAsBZ,OAAtB,EAA+B;AAC7B,QAAIA,WAAW,IAAf,EAAqBA,UAAUW,aAAaC,IAAb,CAAV;AACrB,WAAO,CAACZ,QAAQE,GAAR,CAAYwD,WAAZ,EAAyBnD,IAAzB,CAA8BgC,SAA9B,CAAD,EAA2CoB,MAA3C,CAAkDF,cAAc7C,IAAd,EAAoBZ,OAApB,CAAlD,EAAgFO,IAAhF,CAAqF,IAArF,CAAP;AACD;;AAED,WAAShB,UAAT,CAAoBqB,IAApB,EAA0BZ,OAA1B,EAAmC;AACjC,QAAIA,WAAW,IAAf,EAAqBA,UAAUW,aAAaC,IAAb,CAAV;AACrB,WAAO6C,cAAc7C,IAAd,EAAoBZ,OAApB,EAA6BO,IAA7B,CAAkC,IAAlC,CAAP;AACD;;AAED,WAASd,UAAT,CAAoBmB,IAApB,EAA0B;AACxB,WAAOA,KAAKV,GAAL,CAAS0D,SAAT,EAAoBrD,IAApB,CAAyB,IAAzB,CAAP;AACD;;AAED,WAASqD,SAAT,CAAmBlD,GAAnB,EAAwB;AACtB,WAAOA,IAAIR,GAAJ,CAAQwD,WAAR,EAAqBnD,IAArB,CAA0BgC,SAA1B,CAAP;AACD;;AAED,WAASmB,WAAT,CAAqBnF,KAArB,EAA4B;AAC1B,WAAOA,SAAS,IAAT,GAAgB,EAAhB,GACDA,iBAAiBM,IAAjB,GAAwB6C,WAAWnD,KAAX,CAAxB,GACAiE,SAAS5D,IAAT,CAAcL,SAAS,EAAvB,IAA6B,OAAOA,MAAMiF,OAAN,CAAc,IAAd,EAAoB,MAApB,CAAP,GAAqC,IAAlE,GACAjF,KAHN;AAID;;AAED,SAAO;AACLU,WAAOA,KADF;AAELE,eAAWA,SAFN;AAGLE,YAAQA,MAHH;AAILE,gBAAYA,UAJP;AAKLE,gBAAYA;AALP,GAAP;AAOD,C;;;;;;;;;;;;ACjKD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;;ACFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA,IAAIoE,MAAM9E,oDAAGA,CAAC,IAAJ,CAAV;;AAEO,IAAI+E,WAAWD,IAAI5E,KAAnB;AACA,IAAI8E,eAAeF,IAAI1E,SAAvB;AACA,IAAI6E,YAAYH,IAAIxE,MAApB;AACA,IAAI4E,gBAAgBJ,IAAItE,UAAxB;AACA,IAAI2E,gBAAgBL,IAAIpE,UAAxB,C;;;;;;;;;;;;;;;;;;;;;;;ACRP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAGO,IAAM0E,cAAc,aAApB;;AAEP;;;AAGO,IAAMC,SAAS,QAAf;;AAEP;;;AAGO,IAAMC,iBAAiB;AAC1BC,YAAQ,QADkB;AAE1BC,aAAS,SAFiB;AAG1BC,aAAS,OAHiB;AAI1BC,aAAS,SAJiB;AAK1BC,aAAS,oBALiB;AAM1BC,SAAK,KANqB;AAO1BC,UAAM;AAPoB,CAAvB;;AAUA,IAAMC,QAAQ;AACjBC,WAAO,OADU;AAEjBC,eAAW,WAFM;AAGjBC,gBAAY,YAHK;AAIjBC,aAAS,SAJQ;AAKjBC,eAAW;AALM,CAAd;;AAQA,IAAMC,oBAAoB;AAC7BC,SAAK,KADwB;AAE7BC,QAAI;AAFyB,CAA1B,C;;;;;;;;;;;;;;;;;;;AChCP;AACA;;IAEMC,kB;AACF,kCAAc;AAAA;;AACV,aAAKC,KAAL,GAAa,IAAIC,GAAJ,EAAb;AACA,aAAKC,UAAL,CAAgB,KAAKC,qBAAL,EAAhB;AACH;;;;gDAEuB;AACpB,mBAAO,CACH,IAAIC,qEAAJ,EADG,EAEH,IAAIC,oEAAJ,EAFG,EAGH,IAAIC,gEAAJ,EAHG,EAIH,IAAIC,oEAAJ,EAJG,CAAP;AAMH;;AAED;;;;;;;;qCAK4B;AAAA;;AAAA,gBAAjBL,WAAiB,uEAAJ,EAAI;;AACxBA,wBAAWzE,OAAX,CAAmB;AAAA,uBAAa,MAAKuE,KAAL,CAAWQ,GAAX,CAAeC,UAAUC,IAAzB,EAA+BD,SAA/B,CAAb;AAAA,aAAnB;AACA,mBAAO,KAAKT,KAAZ;AACH;;AAED;;;;;;;;iCAKSS,S,EAAW;AAChB,gBAAIA,qBAAqBE,4DAAzB,EAAwC;AACpC,qBAAKX,KAAL,CAAWQ,GAAX,CAAeC,UAAUC,IAAzB,EAA+BD,SAA/B;AACA,uBAAO,IAAP;AACH;AACD,mBAAO,IAAP;AACH;;AAED;;;;;;;;mCAMWA,S,EAAW;AAClB,iBAAKT,KAAL,CAAWY,MAAX,CAAkBH,UAAUC,IAA5B;AACA,mBAAO,IAAP;AACH;;;4BAEG9F,I,EAAM;AACN,gBAAI,KAAKoF,KAAL,CAAWa,GAAX,CAAejG,IAAf,CAAJ,EAA0B;AACtB,uBAAO,KAAKoF,KAAL,CAAWc,GAAX,CAAelG,IAAf,CAAP;AACH;AACD,mBAAO,IAAP;AACH;;;;;;AAIL,IAAMmG,iBAAkB,YAAY;AAChC,QAAIf,QAAQ,IAAZ;;AAEA,aAASgB,QAAT,GAAqB;AACjBhB,gBAAQ,IAAID,kBAAJ,EAAR;AACA,eAAOC,KAAP;AACH;AACD,WAAOA,SAASgB,UAAhB;AACH,CARuB,EAAxB;;AAUeD,6EAAf,E;;;;;;;;;;;;;;;;;;;;;;;;ACvEA;AACA;AACA;;IAEqBR,iB;;;AACjB,iCAAc;AAAA;;AAAA,qIACJU,0DAAUA,CAACC,IADP;AAEb;;;;gCAEOC,I,EAAMC,M,EAAQC,O,EAAS;AAC3B,mBAAOH,oEAAIA,CAACC,IAAL,EAAWC,MAAX,EAAmBC,OAAnB,CAAP;AACH;;;;EAP0CV,4D;;AAA1BJ,gF;;;;;;;;;;;;;;;;;;;;;;;;ACJrB;AACA;AACA;;IAEqBF,iB;;;AACjB,iCAAc;AAAA;;AAAA,qIACJY,0DAAUA,CAACK,OADP;AAEb;;;;gCAEOH,I,EAAMC,M,EAAQC,O,EAAS;AAC3B,mBAAOE,8DAAMA,CAACJ,IAAP,EAAaC,MAAb,EAAqBC,OAArB,CAAP;AACH;;;;EAP0CV,4D;;AAA1BN,gF;;;;;;;;;;;;;;;;;;;;;;;;ACJrB;AACA;AACA;;IAEqBD,kB;;;AACjB,kCAAc;AAAA;;AAAA,uIACJa,0DAAUA,CAACO,OADP;AAEb;;;;gCAEOL,I,EAAMC,M,EAAQC,O,EAAS;AAC3B,mBAAOI,8DAAMA,CAACN,IAAP,EAAaC,MAAb,EAAqBC,OAArB,CAAP;AACH;;;;EAP2CV,4D;;AAA3BP,iF;;;;;;;;;;;;ACJrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACFA;AACA;AACA;;IAEqBE,a;;;AACjB,6BAAc;AAAA;;AAAA,6HACJW,0DAAUA,CAACS,SADP;AAEb;;;;gCAEOP,I,EAAMC,M,EAAQC,O,EAAS;AAC3B,mBAAOM,gEAAQA,CAACR,IAAT,EAAeC,MAAf,EAAuBC,OAAvB,CAAP;AACH;;;;EAPsCV,4D;;AAAtBL,4E;;;;;;;;;;;;ACJrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;ACDA;;;IAGqBK,a;AACjB,2BAAYD,IAAZ,EAAkB;AAAA;;AACd,aAAKkB,KAAL,GAAalB,IAAb;AACH;;;;kCAMS;AACN,kBAAM,IAAImB,KAAJ,CAAU,iCAAV,CAAN;AACH;;;4BANU;AACP,mBAAO,KAAKD,KAAZ;AACH;;;;;;AAPgBjB,4E;;;;;;;;;;;;ACHrB;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;AAEA;;;;;;;AAOA,SAASmB,IAAT,CAAeX,IAAf,EAAqBC,MAArB,EAA6BC,OAA7B,EAAsC;AAClC,QAAMnB,aAAa,EAAEyB,4DAAF,EAAYF,wDAAZ,EAAoBF,wDAApB,EAAnB;AACA,QAAMQ,aAAaC,+DAAgBA,CAACb,IAAjB,CAAnB;;AAEA,QAAI,CAACY,UAAL,EAAiB;AACb,cAAM,IAAIF,KAAJ,CAAU,kCAAV,CAAN;AACH;;AAED,WAAO3B,WAAW6B,UAAX,EAAuBZ,IAAvB,EAA6BC,MAA7B,EAAqCC,OAArC,CAAP;AACH;;AAEcS,mEAAf,E;;;;;;;;;;;;;;;;ACvBA;;AAEA;;;;;;;;;;;;;;;;;AAiBA,SAASP,MAAT,CAAgBU,GAAhB,EAAqBb,MAArB,EAA6BC,OAA7B,EAAsC;AAClC,QAAI,CAACrF,MAAMkG,OAAN,CAAcd,MAAd,CAAL,EAA4B;AACxB,cAAM,IAAIS,KAAJ,CAAU,+CAAV,CAAN;AACH;AACD,QAAMM,gBAAgB;AAClBC,wBAAgB;AADE,KAAtB;AAGA,QAAMC,eAAejB,OAAOzG,GAAP,CAAW;AAAA,eAAc2H,WAAW1H,IAAzB;AAAA,KAAX,CAArB;AACAyG,cAAU9F,OAAOgH,MAAP,CAAc,EAAd,EAAkBJ,aAAlB,EAAiCd,OAAjC,CAAV;;AAEA,QAAM5G,UAAU,EAAhB;AACA,QAAMkB,OAAO6G,0DAAWA,CAAC/H,OAAZ,CAAb;;AAEA,QAAIgI,UAAUJ,YAAd;AACA,QAAIhB,QAAQe,cAAZ,EAA4B;AACxB;AACA;AACAK,kBAAUR,IAAIS,MAAJ,CAAW,CAAX,EAAc,CAAd,EAAiB,CAAjB,CAAV;AACH;AACD;AACA,QAAMC,YAAYF,QAAQG,MAAR,CAAe,UAACC,GAAD,EAAMC,CAAN,EAASjI,CAAT;AAAA,eAC7BU,OAAOgH,MAAP,CAAcM,GAAd,sBAAsBC,CAAtB,EAA0BjI,CAA1B,EAD6B;AAAA,KAAf,EAEf,EAFe,CAAlB;;AAIAoH,QAAIxG,OAAJ,CAAY,UAACsH,MAAD,EAAY;AACpB,YAAMC,QAAQ,EAAd;AACAX,qBAAa5G,OAAb,CAAqB,UAACwH,WAAD,EAAiB;AAClC,gBAAMC,YAAYP,UAAUM,WAAV,CAAlB;AACAD,kBAAMrH,IAAN,CAAWoH,OAAOG,SAAP,CAAX;AACH,SAHD;AAIA,eAAOvH,sBAAQqH,KAAR,CAAP;AACH,KAPD;AAQA,WAAO,CAACX,YAAD,EAAe5H,OAAf,CAAP;AACH;;AAEc8G,qEAAf,E;;;;;;;;;;;;ACtDA;AAAA;AAAA;AAAA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;AAqBA,SAASE,MAAT,CAAiB0B,GAAjB,EAAsB/B,MAAtB,EAA8BC,OAA9B,EAAuC;AACnC,QAAMc,gBAAgB;AAClBC,wBAAgB,IADE;AAElBgB,wBAAgB;AAFE,KAAtB;AAIA/B,cAAU9F,OAAOgH,MAAP,CAAc,EAAd,EAAkBJ,aAAlB,EAAiCd,OAAjC,CAAV;;AAEA,QAAM7H,MAAM6J,wDAAKA,CAAChC,QAAQ+B,cAAd,CAAZ;AACA,WAAO7B,wDAAMA,CAAC/H,IAAII,SAAJ,CAAcuJ,GAAd,CAAP,EAA2B/B,MAA3B,EAAmCC,OAAnC,CAAP;AACH;;AAEcI,qEAAf,E;;;;;;;;;;;;ACnCA;AAAA;AAAA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA,SAASE,QAAT,CAAmBM,GAAnB,EAAwBb,MAAxB,EAAgC;AAC5B,QAAI,CAACpF,MAAMkG,OAAN,CAAcd,MAAd,CAAL,EAA4B;AACxB,cAAM,IAAIS,KAAJ,CAAU,+CAAV,CAAN;AACH;;AAED,QAAMyB,SAAS,EAAf;AACA,QAAIzI,IAAI,CAAR;AACA,QAAI0I,uBAAJ;AACA,QAAM9I,UAAU,EAAhB;AACA,QAAMkB,OAAO6G,0DAAWA,CAAC/H,OAAZ,CAAb;AACA,QAAM+I,mBAAmBpC,OAAOzG,GAAP,CAAW;AAAA,eAAc2H,WAAW1H,IAAzB;AAAA,KAAX,CAAzB;;AAEAqH,QAAIxG,OAAJ,CAAY,UAACgI,IAAD,EAAU;AAClB,YAAMV,SAAS,EAAf;AACAS,yBAAiB/H,OAAjB,CAAyB,UAAC6G,UAAD,EAAgB;AACrC,gBAAIA,cAAcgB,MAAlB,EAA0B;AACtBC,iCAAiBD,OAAOhB,UAAP,CAAjB;AACH,aAFD,MAEO;AACHgB,uBAAOhB,UAAP,IAAqBzH,GAArB;AACA0I,iCAAiB1I,IAAI,CAArB;AACH;AACDkI,mBAAOQ,cAAP,IAAyBE,KAAKnB,UAAL,CAAzB;AACH,SARD;AASA3G,8BAAQoH,MAAR;AACH,KAZD;;AAcA,WAAO,CAACxH,OAAOmI,IAAP,CAAYJ,MAAZ,CAAD,EAAsB7I,OAAtB,CAAP;AACH;;AAEckH,uEAAf,E;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzDA;;AAEA;AACA;AAYA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;IAYMgC,S;;;AACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCA,yBAAsB;AAAA;;AAAA;;AAAA,0CAANC,IAAM;AAANA,gBAAM;AAAA;;AAAA,qJACTA,IADS;;AAGlB,cAAKC,cAAL,GAAsB,EAAtB;AAHkB;AAIrB;;AAED;;;;;;;;;;;;;;;AA0CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gCAgCSxC,O,EAAS;AACd,gBAAMyC,aAAa;AACfC,uBAAO,KADQ;AAEfC,2BAAW,IAFI;AAGfC,yBAAS,KAHM;AAIfC,8BAAc,KAJC;AAKfC,sBAAM;AALS,aAAnB;AAOA9C,sBAAU9F,OAAOgH,MAAP,CAAc,EAAd,EAAkBuB,UAAlB,EAA8BzC,OAA9B,CAAV;AACA,gBAAM0B,SAAS,KAAKqB,oBAAL,GAA4BrB,MAA3C;;AAEA,gBAAMsB,gBAAgBC,qDAAWA,CAACC,IAAZ,CAClB,IADkB,EAElB,KAAKH,oBAAL,GAA4BrB,MAFV,EAGlB,KAAKyB,WAHa,EAIlBnD,QAAQ6C,YAAR,GAAuBnB,OAAOpI,GAAP,CAAW;AAAA,uBAAK8J,EAAE7J,IAAF,EAAL;AAAA,aAAX,EAA0BI,IAA1B,EAAvB,GAA0D,KAAK0J,cAJ7C,EAKlBrD,QAAQ8C,IALU,EAMlB;AACIQ,4BAAYtD,QAAQ0C,KAAR,KAAkB,QADlC;AAEIa,wBAAQ,CAAC,CAACvD,QAAQ4C;AAFtB,aANkB,CAAtB;;AAYA,gBAAI,CAAC5C,QAAQ2C,SAAb,EAAwB;AACpB,uBAAOK,aAAP;AACH;;AAzBa,2BA2BQhD,OA3BR;AAAA,gBA2BN2C,SA3BM,YA2BNA,SA3BM;AAAA,gBA4BN7C,IA5BM,GA4BiBkD,aA5BjB,CA4BNlD,IA5BM;AAAA,gBA4BAC,MA5BA,GA4BiBiD,aA5BjB,CA4BAjD,MA5BA;AAAA,gBA4BQyD,IA5BR,GA4BiBR,aA5BjB,CA4BQQ,IA5BR;;AA6Bd,gBAAMC,aAAa1D,OAAOzG,GAAP,CAAY;AAAA,uBAAKoK,EAAEnK,IAAP;AAAA,aAAZ,CAAnB;AACA,gBAAMoK,gBAAgBzJ,OAAOmI,IAAP,CAAYM,SAAZ,CAAtB;AACA,gBAAMiB,cAAcD,cAAcpC,MAAd,CAAqB,UAACC,GAAD,EAAMqC,IAAN,EAAe;AACpD,oBAAMC,MAAML,WAAWM,OAAX,CAAmBF,IAAnB,CAAZ;AACA,oBAAIC,QAAQ,CAAC,CAAb,EAAgB;AACZtC,wBAAIlH,IAAJ,CAAS,CAACwJ,GAAD,EAAMnB,UAAUkB,IAAV,CAAN,CAAT;AACH;AACD,uBAAOrC,GAAP;AACH,aANmB,EAMjB,EANiB,CAApB;;AAQA,gBAAIxB,QAAQ0C,KAAR,KAAkB,QAAtB,EAAgC;AAC5BkB,4BAAYxJ,OAAZ,CAAoB,UAAC4J,IAAD,EAAU;AAC1B,wBAAMC,OAAOD,KAAK,CAAL,CAAb;AACA,wBAAME,QAAQF,KAAK,CAAL,CAAd;;AAEAlE,yBAAKmE,IAAL,EAAW7J,OAAX,CAAmB,UAAC+J,KAAD,EAAQC,QAAR,EAAqB;AACpCtE,6BAAKmE,IAAL,EAAWG,QAAX,IAAuBF,MAAMhB,IAAN,CACnBmB,SADmB,EAEnBF,KAFmB,EAGnBX,KAAKY,QAAL,CAHmB,EAInBrE,OAAOkE,IAAP,CAJmB,CAAvB;AAMH,qBAPD;AAQH,iBAZD;AAaH,aAdD,MAcO;AACHnE,qBAAK1F,OAAL,CAAa,UAAC+J,KAAD,EAAQC,QAAR,EAAqB;AAC9BR,gCAAYxJ,OAAZ,CAAoB,UAAC4J,IAAD,EAAU;AAC1B,4BAAMC,OAAOD,KAAK,CAAL,CAAb;AACA,4BAAME,QAAQF,KAAK,CAAL,CAAd;;AAEAG,8BAAMF,IAAN,IAAcC,MAAMhB,IAAN,CACVmB,SADU,EAEVF,MAAMF,IAAN,CAFU,EAGVT,KAAKY,QAAL,CAHU,EAIVrE,OAAOkE,IAAP,CAJU,CAAd;AAMH,qBAVD;AAWH,iBAZD;AAaH;;AAED,mBAAOjB,aAAP;AACH;;AAED;;;;;;;;kCAKW;AACP,gBAAMsB,aAAa,KAAKnB,WAAxB;AACA,gBAAMoB,MAAM,EAAZ;;AAEA,gBAAID,WAAW5J,MAAf,EAAuB;AACnB,oBAAM8J,WAAWF,WAAWG,KAAX,CAAiB,GAAjB,CAAjB;;AAEAD,yBAASpK,OAAT,CAAiB,UAAC+E,GAAD,EAAS;AAAA,yCACHA,IAAIsF,KAAJ,CAAU,GAAV,EAAenL,GAAf,CAAmBoL,MAAnB,CADG;AAAA;AAAA,wBACjBC,KADiB;AAAA,wBACVC,GADU;;AAGtBA,0BAAMA,QAAQP,SAAR,GAAoBO,GAApB,GAA0BD,KAAhC;AACAJ,wBAAIjK,IAAJ,+BAAYK,MAAMiK,MAAMD,KAAN,GAAc,CAApB,EAAuBE,IAAvB,GAA8BvL,GAA9B,CAAkC,UAACwL,CAAD,EAAIhB,GAAJ;AAAA,+BAAYa,QAAQb,GAApB;AAAA,qBAAlC,CAAZ;AACH,iBALD;AAMH;;AAED,mBAAOS,GAAP;AACH;AACD;;;;;;;;;;;;;;;;;;;;;;;;;;;gCAwBSQ,S,EAAwD;AAAA,gBAA7CC,QAA6C,uEAAlC,EAAkC;AAAA,gBAA9BC,MAA8B,uEAArB,EAAEC,WAAW,IAAb,EAAqB;;AAC7D,gBAAMC,qBAAmBJ,UAAUpL,IAAV,EAAzB;AACA,gBAAIyL,SAAS,CAAC,IAAD,EAAOL,SAAP,EAAkBC,QAAlB,CAAb;AACA,gBAAMK,eAAeC,mEAAWF,MAAX,CAArB;;AAEAG,8EAAkBA,CACd,IADJ,EAEIF,YAFJ,EAGI5H,yDAAcA,CAACG,OAHnB,EAII,EAAEmH,oBAAF,EAAaI,4BAAb,EAA4BK,gBAAgBC,4DAAYA,CAACD,cAAb,EAA5C,EAJJ,EAKIR,QALJ;;AAQA,gBAAIC,OAAOC,SAAX,EAAsB;AAClBG,6BAAaK,SAAb,CAAuB,IAAvB;AACH,aAFD,MAEO;AACHL,6BAAaK,SAAb,CAAuB,IAAvB;AACH;;AAED,mBAAOL,YAAP;AACH;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6BAmDMM,c,EAA+C;AAAA,gBAA/BV,MAA+B,uEAAtB,EAAEC,WAAW,KAAb,EAAsB;;AACjD,gBAAMU,UAAU,KAAKC,OAAL,CAAa;AACzBnD,uBAAO,KADkB;AAEzBI,sBAAM6C;AAFmB,aAAb,CAAhB;AAIA,gBAAM1D,SAAS2D,QAAQ7F,MAAR,CAAezG,GAAf,CAAmB;AAAA,uBAASqI,MAAMpI,IAAf;AAAA,aAAnB,CAAf;AACA,gBAAMuM,eAAe,CAAC7D,MAAD,EAASlF,MAAT,CAAgB6I,QAAQ9F,IAAxB,CAArB;;AAEA,gBAAMiG,WAAW,IAAI,KAAKC,WAAT,CAAqBF,YAArB,EAAmCF,QAAQ7F,MAA3C,EAAmD,EAAEW,YAAY,QAAd,EAAnD,CAAjB;;AAEA6E,8EAAkBA,CACd,IADJ,EAEIQ,QAFJ,EAGItI,yDAAcA,CAACO,IAHnB,EAIIiH,MAJJ,EAKIU,cALJ;;AAQA,gBAAIV,OAAOC,SAAX,EAAsB;AAClBa,yBAASL,SAAT,CAAmB,IAAnB;AACH,aAFD,MAEO;AACHK,yBAASL,SAAT,CAAmB,IAAnB;AACH;;AAED,mBAAOK,QAAP;AACH;;AAED;;;;;;;;;;;;;;;;;;;;;;;;kCAqBW1G,I,EAAMW,O,EAAS;AACtBX,mBAAOA,QAAQ,KAAK4G,WAApB;AACAjG,sBAAU9F,OAAOgH,MAAP,CAAc,EAAd,EAAkB,EAAEa,gBAAgB,GAAlB,EAAlB,EAA2C/B,OAA3C,CAAV;;AAEA,gBAAM0B,SAAS,KAAKwE,aAAL,GAAqBxE,MAApC;AACA,gBAAMyE,UAAUzE,OAAOpI,GAAP,CAAW;AAAA,uBAAKO,EAAEuM,aAAF,EAAL;AAAA,aAAX,CAAhB;AACA,gBAAMC,YAAYF,QAAQ,CAAR,EAAWzL,MAA7B;AACA,gBAAI4L,uBAAJ;AACA,gBAAIC,eAAJ;AACA,gBAAIC,eAAJ;;AAEA,gBAAInH,SAASO,iDAAUA,CAACS,SAAxB,EAAmC;AAC/BiG,iCAAiB,EAAjB;AACA,qBAAKC,SAAS,CAAd,EAAiBA,SAASF,SAA1B,EAAqCE,QAArC,EAA+C;AAC3C,wBAAMzM,MAAM,EAAZ;AACA,yBAAK0M,SAAS,CAAd,EAAiBA,SAAS9E,OAAOhH,MAAjC,EAAyC8L,QAAzC,EAAmD;AAC/C1M,4BAAI4H,OAAO8E,MAAP,EAAejN,IAAf,EAAJ,IAA6B4M,QAAQK,MAAR,EAAgBD,MAAhB,CAA7B;AACH;AACDD,mCAAehM,IAAf,CAAoBR,GAApB;AACH;AACJ,aATD,MASO,IAAIuF,SAASO,iDAAUA,CAACO,OAAxB,EAAiC;AACpCmG,iCAAiB,CAAC5E,OAAOpI,GAAP,CAAW;AAAA,2BAAKO,EAAEN,IAAF,EAAL;AAAA,iBAAX,EAA0BI,IAA1B,CAA+BqG,QAAQ+B,cAAvC,CAAD,CAAjB;AACA,qBAAKwE,SAAS,CAAd,EAAiBA,SAASF,SAA1B,EAAqCE,QAArC,EAA+C;AAC3C,wBAAMzM,OAAM,EAAZ;AACA,yBAAK0M,SAAS,CAAd,EAAiBA,SAAS9E,OAAOhH,MAAjC,EAAyC8L,QAAzC,EAAmD;AAC/C1M,6BAAIQ,IAAJ,CAAS6L,QAAQK,MAAR,EAAgBD,MAAhB,CAAT;AACH;AACDD,mCAAehM,IAAf,CAAoBR,KAAIH,IAAJ,CAASqG,QAAQ+B,cAAjB,CAApB;AACH;AACDuE,iCAAiBA,eAAe3M,IAAf,CAAoB,IAApB,CAAjB;AACH,aAVM,MAUA,IAAI0F,SAASO,iDAAUA,CAACK,OAAxB,EAAiC;AACpCqG,iCAAiB,CAAC5E,OAAOpI,GAAP,CAAW;AAAA,2BAAKO,EAAEN,IAAF,EAAL;AAAA,iBAAX,CAAD,CAAjB;AACA,qBAAKgN,SAAS,CAAd,EAAiBA,SAASF,SAA1B,EAAqCE,QAArC,EAA+C;AAC3C,wBAAMzM,QAAM,EAAZ;AACA,yBAAK0M,SAAS,CAAd,EAAiBA,SAAS9E,OAAOhH,MAAjC,EAAyC8L,QAAzC,EAAmD;AAC/C1M,8BAAIQ,IAAJ,CAAS6L,QAAQK,MAAR,EAAgBD,MAAhB,CAAT;AACH;AACDD,mCAAehM,IAAf,CAAoBR,KAApB;AACH;AACJ,aATM,MASA;AACH,sBAAM,IAAI0G,KAAJ,gBAAuBnB,IAAvB,uBAAN;AACH;;AAED,mBAAOiH,cAAP;AACH;;;iCAES3E,K,EAAO;AACb,gBAAM8E,YAAY9E,MAAMpI,IAAN,EAAlB;AACA,iBAAK8J,cAAL,UAA2BoD,SAA3B;AACA,gBAAMC,oBAAoB,KAAKC,kBAA/B;AACA,gBAAMC,qBAAqBF,kBAAkBG,mBAA7C;AACA,gBAAMT,gBAAgBzE,MAAMyE,aAAN,EAAtB;AACA,gBAAMR,UAAUjE,MAAMmF,YAAN,CAAmBhH,IAAnC;;AAEA,gBAAI,CAAC4G,kBAAkBK,SAAlB,GAA8BpF,MAAMpI,IAAN,EAA9B,CAAL,EAAkD;AAC9CmN,kCAAkBhF,MAAlB,CAAyBpH,IAAzB,CAA8BqH,KAA9B;AACAiF,mCAAmBxM,OAAnB,CAA2B,UAAC4M,GAAD,EAAMxN,CAAN,EAAY;AACnCwN,wBAAIrF,MAAMpI,IAAN,EAAJ,IAAoB,IAAI0N,8CAAJ,CAAUb,cAAc5M,CAAd,CAAV,EAA4BoM,QAAQpM,CAAR,CAA5B,EAAwCmI,KAAxC,CAApB;AACH,iBAFD;AAGH,aALD,MAKO;AACH,oBAAMuF,aAAaR,kBAAkBhF,MAAlB,CAAyByF,SAAzB,CAAmC;AAAA,2BAAaC,UAAU7N,IAAV,OAAqBkN,SAAlC;AAAA,iBAAnC,CAAnB;AACAS,8BAAc,CAAd,KAAoBR,kBAAkBhF,MAAlB,CAAyBwF,UAAzB,IAAuCvF,KAA3D;AACH;;AAED;AACA+E,8BAAkBW,gBAAlB,GAAqC,IAArC;AACAX,8BAAkBY,gBAAlB,GAAqC,IAArC;AACAZ,8BAAkBa,cAAlB,GAAmC,IAAnC;;AAEA,iBAAKC,qBAAL,GAA6BC,qBAA7B;AACA,mBAAO,IAAP;AACH;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0CAoCmB1H,M,EAAQ2H,U,EAAYzC,M,EAAQ;AAAA;;AAC3ClF,qBAAS4H,kEAAkBA,CAAC5H,MAAnB,CAAT;AACAkF,qBAAS/K,OAAOgH,MAAP,CAAc,EAAd,EAAkB,EAAEgE,WAAW,IAAb,EAAmB0C,YAAY,KAA/B,EAAlB,EAA0D3C,MAA1D,CAAT;;AAEA,gBAAM4C,eAAe,KAAKC,eAAL,EAArB;AACA,gBAAMC,UAAUL,WAAW/K,KAAX,CAAiB,CAAjB,EAAoB+K,WAAWhN,MAAX,GAAoB,CAAxC,CAAhB;AACA,gBAAMsN,aAAaN,WAAWA,WAAWhN,MAAX,GAAoB,CAA/B,CAAnB;;AAEA,gBAAImN,aAAa9H,OAAOxG,IAApB,KAA6B,CAAC0L,OAAO2C,UAAzC,EAAqD;AACjD,sBAAM,IAAIpH,KAAJ,CAAaT,OAAOxG,IAApB,wCAAN;AACH;;AAED,gBAAM0O,kBAAkBF,QAAQzO,GAAR,CAAY,UAACqI,KAAD,EAAW;AAC3C,oBAAMuG,YAAYL,aAAalG,KAAb,CAAlB;AACA,oBAAI,CAACuG,SAAL,EAAgB;AACZ;AACA,0BAAM,IAAI1H,KAAJ,CAAamB,KAAb,kCAAN;AACH;AACD,uBAAOuG,UAAUC,KAAjB;AACH,aAPuB,CAAxB;;AASA,gBAAMC,QAAQ,KAAKA,KAAL,CAAWnD,OAAOC,SAAlB,CAAd;;AAEA,gBAAMmD,KAAKD,MAAMlC,aAAN,GAAsBxE,MAAjC;AACA,gBAAM4G,iBAAiBL,gBAAgB3O,GAAhB,CAAoB;AAAA,uBAAO+O,GAAGvE,GAAH,CAAP;AAAA,aAApB,CAAvB;;AAEA,gBAAIyE,cAAc,EAAlB;AACA,gBAAIC,gBAAgB,SAAhBA,aAAgB;AAAA,uBAAM,OAAKC,YAAL,EAAN;AAAA,aAApB;;AAEA,gBAAMC,iBAAiB,EAAvB;AACAC,gFAAkBA,CAACP,MAAMjF,WAAzB,EAAsC,UAAC3J,CAAD,EAAO;AACzC,oBAAMoP,aAAaN,eAAehP,GAAf,CAAmB;AAAA,2BAASqI,MAAMmF,YAAN,CAAmBhH,IAAnB,CAAwBtG,CAAxB,CAAT;AAAA,iBAAnB,CAAnB;AACAkP,+BAAelP,CAAf,IAAoBwO,+CAAcY,UAAd,UAA0BpP,CAA1B,EAA6BgP,aAA7B,EAA4CD,WAA5C,GAApB;AACH,aAHD;;AA9B2C,gCAkC3BM,mEAAYA,CAAC,CAACH,cAAD,CAAb,EAA+B,CAAC3I,MAAD,CAA/B,EAAyC,CAACA,OAAOxG,IAAR,CAAzC,CAlC2B;AAAA;AAAA,gBAkCpCoI,KAlCoC;;AAmC3CyG,kBAAMU,QAAN,CAAenH,KAAf;;AAEA4D,8EAAkBA,CACd,IADJ,EAEI6C,KAFJ,EAGI3K,yDAAcA,CAACK,OAHnB,EAII,EAAEmH,QAAQlF,MAAV,EAAkB2B,QAAQqG,OAA1B,EAJJ,EAKIC,UALJ;;AAQA,mBAAOI,KAAP;AACH;;AAED;;;;;;;;;;;kCAQWW,W,EAA2D;AAAA,gBAA9C9D,MAA8C,uEAArC,EAAqC;AAAA,gBAAjC+D,cAAiC;AAAA,gBAAjBC,UAAiB,uEAAJ,EAAI;;AAClE,gBAAMC,kBAAkBjE,OAAOiE,eAA/B;AACA,gBAAMC,sBAAsBlE,OAAOmE,QAAnC;AACA,gBAAMC,UAAUpE,OAAOoE,OAAvB;AACA,gBAAMC,YAAYC,gEAAgBA,CAAC,IAAjB,CAAlB;AACA,gBAAMC,uBAAuBF,UAAUG,qBAAvC;AACA,gBAAMC,mBAAmBC,mEAAmBA,CAAC,IAApB,CAAzB;AACA,gBAAMC,aAAa;AACfC,8BAAcH,gBADC;AAEfI,uBAAOR;AAFQ,aAAnB;;AAKAN,8BAAkBe,kEAAkBA,CAACP,oBAAnB,EAAyCvE,MAAzC,EAAiD,IAAjD,CAAlB;AACA+E,oFAAwBA,CAACjB,WAAzB,EAAsCa,UAAtC,EAAkD,EAAEJ,0CAAF,EAAwBJ,UAAUD,mBAAlC,EAAlD,EACIjP,OAAOgH,MAAP,CAAc;AACVmI;AADU,aAAd,EAEGpE,MAFH,CADJ;;AAKA,gBAAIiE,eAAJ,EAAqB;AACjBe,yFAAyBA,CAACT,oBAA1B,EAAgDI,UAAhD,EAA4D;AACxD3E,kCADwD;AAExDgE;AAFwD,iBAA5D,EAGG,IAHH;AAIH;;AAED,mBAAO,IAAP;AACH;;AAED;;;;;;;;;;2BAOIiB,S,EAAWC,Q,EAAU;AACrB,oBAAQD,SAAR;AACA,qBAAK3M,sDAAL;AACI,yBAAKiF,cAAL,CAAoBlI,IAApB,CAAyB6P,QAAzB;AACA;AAHJ;AAKA,mBAAO,IAAP;AACH;;AAED;;;;;;;;;oCAMaD,S,EAAW;AACpB,oBAAQA,SAAR;AACA,qBAAK3M,sDAAL;AACI,yBAAKiF,cAAL,GAAsB,EAAtB;AACA;;AAHJ;AAMA,mBAAO,IAAP;AACH;;AAED;;;;;;;;;;0CAOmB4H,S,EAAWf,O,EAAS;AAAA;;AACnC,gBAAIgB,gBAAgB,KAAK7H,cAAzB;AACA6H,0BAAcjQ,OAAd,CAAsB;AAAA,uBAAMkQ,GAAGpH,IAAH,CAAQ,MAAR,EAAckH,SAAd,EAAyBf,OAAzB,CAAN;AAAA,aAAtB;AACH;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4BA2CKkB,gB,EAAkBtF,M,EAAQ;AAC3B,gBAAM4C,eAAe,KAAKC,eAAL,EAArB;;AAEA,gBAAI,CAACD,aAAa0C,gBAAb,CAAL,EAAqC;AACjC,sBAAM,IAAI/J,KAAJ,YAAmB+J,gBAAnB,qBAAN;AACH;;AAED,gBAAMC,eAAevF,OAAO1L,IAAP,IAAkBgR,gBAAlB,YAArB;;AAEA,gBAAI1C,aAAa2C,YAAb,CAAJ,EAAgC;AAC5B,sBAAM,IAAIhK,KAAJ,YAAmBgK,YAAnB,qBAAN;AACH;;AAED,gBAAMC,eAAe,KAAKvE,aAAL,GAAqBa,SAArB,GAAiCwD,gBAAjC,CAArB;;AAb2B,wCAcEG,sFAAqBA,CAACD,YAAtB,EAAoC,KAAKtH,WAAzC,EAAsD8B,MAAtD,CAdF;AAAA,gBAcnB0F,UAdmB,yBAcnBA,UAdmB;AAAA,gBAcPC,IAdO,yBAcPA,IAdO;;AAgB3B,gBAAMC,WAAWhC,mEAAYA,CAAC,CAAC8B,UAAD,CAAb,EAA2B,CACxC;AACIpR,sBAAMiR,YADV;AAEInL,sBAAMyL,gDAASA,CAACC,SAFpB;AAGIC,yBAASC,uDAAgBA,CAACC,MAH9B;AAIIN;AAJJ,aADwC,CAA3B,EAMT,CAACJ,YAAD,CANS,EAMO,CANP,CAAjB;;AAQA,gBAAMpC,QAAQ,KAAKA,KAAL,CAAWnD,OAAOC,SAAlB,CAAd;AACAkD,kBAAMU,QAAN,CAAe+B,QAAf;;AAEAtF,8EAAkBA,CACd,IADJ,EAEI6C,KAFJ,EAGI3K,yDAAcA,CAACM,GAHnB,EAIK,EAAEwM,kCAAF,EAAoBtF,cAApB,EAA4BuF,0BAA5B,EAJL,EAKK,IALL;;AAQA,mBAAOpC,KAAP;AACH;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;uCAuBgB;AACZ,gBAAMtI,OAAO,KAAKqL,SAAL,CAAevL,iDAAUA,CAACS,SAA1B,CAAb;AACA,gBAAMN,SAAS,KAAKqL,SAAL,EAAf;;AAEA,mBAAO,IAAI9I,SAAJ,CAAcxC,IAAd,EAAoBC,MAApB,CAAP;AACH;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mCA0CYsL,Y,EAAcC,S,EAAWrG,M,EAAQ;AACzC,gBAAM4C,eAAe,KAAKC,eAAL,EAArB;;AAEAuD,yBAAajR,OAAb,CAAqB,UAACqM,SAAD,EAAe;AAChC,oBAAI,CAACoB,aAAapB,SAAb,CAAL,EAA8B;AAC1B,0BAAM,IAAIjG,KAAJ,YAAmBiG,SAAnB,mCAAN;AACH;AACJ,aAJD;;AAMA,gBAAM8E,YAAY;AACdC,sBAAMC,oDAAaA,CAACC,MADN;AAEdxG,2BAAW;AAFG,aAAlB;;AAKAD,qBAAS/K,OAAOgH,MAAP,CAAc,EAAd,EAAkBqK,SAAlB,EAA6BtG,MAA7B,CAAT;;AAEA,mBAAO0G,+DAAeA,CAAC,IAAhB,EAAsBN,YAAtB,EAAoCC,SAApC,EAA+CrG,MAA/C,CAAP;AACH;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wCAoC6D;AAAA,gBAA9C2G,YAA8C,uEAA/B,EAA+B;AAAA,gBAA3BC,YAA2B,uEAAZ,EAAY;AAAA,gBAAR5G,MAAQ;;AACzD,gBAAMsG,YAAY;AACdC,sBAAMC,oDAAaA,CAACC,MADN;AAEdxG,2BAAW;AAFG,aAAlB;AAIA,gBAAM4G,cAAc,KAAKhE,eAAL,EAApB;AACA,gBAAMiE,YAAY7R,OAAOmI,IAAP,CAAYyJ,WAAZ,CAAlB;AACA,gBAAME,0BAA0B,CAAC,CAACH,YAAD,CAAD,CAAhC;;AAEA5G,qBAAS/K,OAAOgH,MAAP,CAAc,EAAd,EAAkBqK,SAAlB,EAA6BtG,MAA7B,CAAT;AACA2G,2BAAeA,aAAalR,MAAb,GAAsBkR,YAAtB,GAAqC,CAAC,EAAD,CAApD;;AAGAA,yBAAaxR,OAAb,CAAqB,UAAC6R,QAAD,EAAWzS,CAAX,EAAiB;AAClCwS,wCAAwBxS,CAAxB,IAA6B0S,sEAAsBA,8BAC3CD,QADqB,sBACRJ,YADQ,IAEzBE,SAFyB,EAGzBD,WAHyB,CAA7B;AAIH,aALD;;AAOA,mBAAOK,gEAAgBA,CAAC,IAAjB,EAAuBH,uBAAvB,EAAgD/G,MAAhD,EAAwD8G,SAAxD,CAAP;AACH;;;;;AAhvBD;;;;;;;;;;;mDAWmC9G,M,EAAQ;AACvC,mBAAOmH,4DAAiBA,CAACC,gBAAlB,CAAmCpH,MAAnC,CAAP;AACH;;;4BA/BsB;AACnB,mBAAOQ,4DAAP;AACH;;AAED;;;;;;4BAGwB;AACpB,mBAAO/F,0DAAP;AACH;;AAED;;;;;;4BAGwB;AACpB,mBAAO4M,sDAAP;AACH;;;;EApEmBC,iD;;AA2zBTjK,wEAAf,E;;;;;;;;;;;;ACr2BA;AAAA;AAAA;;AAEe;AACX5B,gBAAYd,iDAAUA,CAACC;AADZ,CAAf,E;;;;;;;;;;;;ACFA;AAAA;;;;;;;AAOA,IAAMD,aAAa;AACfS,aAAW,UADI;AAEfF,WAAS,QAFM;AAGfF,WAAS,QAHM;AAIfJ,QAAM;AAJS,CAAnB;;AAOeD,yEAAf,E;;;;;;;;;;;;ACdA;AAAA;;;;;;AAMA,IAAMqL,mBAAmB;AACrBuB,eAAa,aADQ;AAErBC,YAAU,UAFW;AAGrBvB,UAAQ;AAHa,CAAzB;;AAMeD,+EAAf,E;;;;;;;;;;;;ACZA;AAAA;;;;;;;AAOA,IAAMH,YAAY;AACd4B,WAAS,SADK;AAEd3B,aAAW;AAFG,CAAlB;;AAKeD,wEAAf,E;;;;;;;;;;;;ACZA;AAAA;;;;;;AAMA,IAAMW,gBAAgB;AAClBC,UAAQ,QADU;AAElBiB,WAAS,SAFS;AAGlBC,OAAK;AAHa,CAAtB;;AAMenB,4EAAf,E;;;;;;;;;;;;ACZA;AAAA;;;;;;AAMA,IAAMoB,qBAAqB;AACvBC,SAAK,KADkB;AAEvBC,SAAK,KAFkB;AAGvBC,SAAK,KAHkB;AAIvBC,SAAK,KAJkB;AAKvBC,WAAO,OALgB;AAMvBC,UAAM,MANiB;AAOvBC,WAAO,OAPgB;AAQvBC,SAAK;AARkB,CAA3B;;AAWeR,iFAAf,E;;;;;;;;;;;;ACjBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACbA;AAAA;;;;;;AAMA,IAAMS,iBAAiB;AACnBC,cAAY;AADO,CAAvB;;AAIeD,6EAAf,E;;;;;;;;;;;;ACVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAME,YAAY;AACdC,8DADc;AAEdC,sDAFc;AAGdC,4DAHc;AAIdC,8DAJc;AAKdtI,8DALc;AAMduI,kFANc;AAOd/K,wDAPc;AAQdgL,wEARc;AASdC,oEATc;AAUdC,sEAVc;AAWdC,0EAXc;AAYdC,4EAZc;AAadC,0EAbc;AAcdC,0DAdc;AAedzF,oFAAkBA;AAfJ,CAAlB;;AAkBA,IAAM0F,UAAUC,0CAAGA,CAACD,OAApB;AACAnU,OAAOgH,MAAP,CAAcoB,kDAAd,EAAyB;AACrBkL,wBADqB;AAErBe,8CAFqB;AAGrB9Q,6EAHqB;AAIrB+Q,+EAJqB;AAKrB5O,qEALqB;AAMrB6L,2EANqB;AAOrBW,mFAPqB;AAQrBiC,oBARqB;AASrB/O,2EATqB;AAUrBmP,uDAAaA;AAVQ,CAAzB,EAWGC,mCAXH;;AAaepM,iHAAf,E;;;;;;;;;;;;AC3DA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;;;;;;;AAOA,SAASqM,eAAT,CAAyB7O,IAAzB,EAA+BC,MAA/B,EAAuC;AACnCD,WAAOA,QAAQ,EAAf;;AAEA,QAAIwM,qDAAaA,CAAC9M,GAAd,CAAkBO,OAAOiL,OAAzB,CAAJ,EAAuC;AACnC,eAAOsB,qDAAaA,CAAC7M,GAAd,CAAkBM,OAAOiL,OAAzB,EACU4D,OADV,CAEUnI,SAFV,CAEoB1G,OAAOxG,IAF3B,EAGUwG,MAHV,CAGiBA,MAHjB,EAIUD,IAJV,CAIeA,IAJf,EAKUwE,UALV,SAK0BxE,KAAKpF,MAAL,GAAc,CALxC,GAMUmU,KANV,EAAP;AAOH;AACD,WAAOvC,qDAAaA,CACH7M,GADV,CACcM,OAAOV,IAAP,KAAgByL,gDAASA,CAAC4B,OAA1B,GAAoCY,qDAAcA,CAACC,UAAnD,GAAgEtC,uDAAgBA,CAACuB,WAD/F,EAEUoC,OAFV,CAGUnI,SAHV,CAGoB1G,OAAOxG,IAH3B,EAIUwG,MAJV,CAIiBA,MAJjB,EAKUD,IALV,CAKeA,IALf,EAMUwE,UANV,SAM0BxE,KAAKpF,MAAL,GAAc,CANxC,GAOUmU,KAPV,EAAP;AAQH;;AAGD;;;;;;;AAOO,SAASC,0BAAT,CAAoChI,YAApC,EAAkDxC,UAAlD,EAA8D;AAAA,QACzDvE,MADyD,GAC9C+G,YAD8C,CACzD/G,MADyD;;;AAGjE,QAAIuM,qDAAaA,CAAC9M,GAAd,CAAkBO,OAAOiL,OAAzB,CAAJ,EAAuC;AACnC,eAAOsB,qDAAaA,CAAC7M,GAAd,CAAkBM,OAAOiL,OAAzB,EACU4D,OADV,CAEU9H,YAFV,CAEuBA,YAFvB,EAGUxC,UAHV,CAGqBA,UAHrB,EAIUuK,KAJV,EAAP;AAKH;AACD,WAAOvC,qDAAaA,CACH7M,GADV,CACcM,OAAOV,IAAP,KAAgByL,gDAASA,CAAC4B,OAA1B,GAAoCY,qDAAcA,CAACC,UAAnD,GAAgEtC,uDAAgBA,CAACuB,WAD/F,EAEUoC,OAFV,CAGU9H,YAHV,CAGuBA,YAHvB,EAIUxC,UAJV,CAIqBA,UAJrB,EAKUuK,KALV,EAAP;AAMH;;AAED;;;;;;;;AAQO,SAAShG,YAAT,CAAsBkG,UAAtB,EAAkChP,MAAlC,EAA0CqB,OAA1C,EAAmD;AACtD,QAAM4N,aAAa,EAAnB;;AAEA,QAAI,EAAE5N,WAAWA,QAAQ1G,MAArB,CAAJ,EAAkC;AAC9B0G,kBAAUrB,OAAOzG,GAAP,CAAW;AAAA,mBAAQ8I,KAAK7I,IAAb;AAAA,SAAX,CAAV;AACH;;AAED6H,YAAQhH,OAAR,CAAgB,UAAC6H,MAAD,EAASzI,CAAT,EAAe;AAC3BwV,mBAAW/M,MAAX,IAAqBzI,CAArB;AACH,KAFD;;AAIA,WAAOuG,OAAOzG,GAAP,CAAW;AAAA,eAAQqV,gBAAgBI,WAAWC,WAAW5M,KAAK7I,IAAhB,CAAX,CAAhB,EAAmD6I,IAAnD,CAAR;AAAA,KAAX,CAAP;AACH,C;;;;;;;;;;;;AC9ED;AAAA;AAAA;AAAA;AACA;;AAEA,IAAM6M,aAAa;AACfnP,UAAM,EADS;;AAGfoP,mBAHe,2BAGEC,QAHF,EAGY5V,IAHZ,EAGkB;AAC7B,YAAM6V,SAAS7V,QAAQ8V,0DAAWA,EAAlC;;AAEA,aAAKvP,IAAL,CAAUsP,MAAV,IAAoB;AAChB7V,kBAAM6V,MADU;AAEhB1N,oBAAQyN,QAFQ;;AAIhBpI,qBAJgB,uBAIH;AACT,oBAAIA,YAAY,KAAKM,gBAArB;;AAEA,oBAAI,CAACN,SAAL,EAAgB;AACZA,gCAAY,KAAKM,gBAAL,GAAwB,EAApC;AACA,yBAAK3F,MAAL,CAAYtH,OAAZ,CAAoB,UAACuH,KAAD,EAAW;AAC3BoF,kCAAUpF,MAAMpI,IAAN,EAAV,IAA0BoI,KAA1B;AACH,qBAFD;AAGH;AACD,uBAAOoF,SAAP;AACH,aAde;AAehBuI,sBAfgB,wBAeF;AACV,oBAAIC,gBAAgB,KAAKhI,cAAzB;;AAEA,oBAAI,CAACgI,aAAL,EAAoB;AAChBA,oCAAgB,KAAKhI,cAAL,GAAsB,EAAtC;AACA,yBAAK7F,MAAL,CAAYtH,OAAZ,CAAoB,UAACuH,KAAD,EAAW;AAC3B,4BAAIA,MAAM5B,MAAN,GAAeV,IAAf,KAAwByL,gDAASA,CAAC4B,OAAtC,EAA+C;AAC3C6C,0CAAc5N,MAAMpI,IAAN,EAAd,IAA8BoI,KAA9B;AACH;AACJ,qBAJD;AAKH;AACD,uBAAO4N,aAAP;AACH,aA3Be;AA4BhBC,wBA5BgB,0BA4BA;AACZ,oBAAIC,kBAAkB,KAAKnI,gBAA3B;;AAEA,oBAAI,CAAC,KAAKA,gBAAV,EAA4B;AACxBmI,sCAAkB,KAAKnI,gBAAL,GAAwB,EAA1C;AACA,yBAAK5F,MAAL,CAAYtH,OAAZ,CAAoB,UAACuH,KAAD,EAAW;AAC3B,4BAAIA,MAAM5B,MAAN,GAAeV,IAAf,KAAwByL,gDAASA,CAACC,SAAtC,EAAiD;AAC7C0E,4CAAgB9N,MAAMpI,IAAN,EAAhB,IAAgCoI,KAAhC;AACH;AACJ,qBAJD;AAKH;AACD,uBAAO8N,eAAP;AACH;AAxCe,SAApB;AA0CA,eAAO,KAAK3P,IAAL,CAAUsP,MAAV,CAAP;AACH;AAjDc,CAAnB;;AAoDeH,yEAAf,E;;;;;;;;;;;;;;;;;;;;;;;ACvDA;AACA;;AAEA;;;;;;;;IAOqBS,M;;;;;;;;;;;;AACjB;;;;;;;8CAOuB;AACnB,gBAAMC,UAAU,KAAK7I,YAAL,CAAkB/G,MAAlB,CAAyB6K,IAAzC;AACA,mBAAO,CAAC+E,QAAQ,CAAR,CAAD,EAAaA,QAAQA,QAAQjV,MAAR,GAAiB,CAAzB,CAAb,CAAP;AACH;;AAED;;;;;;;;;+BAMQ;AACJ,mBAAO,KAAKoM,YAAL,CAAkB/G,MAAlB,CAAyB6K,IAAhC;AACH;;;iCAEe;AACZ,mBAAO,IAAIgF,8DAAJ,EAAP;AACH;;;;EAzB+BC,kD;;AAAfH,qE;;;;;;;;;;;;;;;;;;;;;;;;;ACVrB;AACA;AACA;AACA;AACA;;;;;;;;IAOqBI,W;;;;;;;;;;;;AACjB;;;;;;;kCAOW;AACP,mBAAO7E,uDAAgBA,CAACuB,WAAxB;AACH;;AAED;;;;;;;;;;8CAOuB;AAAA;;AACnB,gBAAMuD,OAAO,IAAIC,GAAJ,EAAb;AACA,gBAAMC,SAAS,EAAf;;AAEA;AACAtH,qGAAkBA,CAAC,KAAKrE,UAAxB,EAAoC,UAAC9K,CAAD,EAAO;AACvC,oBAAM2K,QAAQ,OAAK2C,YAAL,CAAkBhH,IAAlB,CAAuBtG,CAAvB,CAAd;AACA,oBAAI,CAACuW,KAAKvQ,GAAL,CAAS2E,KAAT,CAAL,EAAsB;AAClB4L,yBAAKG,GAAL,CAAS/L,KAAT;AACA8L,2BAAO3V,IAAP,CAAY6J,KAAZ;AACH;AACJ,aAND;AAOA,mBAAO8L,MAAP;AACH;;;iCAEe;AACZ,mBAAO,IAAIE,mEAAJ,EAAP;AACH;;;;EApCoCN,kD;;AAApBC,0E;;;;;;;;;;;;;;;;;;;;;;;;;;ACXrB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;IAOqBM,U;;;;;;;;;;;;AACjB;;;;;;;kCAOW;AACP,mBAAO9C,qDAAcA,CAACC,UAAtB;AACH;;AAED;;;;;;;;;;8CAOuB;AAAA;;AACnB,gBAAI8C,MAAM3L,OAAO4L,iBAAjB;AACA,gBAAIC,MAAM7L,OAAO8L,iBAAjB;;AAEA;AACA7H,qGAAkBA,CAAC,KAAKrE,UAAxB,EAAoC,UAAC9K,CAAD,EAAO;AACvC,oBAAM2K,QAAQ,OAAK2C,YAAL,CAAkBhH,IAAlB,CAAuBtG,CAAvB,CAAd;AACA,oBAAI2K,iBAAiBiI,4DAArB,EAAwC;AACpC;AACH;;AAED,oBAAIjI,QAAQkM,GAAZ,EAAiB;AACbA,0BAAMlM,KAAN;AACH;AACD,oBAAIA,QAAQoM,GAAZ,EAAiB;AACbA,0BAAMpM,KAAN;AACH;AACJ,aAZD;;AAcA,mBAAO,CAACkM,GAAD,EAAME,GAAN,CAAP;AACH;;;iCAEe;AACZ,mBAAO,IAAIE,kEAAJ,EAAP;AACH;;;;EA3CmCC,gD;;AAAnBN,yE;;;;;;;;;;;;;;;;;;;;;;ACbrB;;AAEA;;;;;;;;IAOqBP,S;;;;;;;;;;;;AACjB;;;;;;;iCAOU;AACN,gBAAI,CAAC,KAAKc,aAAV,EAAyB;AACrB,qBAAKA,aAAL,GAAqB,KAAKC,mBAAL,EAArB;AACH;AACD,mBAAO,KAAKD,aAAZ;AACH;;AAED;;;;;;;;;8CAMuB;AACnB,kBAAM,IAAInQ,KAAJ,CAAU,qBAAV,CAAN;AACH;;AAEA;;;;;;;;;;wCAOgB;AACb,mBAAO,KAAKV,IAAL,EAAP;AACH;;;;EAlCkC+Q,8C;;AAAlBhB,wE;;;;;;;;;;;;;;;;;;;;;;ACTrB;AACA;AACA;AACA;AACA;;IAGMiB,iB;AACF,iCAAc;AAAA;;AACV,aAAKC,UAAL,GAAkB,IAAInS,GAAJ,EAAlB;AACH;;;;0CAEiBoM,O,EAASgG,S,EAAW;AAClC,iBAAKD,UAAL,CAAgB5R,GAAhB,CAAoB6L,OAApB,EAA6BgG,SAA7B;AACA,mBAAO,IAAP;AACH;;;4BAEG3R,I,EAAM;AACN,mBAAO,KAAK0R,UAAL,CAAgBvR,GAAhB,CAAoBH,IAApB,CAAP;AACH;;;4BAEGA,I,EAAM;AACN,mBAAO,KAAK0R,UAAL,CAAgBtR,GAAhB,CAAoBJ,IAApB,CAAP;AACH;;;;;;AAGL,IAAM4R,wBAAwB,SAAxBA,qBAAwB,CAACtS,KAAD,EAAW;AACrCA,UACiBuS,iBADjB,CACmCjG,uDAAgBA,CAACuB,WADpD,EACiEsD,oDADjE,EAEiBoB,iBAFjB,CAEmCjG,uDAAgBA,CAACwB,QAFpD,EAE8D0E,iDAF9D,EAGiBD,iBAHjB,CAGmCjG,uDAAgBA,CAACC,MAHpD,EAG4DwE,+CAH5D,EAIiBwB,iBAJjB,CAImC5D,qDAAcA,CAACC,UAJlD,EAI8D6C,mDAJ9D;AAKH,CAND;;AAQA,IAAM9D,gBAAiB,YAAY;AAC/B,QAAI3N,QAAQ,IAAZ;AACA,aAASgB,QAAT,GAAqB;AACjBhB,gBAAQ,IAAImS,iBAAJ,EAAR;AACAG,8BAAsBtS,KAAtB;AACA,eAAOA,KAAP;AACH;AACD,WAAOA,SAASgB,UAAhB;AACH,CARsB,EAAvB;;AAUe2M,4EAAf,E;;;;;;;;;;;;;;;;;;;AC5CA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;IAmBqBuE,K;AACjB;;;;;;;AAOA,mBAAa/J,YAAb,EAA2BxC,UAA3B,EAAuC;AAAA;;AACnC,aAAKwC,YAAL,GAAoBA,YAApB;AACA,aAAKxC,UAAL,GAAkBA,UAAlB;AACH;;;;;;AAMD;;;;;;iCAMU;AACN,kBAAM,IAAI9D,KAAJ,CAAU,qBAAV,CAAN;AACH;;AAED;;;;;;;;;iCAMU;AACN,mBAAO,KAAKsG,YAAL,CAAkB/G,MAAzB;AACH;;AAED;;;;;;;;;+BAMQ;AACJ,mBAAO,KAAK+G,YAAL,CAAkBvN,IAAzB;AACH;;AAED;;;;;;;;;+BAMQ;AACJ,mBAAO,KAAKuN,YAAL,CAAkB/G,MAAlB,CAAyBV,IAAhC;AACH;;AAED;;;;;;;;;kCAMW;AACP,mBAAO,KAAKyH,YAAL,CAAkB/G,MAAlB,CAAyBiL,OAAhC;AACH;;AAED;;;;;;;;;sCAMe;AACX,mBAAO,KAAKlE,YAAL,CAAkB/G,MAAlB,CAAyBqR,WAAhC;AACH;;AAED;;;;;;;;;sCAMe;AACX,mBAAO,KAAKtK,YAAL,CAAkB/G,MAAlB,CAAyBsR,WAAzB,IAAwC,KAAKvK,YAAL,CAAkB/G,MAAlB,CAAyBxG,IAAxE;AACH;;AAED;;;;;;;;;+BAMQ;AAAA;;AACJ,gBAAMuG,OAAO,EAAb;AACA6I,qGAAkBA,CAAC,KAAKrE,UAAxB,EAAoC,UAAC9K,CAAD,EAAO;AACvCsG,qBAAKxF,IAAL,CAAU,MAAKwM,YAAL,CAAkBhH,IAAlB,CAAuBtG,CAAvB,CAAV;AACH,aAFD;AAGA,mBAAOsG,IAAP;AACH;;AAED;;;;;;;;;wCAMiB;AACb,kBAAM,IAAIU,KAAJ,CAAU,qBAAV,CAAN;AACH;;;iCAhGe;AACZ,kBAAM,IAAIA,KAAJ,CAAU,qBAAV,CAAN;AACH;;;4BAgGoB;AACjB,gBAAM8Q,UAAU;AACZC,yBAAS,EADG;AAEZC,0BAAU,IAFE;AAGZ/K,yBAHY,qBAGFlN,IAHE,EAGI;AACZ,yBAAKgY,OAAL,CAAahY,IAAb,GAAoBA,IAApB;AACA,2BAAO,IAAP;AACH,iBANW;AAOZwG,sBAPY,kBAOLA,OAPK,EAOG;AACX,yBAAKwR,OAAL,CAAaxR,MAAb,GAAsBA,OAAtB;AACA,2BAAO,IAAP;AACH,iBAVW;AAWZD,oBAXY,gBAWPA,KAXO,EAWD;AACP,yBAAKyR,OAAL,CAAazR,IAAb,GAAoBA,KAApB;AACA,2BAAO,IAAP;AACH,iBAdW;AAeZgH,4BAfY,wBAeCA,aAfD,EAee;AACvB,yBAAKyK,OAAL,CAAazK,YAAb,GAA4BA,aAA5B;AACA,2BAAO,IAAP;AACH,iBAlBW;AAmBZxC,0BAnBY,sBAmBDA,WAnBC,EAmBW;AACnB,yBAAKiN,OAAL,CAAajN,UAAb,GAA0BA,WAA1B;AACA,2BAAO,IAAP;AACH,iBAtBW;AAuBZuK,qBAvBY,mBAuBJ;AACJ,wBAAI/H,eAAe,IAAnB;AACA,wBAAI,KAAKyK,OAAL,CAAazK,YAAb,YAAqC2K,sDAAzC,EAAuD;AACnD3K,uCAAe,KAAKyK,OAAL,CAAazK,YAA5B;AACH,qBAFD,MAEO,IAAI,KAAKyK,OAAL,CAAaxR,MAAb,IAAuB,KAAKwR,OAAL,CAAazR,IAAxC,EAA8C;AACjDgH,uCAAe,IAAI2K,sDAAJ,CAAiB,KAAKF,OAAL,CAAahY,IAA9B,EACK,KAAKgY,OAAL,CAAazR,IADlB,EAEK,KAAKyR,OAAL,CAAaxR,MAFlB,EAGK,KAAKyR,QAAL,CAAcE,MAAd,EAHL,CAAf;AAIH,qBALM,MAMF;AACD,8BAAM,IAAIlR,KAAJ,CAAU,0BAAV,CAAN;AACH;AACD,2BAAO,IAAI,KAAKgR,QAAT,CAAkB1K,YAAlB,EAAgC,KAAKyK,OAAL,CAAajN,UAA7C,CAAP;AACH;AArCW,aAAhB;AAuCA,mBAAOgN,OAAP;AACH;;;;;;AAxJgBT,oE;;;;;;;;;;;;ACtBrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACHA;AACA;AACA;;AAEA;;;;;;;;IAOqBH,O;;;;;;;;;;;;AACnB;;;;;;;iCAOY;AACN,gBAAI,CAAC,KAAKC,aAAV,EAAyB;AACrB,qBAAKA,aAAL,GAAqB,KAAKC,mBAAL,EAArB;AACH;AACD,mBAAO,KAAKD,aAAZ;AACH;;AAEH;;;;;;;;;+BAMU;AACJ,mBAAO,KAAK7J,YAAL,CAAkB/G,MAAlB,CAAyB4R,IAAhC;AACH;;AAEH;;;;;;;;;mCAMc;AACR,mBAAO,KAAK7K,YAAL,CAAkB/G,MAAlB,CAAyB6R,QAAzB,IAAqCC,8EAA5C;AACH;;AAEH;;;;;;;;;uCAMkB;AAAA,gBACJC,YADI,GACa,KAAKhL,YAAL,CAAkB/G,MAD/B,CACJ+R,YADI;;AAEZ,mBAAOA,wBAAwBzY,QAAxB,GAAmCyY,YAAnC,GAAkDC,mDAAzD;AACH;;AAEH;;;;;;;;;8CAMyB;AACnB,kBAAM,IAAIvR,KAAJ,CAAU,qBAAV,CAAN;AACH;;AAED;;;;;;;;;;wCAOiB;AACb,mBAAO,KAAKV,IAAL,EAAP;AACH;;;;EAjEgC+Q,8C;;AAAhBH,sE;;;;;;;;;;;;;;;;;;;;;;;ACXrB;AACA;;AAEA;;;;;;;;IAOqBd,Y;;;;;;;;;;;;AACnB;;;;;;;8BAOSoC,G,EAAK;AACR,gBAAMC,QAAQ,yDAAd;AACAD,kBAAME,OAAOF,GAAP,CAAN;AACA,gBAAIG,eAAJ;AACA;AACA,gBAAI,CAAC/F,4DAAiBA,CAACgG,SAAlB,CAA4BJ,GAA5B,CAAL,EAAuC;AACnC,oBAAIK,UAAUL,IAAIM,KAAJ,CAAUL,KAAV,CAAd;AACAE,yBAASE,UAAa3N,OAAO6N,UAAP,CAAkBF,QAAQ,CAAR,CAAlB,CAAb,SAA8C3N,OAAO6N,UAAP,CAAkBF,QAAQ,CAAR,CAAlB,CAA9C,GACUjG,4DAAiBA,CAACoG,EADrC;AAEH,aAJD,MAIO;AACHL,yBAAS/F,4DAAiBA,CAACqG,cAAlB,CAAiCT,GAAjC,CAAT;AACH;AACD,mBAAOG,MAAP;AACH;;;;EArBqCO,qD;;AAArB9C,2E;;;;;;;;;;;;;;;;;;;;;;;ACVrB;AACA;;AAEA;;;;;;;;IAOqBO,iB;;;;;;;;;;;;AACnB;;;;;;;8BAOS6B,G,EAAK;AACR,gBAAIG,eAAJ;AACA;AACA,gBAAI,CAAC/F,4DAAiBA,CAACgG,SAAlB,CAA4BJ,GAA5B,CAAL,EAAuC;AACnCG,yBAASD,OAAOF,GAAP,EAAYpa,IAAZ,EAAT;AACH,aAFD,MAEO;AACHua,yBAAS/F,4DAAiBA,CAACqG,cAAlB,CAAiCT,GAAjC,CAAT;AACH;AACD,mBAAOG,MAAP;AACH;;;;EAjB0CO,qD;;AAA1BvC,gF;;;;;;;;;;;;;;;;;;;;;;;ACVrB;AACA;;AAEA;;;;;;;;IAOqBM,gB;;;;;;;;;;;;AACnB;;;;;;;8BAOSuB,G,EAAK;AACR,gBAAIG,eAAJ;AACA;AACA,gBAAI,CAAC/F,4DAAiBA,CAACgG,SAAlB,CAA4BJ,GAA5B,CAAL,EAAuC;AACnC,oBAAIW,YAAYJ,WAAWP,GAAX,EAAgB,EAAhB,CAAhB;AACAG,yBAASzN,OAAO3M,KAAP,CAAa4a,SAAb,IAA0BvG,4DAAiBA,CAACoG,EAA5C,GAAiDG,SAA1D;AACH,aAHD,MAGO;AACHR,yBAAS/F,4DAAiBA,CAACqG,cAAlB,CAAiCT,GAAjC,CAAT;AACH;AACD,mBAAOG,MAAP;AACH;;;;EAlByCO,qD;;AAAzBjC,+E;;;;;;;;;;;;;;;;;ACVrB;;;;;;IAMqBiC,W;;;;;;;;AACjB;;;;;;4BAMS;AACL,YAAM,IAAIlS,KAAJ,CAAU,qBAAV,CAAN;AACH;;;;;;AATgBkS,0E;;;;;;;;;;;;;;;;;;;;;;;;ACNrB;AACA;AACA;;AAEA;;;;;;;;IAOqBE,c;;;;;;;;;;;;;AAEjB;;;;;;;8BAOOZ,G,QAAiB;AAAA,gBAAVvZ,MAAU,QAAVA,MAAU;;AACpB,gBAAI0Z,eAAJ;AACA;AACA,gBAAI,CAAC,KAAKU,IAAV,EAAgB;AACZ,qBAAKA,IAAL,GAAY,IAAIrE,wDAAJ,CAAsB/V,MAAtB,CAAZ;AACH;AACD,gBAAI,CAAC2T,4DAAiBA,CAACgG,SAAlB,CAA4BJ,GAA5B,CAAL,EAAuC;AACnC,oBAAIc,aAAa,KAAKD,IAAL,CAAUE,aAAV,CAAwBf,GAAxB,CAAjB;AACAG,yBAASW,aAAaA,WAAWE,OAAX,EAAb,GAAoC5G,4DAAiBA,CAACoG,EAA/D;AACH,aAHD,MAGO;AACHL,yBAAS/F,4DAAiBA,CAACqG,cAAlB,CAAiCT,GAAjC,CAAT;AACH;AACD,mBAAOG,MAAP;AACH;;;;EAtBuCO,qD;;AAAvBE,6E;;;;;;;;;;;;;;;;;ACXrB;;;;;;;;IAQqBnB,Y;AACjB;;;;;;;;;AASA,wBAAalY,IAAb,EAAmBuG,IAAnB,EAAyBC,MAAzB,EAAiC2R,MAAjC,EAAyC;AAAA;;AACrC,SAAKnY,IAAL,GAAYA,IAAZ;AACA,SAAKwG,MAAL,GAAcA,MAAd;AACA,SAAK2R,MAAL,GAAcA,MAAd;AACA,SAAK5R,IAAL,GAAY,KAAKmT,SAAL,CAAenT,IAAf,CAAZ;AACH;;AAED;;;;;;;;;;;8BAOWA,I,EAAM;AAAA;;AACb,aAAOA,KAAKxG,GAAL,CAAS;AAAA,eAAS,MAAKoY,MAAL,CAAYrZ,KAAZ,CAAkB8L,KAAlB,EAAyB,EAAE1L,QAAQ,MAAKsH,MAAL,CAAYtH,MAAtB,EAAzB,CAAT;AAAA,OAAT,CAAP;AACH;;;;;;AA1BgBgZ,2E;;;;;;;;;;;;;;;;;;;;;;;;;;ACRrB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;IAOqBN,Q;;;AAChB;;;;;;;AAOD,sBAAarK,YAAb,EAA2BxC,UAA3B,EAAuC;AAAA;;AAAA,wHAC7BwC,YAD6B,EACfxC,UADe;;AAGnC,cAAK4O,cAAL,GAAsB,IAAtB;AAHmC;AAItC;;AAEA;;;;;;;;;;;8CAOsB;AAAA;;AACnB,gBAAMnD,OAAO,IAAIC,GAAJ,EAAb;AACA,gBAAMC,SAAS,EAAf;;AAEA;AACA;AACAtH,qGAAkBA,CAAC,KAAKrE,UAAxB,EAAoC,UAAC9K,CAAD,EAAO;AACvC,oBAAM2K,QAAQ,OAAK2C,YAAL,CAAkBhH,IAAlB,CAAuBtG,CAAvB,CAAd;AACA,oBAAI,CAACuW,KAAKvQ,GAAL,CAAS2E,KAAT,CAAL,EAAsB;AAClB4L,yBAAKG,GAAL,CAAS/L,KAAT;AACA8L,2BAAO3V,IAAP,CAAY6J,KAAZ;AACH;AACJ,aAND;;AAQA,mBAAO8L,MAAP;AACH;;AAGD;;;;;;;;;uDAMgC;AAC5B,gBAAI,KAAKiD,cAAT,EAAyB;AACrB,uBAAO,KAAKA,cAAZ;AACH;;AAED,gBAAMC,aAAa,KAAKrT,IAAL,GAAYsT,MAAZ,CAAmB;AAAA,uBAAQ,EAAEhR,gBAAgBgK,4DAAlB,CAAR;AAAA,aAAnB,EAAiEtJ,IAAjE,CAAsE,UAACuQ,CAAD,EAAIC,CAAJ;AAAA,uBAAUD,IAAIC,CAAd;AAAA,aAAtE,CAAnB;AACA,gBAAMC,QAAQJ,WAAWzY,MAAzB;AACA,gBAAI8Y,UAAU9O,OAAO4L,iBAArB;AACA,gBAAImD,kBAAJ;AACA,gBAAIC,kBAAJ;AACA,gBAAIC,iBAAiB,CAArB;;AAEA,iBAAK,IAAIna,IAAI,CAAb,EAAgBA,IAAI+Z,KAApB,EAA2B/Z,GAA3B,EAAgC;AAC5Bia,4BAAYN,WAAW3Z,IAAI,CAAf,CAAZ;AACAka,4BAAYP,WAAW3Z,CAAX,CAAZ;;AAEA,oBAAIka,cAAcD,SAAlB,EAA6B;AACzB;AACH;;AAEDD,0BAAUI,KAAKvD,GAAL,CAASmD,OAAT,EAAkBE,YAAYP,WAAW3Z,IAAI,CAAf,CAA9B,CAAV;AACAma;AACH;;AAED,gBAAI,CAACA,cAAL,EAAqB;AACjBH,0BAAU,IAAV;AACH;AACD,iBAAKN,cAAL,GAAsBM,OAAtB;;AAEA,mBAAO,KAAKN,cAAZ;AACH;;AAED;;;;;;;;;iCAMU;AACN,mBAAO,KAAKpM,YAAL,CAAkB/G,MAAlB,CAAyBtH,MAAhC;AACH;;AAED;;;;;;;;;;wCAOiB;AAAA;;AACb,gBAAMqH,OAAO,EAAb;AACA,gBAAMY,aAAa,KAAKjI,MAAL,EAAnB;;AAEAkQ,qGAAkBA,CAAC,KAAKrE,UAAxB,EAAoC,UAAC9K,CAAD,EAAO;AACvC,oBAAM2K,QAAQ,OAAK2C,YAAL,CAAkBhH,IAAlB,CAAuBtG,CAAvB,CAAd;AACA;AACA,oBAAI4S,4DAAiBA,CAACgG,SAAlB,CAA4BjO,KAA5B,KAAuC,CAACzD,UAAD,IAAegE,OAAOmP,QAAP,CAAgB1P,KAAhB,CAA1D,EAAmF;AAC/E;AACA,wBAAM2P,cAAc1H,4DAAiBA,CAACqG,cAAlB,CAAiCtO,KAAjC,KAA2CA,KAA/D;AACArE,yBAAKxF,IAAL,CAAUwZ,WAAV;AACH,iBAJD,MAIO;AACHhU,yBAAKxF,IAAL,CAAUkU,wDAAiBA,CAACuF,QAAlB,CAA2B5P,KAA3B,EAAkCzD,UAAlC,CAAV;AACH;AACJ,aAVD;AAWA,mBAAOZ,IAAP;AACH;;;iCAEe;AACZ,mBAAO,IAAI8S,gEAAJ,EAAP;AACH;;;;EAlHiC/C,kD;;AAAjBsB,uE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACbrB;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,SAAS6C,oBAAT,CAA+BtS,MAA/B,EAAuC0E,aAAvC,EAAsDR,OAAtD,EAA+DpM,CAA/D,EAAkE;AAC9D,QAAMya,OAAO,EAAb;;AAD8D;AAAA;AAAA;;AAAA;AAG9D,6BAA2BvS,OAAOwS,OAAP,EAA3B,8HAA6C;AAAA;;AAAA;;AAAA,gBAAjCxc,GAAiC;AAAA,gBAA5BiK,KAA4B;;AACzCsS,iBAAKtS,MAAMpI,IAAN,EAAL,IAAqB,IAAI0N,8CAAJ,CAAUb,cAAc1O,GAAd,EAAmB8B,CAAnB,CAAV,EAAiCoM,QAAQlO,GAAR,EAAa8B,CAAb,CAAjC,EAAkDmI,KAAlD,CAArB;AACH;AAL6D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAM9D,WAAOsS,IAAP;AACH;;AAEM,SAASE,eAAT,CAA0BzS,MAA1B,EAAkC;AACrC,QAAMuS,OAAO,EAAb;;AAEA,SAAK,IAAMvc,GAAX,IAAkBgK,MAAlB,EAA0B;AACtBuS,aAAKvc,GAAL,IAAY,IAAIuP,8CAAJ,CAAUvF,OAAOhK,GAAP,EAAY0c,cAAtB,EAAsC1S,OAAOhK,GAAP,EAAY2c,QAAlD,EAA4D3c,GAA5D,CAAZ;AACH;AACD,WAAOuc,IAAP;AACH;;AAEM,IAAMK,eAAe,SAAfA,YAAe,QAA8B5N,iBAA9B,EAAiD6N,cAAjD,EAAoE;AAAA;AAAA,QAAlEjQ,UAAkE;AAAA,QAAtDkQ,aAAsD;;AAC5F,QAAIC,SAASD,cAAc9Z,MAAd,GAAuB8Z,cAAc/P,KAAd,CAAoB,GAApB,CAAvB,GAAkD,EAA/D;AACA,QAAIiQ,kBAAkBhO,kBAAkBK,SAAlB,EAAtB;AACA,QAAI4N,YAAYF,OAAOnb,GAAP,CAAW;AAAA,eAAQwV,iFAA0BA,CAAC4F,gBAAgBE,IAAhB,EAAsB9N,YAAjD,EAA+DxC,UAA/D,CAAR;AAAA,KAAX,CAAhB;AACA,WAAO2K,oDAAUA,CAACC,eAAX,CAA2ByF,SAA3B,EAAsCJ,cAAtC,CAAP;AACH,CALM;;AAOA,IAAMM,2BAA2B,SAA3BA,wBAA2B,CAAC/K,KAAD,EAAQgL,SAAR,EAA+C;AAAA,QAA5B7P,MAA4B,uEAAnB,EAAmB;AAAA,QAAf8P,UAAe;;AACnF,QAAID,cAAcrX,yDAAcA,CAACI,OAAjC,EAA0C;AAAA;;AACtCiM,cAAMkL,WAAN,CAAkBta,MAAlB,GAA2B,CAA3B;AACA,oCAAMsa,WAAN,EAAkB1a,IAAlB,8CAA0Bya,UAA1B;AACH,KAHD,MAGO;AACHjL,cAAMkL,WAAN,CAAkB1a,IAAlB,CAAuB;AACnB2a,gBAAIH,SADe;AAEnBI,kBAAMjQ,MAFa;AAGnBkQ,sBAAUJ;AAHS,SAAvB;AAKH;AACJ,CAXM;AAYA,IAAMK,4BAA4B,SAA5BA,yBAA4B,CAACC,QAAD,EAAWC,KAAX,EAAqB;AAAA;;AAC1D,mCAAMC,mBAAN,EAA0Bjb,IAA1B,iDAAkC+a,SAASE,mBAA3C,4BAAmEF,SAASL,WAA5E;AACH,CAFM;;AAIA,IAAMzP,qBAAqB,SAArBA,kBAAqB,CAAC8P,QAAD,EAAWvL,KAAX,EAAkBgL,SAAlB,EAAyD;AAAA,QAA5B7P,MAA4B,uEAAnB,EAAmB;AAAA,QAAf8P,UAAe;;AACvFF,6BAAyB/K,KAAzB,EAAgCgL,SAAhC,EAA2C7P,MAA3C,EAAmD8P,UAAnD;AACAK,8BAA0BC,QAA1B,EAAoCvL,KAApC;AACH,CAHM;;AAKP,IAAM0L,sEACD/J,oDAAaA,CAACC,MADb,EACsB;AACpB+J,eAAW,CAAC,YAAD,CADS;AAEpBC,cAAU,CAAC,IAAD,EAAO,KAAP;AAFU,CADtB,mCAKDjK,oDAAaA,CAACkB,OALb,EAKuB;AACrB8I,eAAW,CAAC,kBAAD,CADU;AAErBC,cAAU,CAAC,KAAD,EAAQ,IAAR;AAFW,CALvB,mCASDjK,oDAAaA,CAACmB,GATb,EASmB;AACjB6I,eAAW,CAAC,YAAD,EAAe,kBAAf,CADM;AAEjBC,cAAU,CAAC,IAAD,EAAO,IAAP;AAFO,CATnB,kBAAN;;AAeA,IAAMC,qBAAqB,SAArBA,kBAAqB,CAACrR,UAAD,EAAa9K,CAAb,EAAgBoc,iBAAhB,EAAsC;AAC7D,QAAIA,sBAAsB,CAAC,CAAvB,IAA4Bpc,MAAOoc,oBAAoB,CAA3D,EAA+D;AAC3D,YAAMC,KAAKvR,WAAW5J,MAAX,GAAoB,CAA/B;;AAEA4J,mBAAWuR,EAAX,IAAoBvR,WAAWuR,EAAX,EAAepR,KAAf,CAAqB,GAArB,EAA0B,CAA1B,CAApB,SAAoDjL,CAApD;AACH,KAJD,MAIO;AACH8K,mBAAWhK,IAAX,MAAmBd,CAAnB;AACH;AACJ,CARD;;AAUO,IAAMsc,2BAA2B,SAA3BA,wBAA2B,CAACxR,UAAD,EAAayR,OAAb,EAAsBvK,IAAtB,EAA+B;AACnE,QAAIwK,uBAAuB,CAAC,CAA5B;AACA,QAAIC,uBAAuB,CAAC,CAA5B;AACA,QAAMC,gBAAgB,EAAtB;AACA,QAAMC,gBAAgB,EAAtB;;AAJmE,+CAM9BX,cAAchK,IAAd,EAAoBkK,QANU;AAAA,QAM5DU,YAN4D;AAAA,QAM9CC,YAN8C;;AAQnE1N,wEAAkBA,CAACrE,UAAnB,EAA+B,UAAC9K,CAAD,EAAO;AAClC,YAAM8c,gBAAgBP,QAAQvc,CAAR,CAAtB;AACA8c,yBAAiBF,YAAjB,IAAiCT,mBAAmBO,aAAnB,EAAkC1c,CAAlC,EAAqCwc,oBAArC,CAAjC;AACA,SAACM,aAAD,IAAkBD,YAAlB,IAAkCV,mBAAmBQ,aAAnB,EAAkC3c,CAAlC,EAAqCyc,oBAArC,CAAlC;AACH,KAJD;AAKA,WAAO;AACH3R,oBAAY4R,cAAcvc,IAAd,CAAmB,GAAnB,CADT;AAEH4c,0BAAkBJ,cAAcxc,IAAd,CAAmB,GAAnB;AAFf,KAAP;AAIH,CAjBM;;AAoBA,IAAM6c,0BAA0B,SAA1BA,uBAA0B,CAAClS,UAAD,EAAayR,OAAb,EAAsBvK,IAAtB,EAA4BH,YAA5B,EAA0CoL,aAA1C,EAA4D;AAC/F,QAAIb,oBAAoB,EAAxB;AACA,QAAMc,kBAAkB,EAAxB;AACA,QAAMC,eAAe,EAArB;;AAEAhO,wEAAkBA,CAACrE,UAAnB,EAA+B,UAAC9K,CAAD,EAAO;AAClC,YAAIuc,QAAQvc,CAAR,CAAJ,EAAgB;AACZ,gBAAIuW,OAAO,EAAX;;AAEA,gBAAI6G,eAAe,EAAEvU,MAAM,EAAR,EAAnB;;AAEAgJ,yBAAajR,OAAb,CAAqB,UAAC0K,CAAD,EAAO;AACxB,oBAAMhF,OAAO2W,cAAc3R,CAAd,EAAiBgC,YAAjB,CAA8BhH,IAA9B,CAAmCtG,CAAnC,CAAb;AACAuW,uBAAUA,IAAV,SAAkBjQ,IAAlB;AACA8W,6BAAavU,IAAb,CAAkByC,CAAlB,IAAuBhF,IAAvB;AACH,aAJD;;AAMA,gBAAI4W,gBAAgB3G,IAAhB,MAA0B1L,SAA9B,EAAyC;AACrCqS,gCAAgB3G,IAAhB,IAAwB,EAAxB;AACA6F,kCAAkB7F,IAAlB,IAA0B,CAAC,CAA3B;AACA4G,6BAAa5G,IAAb,IAAqB6G,YAArB;AACH;;AAEDjB,+BAAmBe,gBAAgB3G,IAAhB,CAAnB,EAA0CvW,CAA1C,EAA6Coc,kBAAkB7F,IAAlB,CAA7C;AACA6F,8BAAkB7F,IAAlB,IAA0BvW,CAA1B;AACH;AACJ,KArBD;;AAuBA,WAAO;AACHkd,wCADG;AAEHC;AAFG,KAAP;AAIH,CAhCM;;AAmCA,IAAME,eAAe,SAAfA,YAAe,CAACC,QAAD,EAAWC,QAAX,EAAqB9R,MAArB,EAA6BoQ,QAA7B,EAAuC2B,QAAvC,EAAoD;AAC5E,QAAIzO,cAAc,EAAlB;AACA,QAAIC,gBAAgB,SAAhBA,aAAgB;AAAA,eAAM6M,SAAS5M,YAAT,EAAN;AAAA,KAApB;AAF4E,QAGpE+C,IAHoE,GAG3DvG,MAH2D,CAGpEuG,IAHoE;;AAI5E,QAAMlH,aAAawS,SAAS3T,WAA5B;AACA,QAAMyD,qBAAqBkQ,SAASnQ,kBAAT,CAA4BE,mBAAvD;;AAEA,QAAMoQ,mBAAmB,SAAnBA,gBAAmB;AAAA,eAASF,SAC9BnQ,mBAAmBuB,KAAnB,CAD8B,EAE9BA,KAF8B,EAG9BK,aAH8B,EAI9BD,WAJ8B,CAAT;AAAA,KAAzB;;AAOA,WAAOyO,SAAS1S,UAAT,EAAqB2S,gBAArB,EAAuCzL,IAAvC,CAAP;AACH,CAfM;;AAiBA,IAAM0L,qBAAqB,SAArBA,kBAAqB,CAACpN,KAAD,EAAW;AACzC,QAAMgN,WAAWhN,MAAM1B,KAAN,CAAY,KAAZ,CAAjB;AACA,QAAM1B,oBAAoBoD,MAAM/G,oBAAN,EAA1B;AACA+T,aAASzT,cAAT,GAA0BqD,kBAAkBhF,MAAlB,CAAyBpI,GAAzB,CAA6B;AAAA,eAAKO,EAAEN,IAAF,EAAL;AAAA,KAA7B,EAA4CI,IAA5C,CAAiD,GAAjD,CAA1B;;AAEA;AACA+M,sBAAkBW,gBAAlB,GAAqC,IAArC;AACAX,sBAAkBY,gBAAlB,GAAqC,IAArC;AACAZ,sBAAkBa,cAAlB,GAAmC,IAAnC;AACAuP,aAAStP,qBAAT,GAAiCC,qBAAjC;;AAEA,WAAOqP,QAAP;AACH,CAZM;;AAcP,IAAMK,SAAS,SAATA,MAAS,CAACvW,GAAD,EAAMd,IAAN,EAAYwK,EAAZ,EAAmB;AAC9B,QAAI5S,MAAM4S,GAAG1J,GAAH,EAAQd,IAAR,EAAc,CAAd,CAAV;;AAEA,SAAK,IAAItG,IAAI,CAAR,EAAW4d,MAAMxW,IAAIlG,MAA1B,EAAkClB,IAAI4d,GAAtC,EAA2C5d,GAA3C,EAAgD;AAC5C9B,cAASA,GAAT,SAAgB4S,GAAG1J,GAAH,EAAQd,IAAR,EAActG,CAAd,CAAhB;AACH;AACD,WAAO9B,GAAP;AACH,CAPD;;AASA,IAAM2f,QAAQ,SAARA,KAAQ,CAACzW,GAAD,EAAMc,MAAN,EAAcoC,GAAd,EAAmBwT,KAAnB,EAA6B;AACvC,QAAMtF,MAAMtQ,OAAOd,IAAIkD,GAAJ,CAAP,EAAiByT,aAA7B;AACA,WAAO3W,IAAIkD,GAAJ,MAAatG,iDAAb,GAAsB8Z,KAAtB,GAA8BtF,GAArC;AACH,CAHD;;AAKA,IAAMwF,oCACDlK,qDAAcA,CAACC,UADd,EAC2B,UAACyE,GAAD,EAAM/B,MAAN,EAAiB;AAC1C,QAAMwH,YAAYxH,OAAO,CAAP,aAAqBtV,KAArB,GAA6BsV,MAA7B,GAAsC,CAACA,MAAD,CAAxD;AACA,WAAOwH,UAAUC,IAAV,CAAe;AAAA,eAAO1F,OAAO2F,IAAI,CAAJ,CAAP,IAAiB3F,OAAO2F,IAAI,CAAJ,CAA/B;AAAA,KAAf,CAAP;AACH,CAJC,CAAN;;AAOA,IAAMC,iBAAiB,SAAjBA,cAAiB,CAACjgB,KAAD,EAAQsY,MAAR,EAAgB4H,SAAhB;AAAA,WAA8BL,cAAcK,SAAd,EAAyBlgB,KAAzB,EAAgCsY,MAAhC,CAA9B;AAAA,CAAvB;;AAEO,IAAM6H,yBAAyB,SAAzBA,sBAAyB,CAAChO,KAAD,EAAQiO,UAAR,EAAoC;AAAA,QAAhB9S,MAAgB,uEAAP,EAAO;;AACtE,QAAI+S,MAAM,EAAV;AACA,QAAMlD,YAAY7P,OAAO6P,SAAP,IAAoBvW,4DAAiBA,CAACC,GAAxD;AACA,QAAMyZ,kBAAkBhT,OAAOgT,eAAP,IAA0B,KAAlD;AACA,QAAMC,cAAchB,mBAAmBpN,KAAnB,CAApB;AACA,QAAMqO,oBAAoBD,YAAYpQ,eAAZ,EAA1B;;AAEA,QAAI,CAACiQ,WAAWrd,MAAhB,EAAwB;AACpBsd,cAAM,CAAC;AAAA,mBAAM,KAAN;AAAA,SAAD,CAAN;AACH,KAFD,MAEO;AACHA,cAAMD,WAAWze,GAAX,CAAe;AAAA,mBAAc,YAAmB;AAAA,oBAAlB6b,QAAkB,uEAAP,EAAO;AAAA,4CACRA,QADQ,CAC1CpM,WAD0C;AAAA,oBAC1CA,WAD0C,yCAC5B,CAAC,EAAD,EAAK,EAAL,CAD4B;AAAA,oBAClBqP,KADkB,GACRjD,QADQ,CAClBiD,KADkB;;AAAA,kDAEXrP,WAFW;AAAA;AAAA,oBAE3CtF,UAF2C,iCAE9B,EAF8B;AAAA;AAAA,oBAE1B4U,MAF0B,kCAEjB,EAFiB;;AAGlD,oBAAMC,OAAO7U,WAAW/I,MAAxB;AACA,oBAAM6d,YAAY,EAAlB;;AAEA,oBAAID,IAAJ,EAAU;AACN,yBAAK,IAAI9e,IAAI,CAAR,EAAW4d,MAAMrO,YAAYrO,MAAlC,EAA0ClB,IAAI4d,GAA9C,EAAmD5d,GAAnD,EAAwD;AACpD,4BAAMM,MAAMiP,YAAYvP,CAAZ,CAAZ;AACA,4BAAM9B,MAAMoC,IAAIH,IAAJ,EAAZ;AACA4e,kCAAU7gB,GAAV,IAAiB,CAAjB;AACH;AACJ;AACD,oBAAM8gB,YAAYte,OAAOmI,IAAP,CAAY+V,SAAS,EAArB,CAAlB;AACA,uBAAOC,OAAO3d,MAAP,IAAiB8d,UAAU9d,MAA3B,GAAoC,UAACgH,MAAD,EAASlI,CAAT,EAAe;AACtD,wBAAMif,UAAUH,OAAOC,UAAUpB,OAAO1T,UAAP,EAAmB/B,MAAnB,EAA2B2V,KAA3B,EAAkC7d,CAAlC,CAAV,CAAP,GAAyD,IAAzE;;AAEA,wBAAIye,eAAJ,EAAqB;AACjB,+BAAOO,UAAUE,KAAV,CAAgB,UAAC/W,KAAD,EAAW;AAC9B,gCAAMqQ,MAAMtQ,OAAOC,KAAP,EAAc4V,aAA1B;AACA,mCAAOK,eAAe5F,GAAf,EAAoBoG,MAAMzW,KAAN,CAApB,EAAkCwW,kBAAkBxW,KAAlB,EAAyBgX,GAAzB,CAA6B3N,OAA/D,CAAP;AACH,yBAHM,KAGDyN,OAHN;AAIH;AACD,2BAAOA,OAAP;AACH,iBAVM,GAUH;AAAA,2BAAM,KAAN;AAAA,iBAVJ;AAWH,aAzBiC,CAyB/BrO,SAzB+B,CAAb;AAAA,SAAf,CAAN;AA0BH;;AAED,QAAIwO,sBAAJ;AACA,QAAI9D,cAAcvW,4DAAiBA,CAACC,GAApC,EAAyC;AACrCoa,wBAAgBV,YAAYvK,MAAZ,CAAmB;AAAA,mBAAUqK,IAAIU,KAAJ,CAAU;AAAA,uBAAMpO,GAAG5I,MAAH,CAAN;AAAA,aAAV,CAAV;AAAA,SAAnB,EAA0D;AACtEwD,uBAAW;AAD2D,SAA1D,CAAhB;AAGH,KAJD,MAIO;AACH0T,wBAAgBV,YAAYvK,MAAZ,CAAmB;AAAA,mBAAUqK,IAAIN,IAAJ,CAAS;AAAA,uBAAMpN,GAAG5I,MAAH,CAAN;AAAA,aAAT,CAAV;AAAA,SAAnB,EAAyD;AACrEwD,uBAAW;AAD0D,SAAzD,CAAhB;AAGH;;AAED,WAAO0T,aAAP;AACH,CAlDM;;AAqDA,IAAMjN,kBAAkB,SAAlBA,eAAkB,CAAC0J,QAAD,EAAWhK,YAAX,EAA4D;AAAA,QAAnCC,SAAmC,uEAAvB;AAAA,eAAO0G,GAAP;AAAA,KAAuB;AAAA,QAAX/M,MAAW;AAAA,QAEnFC,SAFmF,GAGnFD,MAHmF,CAEnFC,SAFmF;;AAIvF,QAAMuR,gBAAgBpB,SAASnP,aAAT,GAAyBa,SAAzB,EAAtB;;AAJuF,wBASnF8P,aACAxB,SAASjN,KAAT,CAAelD,SAAf,CADA,EAEAoG,SAFA,EAGArG,MAHA,EAIAoQ,QAJA,EAKA;AAAA,0CAAIjQ,MAAJ;AAAIA,kBAAJ;AAAA;;AAAA,eAAeoR,yCAA2BpR,MAA3B,SAAmCiG,YAAnC,EAAiDoL,aAAjD,GAAf;AAAA,KALA,CATmF;AAAA,QAOnFC,eAPmF,iBAOnFA,eAPmF;AAAA,QAQnFC,YARmF,iBAQnFA,YARmF;;AAiBvF,QAAMkC,YAAY,EAAlB;AACA3e,WAAOmI,IAAP,CAAYqU,eAAZ,EAA6B5T,IAA7B,GAAoC1I,OAApC,CAA4C,UAACsJ,CAAD,EAAO;AAC/C,YAAIgT,gBAAgBhT,CAAhB,CAAJ,EAAwB;AACpB,gBAAMoV,SAASzD,SAASjN,KAAT,CAAelD,SAAf,CAAf;AACA,gBAAM6T,aAAapC,aAAajT,CAAb,CAAnB;AACAoV,mBAAO3V,WAAP,GAAqBuT,gBAAgBhT,CAAhB,EAAmB/J,IAAnB,CAAwB,GAAxB,CAArB;AACAmf,mBAAOtR,qBAAP,GAA+BC,qBAA/B;;AAEA,gBAAMuR,oBAAoB,SAApBA,iBAAoB;AAAA,uBAAU3N,aAAaqN,KAAb,CAAmB;AAAA,2BAAKhX,OAAOoD,CAAP,EAAUyS,aAAV,KAA4BwB,WAAW1W,IAAX,CAAgByC,CAAhB,CAAjC;AAAA,iBAAnB,CAAV;AAAA,aAA1B;AACA;AACA,gBAAII,SAAJ,EAAe;AACXK,mCAAmB8P,QAAnB,EAA6ByD,MAA7B,EAAqCrb,yDAAcA,CAACC,MAApD,EAA4DuH,MAA5D,EAAoE+T,iBAApE;AACH;AACDF,mBAAO9D,WAAP,CAAmB8D,OAAO9D,WAAP,CAAmBta,MAAnB,GAA4B,CAA/C,EAAkDwa,IAAlD,GAAyDyB,aAAajT,CAAb,CAAzD;;AAEAmV,sBAAUve,IAAV,CAAewe,MAAf;AACH;AACJ,KAhBD;;AAmBA,WAAOD,SAAP;AACH,CAtCM;AAuCA,IAAMI,uBAAuB,SAAvBA,oBAAuB,CAACnC,QAAD,EAAWxS,UAAX,EAAuB+Q,QAAvB,EAAiC6D,YAAjC,EAA+CnC,QAA/C,EAA4D;AAC5FD,aAAS3T,WAAT,GAAuBmB,UAAvB;AACAwS,aAAStP,qBAAT,GAAiCC,qBAAjC;AACAlC,uBACI8P,QADJ,EAEIyB,QAFJ,EAGIrZ,yDAAcA,CAACC,MAHnB,EAIK,EAAEuH,QAAQiU,YAAV,EAJL,EAKMnC,QALN;AAOH,CAVM;;AAaA,IAAMoC,kBAAkB,SAAlBA,eAAkB,CAAC9D,QAAD,EAAW0B,QAAX,EAAqBmC,YAArB,EAAmCE,WAAnC,EAAmD;AAC9E,QAAIC,eAAe,EAAnB;;AAD8E,QAGxE7N,IAHwE,GAG/D0N,YAH+D,CAGxE1N,IAHwE;;;AAK9E,QAAMsN,SAASzD,SAASjN,KAAT,CAAegR,YAAYlU,SAA3B,CAAf;AACA,QAAMoU,mBAAmBzC,aACrBiC,MADqB,EAErB/B,QAFqB,EAGrBmC,YAHqB,EAIrB7D,QAJqB,EAKrBS,wBALqB,CAAzB;AAOA,QAAML,YAAYD,cAAchK,IAAd,EAAoBiK,SAAtC;;AAEAwD,yBAAqBH,MAArB,EAA6BQ,iBAAiB7D,UAAU,CAAV,CAAjB,CAA7B,EAA6DJ,QAA7D,EAAuE6D,YAAvE,EAAqFnC,QAArF;;AAEA,QAAItB,UAAU/a,MAAV,GAAmB,CAAvB,EAA0B;AACtB2e,uBAAehE,SAASjN,KAAT,CAAegR,YAAYlU,SAA3B,CAAf;AACA+T,6BAAqBI,YAArB,EAAmCC,iBAAiB7D,UAAU,CAAV,CAAjB,CAAnC,EAAmEJ,QAAnE,EAA6E6D,YAA7E,EAA2FnC,QAA3F;AACA,eAAO,CAAC+B,MAAD,EAASO,YAAT,CAAP;AACH;;AAED,WAAOP,MAAP;AACH,CAxBM;;AA0BA,IAAMS,mBAAmB,SAAnBA,gBAAmB,CAAClE,QAAD,EAAWmE,SAAX,EAAsBvU,MAAtB,EAA8B8G,SAA9B,EAA4C;AACxE,QAAM+M,SAASzD,SAASjN,KAAT,CAAenD,OAAOC,SAAtB,CAAf;AACA,QAAIuU,gBAAgBD,SAApB;AACA,QAAIvU,OAAOuG,IAAP,KAAgBC,oDAAaA,CAACkB,OAAlC,EAA2C;AACvC8M,wBAAgB1N,UAAUqH,MAAV,CAAiB;AAAA,mBAAaoG,UAAUzV,OAAV,CAAkB0C,SAAlB,MAAiC,CAAC,CAA/C;AAAA,SAAjB,CAAhB;AACH;AACD;AACA;AACAqS,WAAOzV,cAAP,GAAwBoW,cAAc9f,IAAd,CAAmB,GAAnB,CAAxB;AACAmf,WAAOtR,qBAAP,GAA+BC,qBAA/B;;AAEAlC,uBACI8P,QADJ,EAEIyD,MAFJ,EAGIrb,yDAAcA,CAACE,OAHnB,EAII,EAAE6b,oBAAF,EAAavU,cAAb,EAAqByU,iBAAiBD,aAAtC,EAJJ,EAKI,IALJ;;AAQA,WAAOX,MAAP;AACH,CApBM;;AAuBA,IAAM3M,mBAAmB,SAAnBA,gBAAmB,CAACkJ,QAAD,EAAWsE,YAAX,EAAyB1U,MAAzB,EAAiC8G,SAAjC;AAAA,WAC5B4N,aAAargB,GAAb,CAAiB;AAAA,eACbigB,iBAAiBlE,QAAjB,EAA2BuE,UAA3B,EAAuC3U,MAAvC,EAA+C8G,SAA/C,CADa;AAAA,KAAjB,CAD4B;AAAA,CAAzB;;AAIA,IAAMpE,qBAAqB,SAArBA,kBAAqB,CAAC1G,UAAD,EAAgB;AAC9C;AACAA,iBAAa4Y,sDAAOA,CAAC,EAAR,EAAY5Y,UAAZ,CAAb;AACA,QAAI,CAACA,WAAW5B,IAAhB,EAAsB;AAClB4B,mBAAW5B,IAAX,GAAkByL,gDAASA,CAACC,SAA5B;AACH;;AAED,QAAI,CAAC9J,WAAW+J,OAAhB,EAAyB;AACrB,gBAAQ/J,WAAW5B,IAAnB;AACA,iBAAKyL,gDAASA,CAAC4B,OAAf;AACIzL,2BAAW+J,OAAX,GAAqBsC,qDAAcA,CAACC,UAApC;AACA;AACJ;AACA,iBAAKzC,gDAASA,CAACC,SAAf;AACI9J,2BAAW+J,OAAX,GAAqBC,uDAAgBA,CAACuB,WAAtC;AACA;AAPJ;AASH;;AAED,WAAOvL,UAAP;AACH,CApBM;;AAsBA,IAAM6Y,qBAAqB,SAArBA,kBAAqB,CAAC7Y,UAAD,EAAgB;AAAA,QACtC5B,IADsC,GACd4B,UADc,CACtC5B,IADsC;AAAA,QAChC2L,OADgC,GACd/J,UADc,CAChC+J,OADgC;AAAA,QACvBzR,IADuB,GACd0H,UADc,CACvB1H,IADuB;;AAE9C,QAAI8F,SAASyL,gDAASA,CAACC,SAAnB,IAAgC1L,SAASyL,gDAASA,CAAC4B,OAAvD,EAAgE;AAC5D,YAAI,CAACJ,qDAAaA,CAAC9M,GAAd,CAAkBwL,OAAlB,CAAL,EAAiC;AAC7B,kBAAM,IAAIxK,KAAJ,uDAA6DwK,OAA7D,kBAAiFzR,IAAjF,YAAN;AACH;AACJ,KAJD,MAIO;AACH,cAAM,IAAIiH,KAAJ,4CAAkDnB,IAAlD,kBAAmE9F,IAAnE,YAAN;AACH;AACJ,CATM;;AAWA,IAAMwgB,4BAA4B,SAA5BA,yBAA4B;AAAA,WAAUha,OAAOzG,GAAP,CAAW,UAAC2H,UAAD,EAAgB;AAC1EA,qBAAa0G,mBAAmB1G,UAAnB,CAAb;AACA6Y,2BAAmB7Y,UAAnB;AACA,eAAOA,UAAP;AACH,KAJkD,CAAV;AAAA,CAAlC;;AAMA,IAAM+Y,mBAAmB,SAAnBA,gBAAmB,CAACja,MAAD,EAASka,UAAT,EAAwB;AACpDla,WAAO3F,OAAP,CAAe,UAAC6G,UAAD,EAAgB;AAC3B,YAAMiZ,cAAcjZ,WAAWkZ,EAA/B;AACA,YAAI,CAACD,WAAL,EAAkB;AAAE;AAAS;;AAE7B,YAAMpW,MAAMmW,WAAWlW,OAAX,CAAmB9C,WAAW1H,IAA9B,CAAZ;AACA0gB,mBAAWnW,GAAX,IAAkBoW,WAAlB;AACAjZ,mBAAW1H,IAAX,GAAkB2gB,WAAlB;AACA,eAAOjZ,WAAWkZ,EAAlB;AACH,KARD;AASH,CAVM;;AAYA,IAAMC,aAAa,SAAbA,UAAa,CAACC,QAAD,EAAWva,IAAX,EAAiBC,MAAjB,EAAyBC,OAAzB,EAAqC;AAC3DD,aAASga,0BAA0Bha,MAA1B,CAAT;AACAC,cAAU9F,OAAOgH,MAAP,CAAchH,OAAOgH,MAAP,CAAc,EAAd,EAAkBoZ,uDAAlB,CAAd,EAAgDta,OAAhD,CAAV;AACA,QAAMZ,YAAYM,yDAAcA,CAACD,GAAf,CAAmBO,QAAQU,UAA3B,CAAlB;;AAGA,QAAI,CAACtB,SAAL,EAAgB;AACZ,cAAM,IAAIoB,KAAJ,sCAA6CR,QAAQU,UAArD,aAAN;AACH;;AAR0D,6BAU3BtB,UAAUnD,OAAV,CAAkB6D,IAAlB,EAAwBC,MAAxB,EAAgCC,OAAhC,CAV2B;AAAA;AAAA,QAUpDiC,MAVoD;AAAA,QAU5CmE,aAV4C;;AAW3D4T,qBAAiBja,MAAjB,EAAyBkC,MAAzB;AACA,QAAMkN,WAAWtG,mEAAYA,CAACzC,aAAb,EAA4BrG,MAA5B,EAAoCkC,MAApC,CAAjB;;AAEA;AACA,QAAMsY,YAAYtL,oDAAUA,CAACC,eAAX,CAA2BC,QAA3B,EAAqCnP,QAAQzG,IAA7C,CAAlB;AACA8gB,aAAS1T,kBAAT,GAA8B4T,SAA9B;;AAEA;AACAF,aAASlX,WAAT,GAAuBiD,cAAc1L,MAAd,IAAwB0L,cAAc,CAAd,EAAiB1L,MAAzC,WAAuD0L,cAAc,CAAd,EAAiB1L,MAAjB,GAA0B,CAAjF,IAAuF,EAA9G;;AAEA;AACA,QAAM8f,eAAe,EAArB;AAtB2D,QAuBnD9Y,MAvBmD,GAuBxC6Y,SAvBwC,CAuBnD7Y,MAvBmD;;AAwB3D,QAAM+Y,gBAAgB/Y,OAAOpI,GAAP,CAAW;AAAA,eAASqI,MAAM7B,IAAN,EAAT;AAAA,KAAX,CAAtB;AACA,QAAM4a,sBAAsBhZ,OAAOpI,GAAP,CAAW;AAAA,eAASqI,MAAMyE,aAAN,EAAT;AAAA,KAAX,CAA5B;AACAuC,wEAAkBA,CAAC0R,SAASlX,WAA5B,EAAyC,UAAC3J,CAAD,EAAO;AAC5CghB,qBAAahhB,CAAb,IAAkBwa,qBAAqBtS,MAArB,EAA6BgZ,mBAA7B,EAAkDD,aAAlD,EAAiEjhB,CAAjE,CAAlB;AACH,KAFD;AAGA+gB,cAAU1T,mBAAV,GAAgC2T,YAAhC;;AAEAH,aAAShX,cAAT,GAA2BtD,OAAOzG,GAAP,CAAW;AAAA,eAAKwL,EAAEvL,IAAP;AAAA,KAAX,CAAD,CAA0BI,IAA1B,EAA1B;AACA0gB,aAASpU,WAAT,GAAuBjG,QAAQU,UAAR,KAAuBd,iDAAUA,CAACC,IAAlC,GAAyCc,+DAAgBA,CAACb,IAAjB,CAAzC,GAAkEE,QAAQU,UAAjG;AACA,WAAO2Z,QAAP;AACH,CAlCM;;AAoCA,IAAMM,gBAAgB,SAAhBA,aAAgB,CAAC5a,MAAD,EAAS4B,KAAT,EAAmB;AAC5C,QAAInI,IAAI,CAAR;;AAEA,WAAOA,IAAIuG,OAAOrF,MAAlB,EAA0B,EAAElB,CAA5B,EAA+B;AAC3B,YAAImI,UAAU5B,OAAOvG,CAAP,EAAUD,IAAxB,EAA8B;AAC1B,mBAAO;AACHA,sBAAMoI,KADH;AAEHtC,sBAAMU,OAAOvG,CAAP,EAAUwR,OAAV,IAAqBjL,OAAOvG,CAAP,EAAU6F,IAFlC;AAGH8I,uBAAO3O;AAHJ,aAAP;AAKH;AACJ;AACD,WAAO,IAAP;AACH,CAbM;;AAeA,IAAMohB,yBAAyB,SAAzBA,sBAAyB,CAAC7B,UAAD,EAAgB;AAClD,QAAI3T,SAAS,EAAb;AACA,QAAI0P,kBAAJ;AACAA,gBAAYiE,WAAW9D,EAAvB;AACA,YAAQH,SAAR;AACA,aAAKrX,yDAAcA,CAACC,MAApB;AACI0H,qBAAS,CAAC2T,WAAW5D,QAAZ,CAAT;AACA;AACJ,aAAK1X,yDAAcA,CAACE,OAApB;AACIyH,qBAAS,CAAC2T,WAAW7D,IAAX,CAAgBwE,eAAjB,CAAT;AACA;AACJ,aAAKjc,yDAAcA,CAACO,IAApB;AACIoH,qBAAS,CAAC2T,WAAW5D,QAAZ,CAAT;AACA;AACJ,aAAK1X,yDAAcA,CAACG,OAApB;AACIkX,wBAAY,SAAZ;AACA1P,qBAAS,CAAC2T,WAAW7D,IAAX,CAAgB/P,aAAhB,CAA8BV,KAA9B,CAAoC,GAApC,CAAD,EAA2CsU,WAAW5D,QAAtD,CAAT;AACA;AACJ;AACIL,wBAAY,IAAZ;AAfJ;;AAkBA,WAAO;AACHA,4BADG;AAEH1P;AAFG,KAAP;AAIH,CA1BM;;AA4BP,IAAMyV,gCAAgC,SAAhCA,6BAAgC,CAACzQ,SAAD,EAAY0Q,SAAZ,EAA0B;AAC5D,QAAMC,cAAcD,UAAUE,cAAV,EAApB;AACA,QAAIC,iBAAiB7Q,SAArB;;AAEA2Q,gBAAY3gB,OAAZ,CAAoB,UAAC2e,UAAD,EAAgB;AAChC,YAAI,CAACA,UAAL,EAAiB;AACb;AACH;;AAH+B,oCAKF6B,uBAAuB7B,UAAvB,CALE;AAAA,YAKxBjE,SALwB,yBAKxBA,SALwB;AAAA,YAKb1P,MALa,yBAKbA,MALa;;AAMhC,YAAI0P,SAAJ,EAAe;AAAA;;AACXmG,6BAAiB,mCAAenG,SAAf,4CAA6B1P,MAA7B,UAAqC;AAClDF,2BAAW;AADuC,aAArC,GAAjB;AAGH;AACJ,KAXD;;AAaA,WAAO+V,cAAP;AACH,CAlBD;;AAoBA,IAAMC,mBAAmB,SAAnBA,gBAAmB,CAAC9Q,SAAD,EAAY+Q,IAAZ,EAAqB;AAC1C,SAAK,IAAI3hB,IAAI,CAAR,EAAW4d,MAAM+D,KAAKzgB,MAA3B,EAAmClB,IAAI4d,GAAvC,EAA4C5d,GAA5C,EAAiD;AAC7C,YAAMsQ,QAAQqR,KAAK3hB,CAAL,CAAd;AACA4Q,oBAAYyQ,8BAA8BzQ,SAA9B,EAAyCN,KAAzC,CAAZ;AACH;AACD,WAAOM,SAAP;AACH,CAND;;AAQA,IAAMgR,uBAAuB,SAAvBA,oBAAuB,CAACN,SAAD,EAAY1Q,SAAZ,EAA0D;AAAA,QAAnCnF,MAAmC,uEAA1B,EAA0B;AAAA,QAAtBoW,YAAsB,uEAAP,EAAO;;AACnF,QAAMC,qBAAqBD,aAAaC,kBAAxC;AACA,QAAMC,gBAAgBF,aAAaE,aAAb,IAA8B,EAApD;;AAEA,QAAIT,cAAcQ,kBAAlB,EAAsC;AAClC;AACH;;AAED,QAAME,YAAYD,cAAc7gB,MAAd,GAAuB6gB,cAAcxX,OAAd,CAAsB+W,SAAtB,MAAqC,CAAC,CAA7D,GAAiE,IAAnF;;AAEAU,iBAAaV,UAAUW,iBAAV,CAA4BrR,SAA5B,EAAuCnF,MAAvC,CAAb;;AAEA,QAAMyW,WAAWZ,UAAUa,SAA3B;AACAD,aAASthB,OAAT,CAAiB,UAACwhB,KAAD,EAAW;AACxB,YAAMX,iBAAiBJ,8BAA8BzQ,SAA9B,EAAyCwR,KAAzC,CAAvB;AACAR,6BAAqBQ,KAArB,EAA4BX,cAA5B,EAA4ChW,MAA5C,EAAoDoW,YAApD;AACH,KAHD;AAIH,CAjBD;;AAmBO,IAAM1R,sBAAsB,SAAtBA,mBAAsB,CAACG,KAAD,EAAW;AAC1C,WAAOA,MAAM+R,OAAN,IAAiB/R,MAAMkL,WAAN,CAAkB8G,IAAlB,CAAuB;AAAA,eAAK1Y,EAAE6R,EAAF,KAASxX,yDAAcA,CAACG,OAA7B;AAAA,KAAvB,CAAxB,EAAsF;AAClFkM,gBAAQA,MAAM+R,OAAd;AACH;AACD,WAAO/R,KAAP;AACH,CALM;;AAOA,IAAMP,mBAAmB,SAAnBA,gBAAmB,CAACO,KAAD,EAAW;AACvC,WAAOA,MAAM+R,OAAb,EAAsB;AAClB/R,gBAAQA,MAAM+R,OAAd;AACH;AACD,WAAO/R,KAAP;AACH,CALM;;AAOA,IAAMiS,qBAAqB,SAArBA,kBAAqB,CAACjS,KAAD,EAAsB;AAAA,QAAdqR,IAAc,uEAAP,EAAO;;AACpD,WAAOrR,MAAM+R,OAAb,EAAsB;AAClBV,aAAK7gB,IAAL,CAAUwP,KAAV;AACAA,gBAAQA,MAAM+R,OAAd;AACH;AACD,WAAOV,IAAP;AACH,CANM;;AAQA,IAAMnR,2BAA2B,SAA3BA,wBAA2B,CAACjB,WAAD,EAAca,UAAd,EAA0BoS,cAA1B,EAA0C/W,MAA1C,EAAqD;AACzF,QAAIkQ,iBAAJ;AACA,QAAI/K,kBAAJ;AAFyF,QAGjFZ,oBAHiF,GAGrCwS,cAHqC,CAGjFxS,oBAHiF;AAAA,QAG3DyS,iBAH2D,GAGrCD,cAHqC,CAG3DC,iBAH2D;;AAIzF,QAAM9S,sBAAsB6S,eAAe5S,QAA3C;AACA,QAAM8S,8BAA8BjX,OAAOiX,2BAA3C;AACA,QAAMC,WAAW,SAAXA,QAAW,CAACC,KAAD,EAAW;AACxB,YAAMhJ,SAASnO,OAAOkX,QAAP,IAAoB;AAAA,mBAAM,IAAN;AAAA,SAAnC;AACA,eAAO/I,OAAOgJ,KAAP,EAAcnX,MAAd,CAAP;AACH,KAHD;;AAKA,QAAIoX,YAAY,EAAhB;;AAEA,QAAItT,gBAAgB,IAAhB,IAAwB9D,OAAOqX,UAAP,KAAsB,IAAlD,EAAwD;AACpDD,oBAAY,CAAC;AACTlH,sBAAU;AADD,SAAD,CAAZ;AAGAA,mBAAW,EAAX;AACH,KALD,MAKO;AAAA;;AACH,YAAIoH,kBAAkBriB,OAAOme,MAAP,CAAc7O,qBAAqBgT,cAAnC,CAAtB;AACA,YAAIP,sBAAsB,KAA1B,EAAiC;AAC7BM,8BAAkBA,gBAAgBnJ,MAAhB,CAAuB;AAAA,uBAAKhQ,EAAE6B,MAAF,CAASmE,QAAT,KAAsBD,mBAA3B;AAAA,aAAvB,CAAlB;AACH;;AAED,YAAMsT,mBAAmBF,gBAAgBnJ,MAAhB,CAAuB+I,QAAvB,EAAiC7iB,GAAjC,CAAqC;AAAA,mBAAUojB,OAAOzX,MAAP,CAAckQ,QAAxB;AAAA,SAArC,CAAzB;;AAEA,YAAMoG,gBAAgB,EAAtB;;AAEA,YAAIU,sBAAsB,KAA1B,EAAiC;AAC7B,gBAAMU,wBAAwBziB,OAAOme,MAAP,CAAc7O,qBAAqBgT,cAAnC,CAA9B;;AAEAG,kCAAsBviB,OAAtB,CAA8B,UAACwiB,SAAD,EAAe;AACzC,oBAAMC,aAAaD,UAAU3X,MAA7B;AACA,oBAAI4X,WAAWC,aAAX,KAA6B,KAA7B,IAAsCD,WAAWH,MAAX,KAAsBzX,OAAOyX,MAAnE,IACIG,WAAWzT,QAAX,KAAwBD,mBADhC,EACqD;AACjDoS,kCAAcjhB,IAAd,CAAmBsiB,UAAU9S,KAA7B;AACAqL,+BAAWwH,sBAAsBvJ,MAAtB,CAA6B;AAAA,+BAAKhQ,MAAMwZ,SAAX;AAAA,qBAA7B,EAAmDtjB,GAAnD,CAAuD;AAAA,+BAAK8J,EAAE6B,MAAF,CAASkQ,QAAd;AAAA,qBAAvD,CAAX;AACAA,6BAASza,MAAT,IAAmB2hB,UAAU/hB,IAAV,CAAe;AAC9B6a,0CAD8B;AAE9B4H,gCAAQH,UAAU9S,KAFY;AAG9BqR,8BAAMY,mBAAmBa,UAAU9S,KAA7B;AAHwB,qBAAf,CAAnB;AAKH;AACJ,aAZD;AAaH;;AAGDqL,mBAAW,aAAGpY,MAAH,2CAAiB0f,gBAAjB,IAAmC1T,WAAnC,IAAiDqK,MAAjD,CAAwD;AAAA,mBAAKhQ,MAAM,IAAX;AAAA,SAAxD,CAAX;AACAiZ,kBAAU/hB,IAAV,CAAe;AACX6a,8BADW;AAEXoG,qCAAmBA,aAAnB,qBAAqCtW,OAAOsW,aAAP,IAAwB,EAA7D;AAFW,SAAf;AAIH;;AAED,QAAMjS,YAAYM,WAAWE,KAA7B;;AAEA,QAAMb,aAAa/O,OAAOgH,MAAP,CAAc;AAC7B8b,2BAAmBjU,WADU;AAE7BI;AAF6B,KAAd,EAGhBlE,MAHgB,CAAnB;;AAKA,QAAMyE,mBAAmBE,WAAWC,YAApC;AACA,QAAIqS,+BAA+BxS,gBAAnC,EAAqD;AACjDU,oBAAY0N,uBAAuBpO,gBAAvB,EAAyCyL,QAAzC,EAAmD;AAC3D8C,6BAAiBiE;AAD0C,SAAnD,CAAZ;AAGAd,6BAAqB1R,gBAArB,EAAuCU,SAAvC,EAAkDnB,UAAlD;AACH;;AAEDoT,cAAUjiB,OAAV,CAAkB,UAAC6iB,GAAD,EAAS;AACvB,YAAMC,mBAAmBpF,uBAAuBxO,SAAvB,EAAkC2T,IAAI9H,QAAtC,CAAzB;AACA,YAAMgG,OAAO8B,IAAI9B,IAAjB;;AAEA,YAAIA,IAAJ,EAAU;AACN,gBAAMvC,gBAAgBsC,iBAAiBgC,gBAAjB,EAAmC/B,KAAKgC,OAAL,EAAnC,CAAtB;AACAF,gBAAIF,MAAJ,CAAWtB,iBAAX,CAA6B7C,aAA7B,EAA4C3P,UAA5C;AACH,SAHD,MAGO;AACHmS,iCAAqB9R,SAArB,EAAgC4T,gBAAhC,EAAkDjU,UAAlD,EAA8D;AAC1DsS,+BAAe0B,IAAI1B,aADuC;AAE1DD,oCAAoBY,+BAA+BxS;AAFO,aAA9D;AAIH;AACJ,KAbD;AAcH,CAnFM;;AAqFA,IAAMO,4BAA4B,SAA5BA,yBAA4B,CAACT,oBAAD,EAAuBI,UAAvB,EAAmCoS,cAAnC,EAAsD;AAC3F,QAAMoB,mBAAmB5T,qBAAqB4T,gBAA9C;;AAEA,SAAK,IAAMV,MAAX,IAAqBU,gBAArB,EAAuC;AACnC,YAAMR,YAAYQ,iBAAiBV,MAAjB,CAAlB;AACA,YAAMG,aAAaD,UAAU3X,MAA7B;AACA,YAAMkE,sBAAsB6S,eAAe/W,MAAf,CAAsBmE,QAAlD;AACA,YAAMiU,wBAAwBrB,eAAe/S,UAAf,CAA0BoU,qBAA1B,GAC1BrB,eAAe/S,UAAf,CAA0BoU,qBAA1B,CAAgDR,UAAhD,EAA4Db,eAAe/W,MAA3E,CAD0B,GAC2D,IADzF;AAEA,YAAI4X,WAAWzT,QAAX,KAAwBD,mBAAxB,IAA+CkU,qBAAnD,EAA0E;AACtE,gBAAMC,gBAAgBT,WAAW1H,QAAjC;AACAnL,qCAAyBsT,aAAzB,EAAwC1T,UAAxC,EAAoD;AAChDJ,0DADgD;AAEhDyS,mCAAmB,KAF6B;AAGhD7S,0BAAUD;AAHsC,aAApD,EAIG0T,UAJH;AAKH;AACJ;AACJ,CAlBM;;AAoBA,IAAM9S,qBAAqB,SAArBA,kBAAqB,CAACP,oBAAD,EAA8C;AAAA,QAAvBvE,MAAuB,uEAAd,EAAc;AAAA,QAAV6E,KAAU;;AAC5E,QAAIyT,wBAAJ;AACA,QAAMrU,kBAAkBjE,OAAOiE,eAA/B;AACA,QAAMiM,WAAWlQ,OAAOkQ,QAAxB;AACA,QAAMzd,MAASuN,OAAOyX,MAAhB,SAA0BzX,OAAOmE,QAAvC;;AAEA,QAAIF,eAAJ,EAAqB;AACjBqU,0BAAkB/T,qBAAqBgT,cAAvC;AACH,KAFD,MAEO;AACHe,0BAAkB/T,qBAAqB4T,gBAAvC;AACH;;AAED,QAAIjI,aAAa,IAAjB,EAAuB;AACnB,eAAOoI,gBAAgB7lB,GAAhB,CAAP;AACH,KAFD,MAEO;AACH6lB,wBAAgB7lB,GAAhB,IAAuB;AACnBoS,wBADmB;AAEnB7E;AAFmB,SAAvB;AAIH;;AAED,WAAO,KAAP;AACH,CAtBM;;AAyBA,IAAMiH,yBAAyB,SAAzBA,sBAAyB,CAACsN,SAAD,EAAYzN,SAAZ,EAAuBD,WAAvB,EAAuC;AACzE,QAAM0R,sBAAsBhE,UAAUjY,MAAV,CAAiB,UAACC,GAAD,EAAMG,KAAN,EAAgB;AACzD,YAAIA,MAAMqE,WAAN,CAAkBzM,IAAlB,KAA2B,QAA/B,EAAyC;AACrCiI,gBAAIlH,IAAJ,+BAAYyR,UAAUqH,MAAV,CAAiB;AAAA,uBAAa3M,UAAUgX,MAAV,CAAiB9b,KAAjB,MAA4B,CAAC,CAA1C;AAAA,aAAjB,CAAZ;AACH,SAFD,MAEO,IAAIA,SAASmK,WAAb,EAA0B;AAC7BtK,gBAAIlH,IAAJ,CAASqH,KAAT;AACH;AACD,eAAOH,GAAP;AACH,KAP2B,EAOzB,EAPyB,CAA5B;AAQA,WAAO7G,MAAM+iB,IAAN,CAAW,IAAI1N,GAAJ,CAAQwN,mBAAR,CAAX,EAAyClkB,GAAzC,CAA6C;AAAA,eAASqI,MAAM/J,IAAN,EAAT;AAAA,KAA7C,CAAP;AACH,CAVM;;AAYP;;;;;;;AAOO,IAAM+lB,wBAAwB,SAAxBA,qBAAwB,CAAChc,KAAD,EAAQhK,KAAR,EAAkB;AACnD,QAAIgK,MAAMmQ,YAAV,EAAwB;AACpB,eAAOnQ,MAAMmQ,YAAN,GAAqBna,KAArB,CAAP;AACH;AACD,WAAOA,KAAP;AACH,CALM,C;;;;;;;;;;;AC9rBP,IAAM2K,YAAYsb,mBAAOA,CAAC,iCAAR,CAAlB;;AAEAC,OAAOC,OAAP,GAAiBxb,UAAUyb,OAAV,GAAoBzb,UAAUyb,OAA9B,GAAwCzb,SAAzD,C;;;;;;;;;;;;;;;;;ACFA;;;;;;IAMM8J,iB;;;;AACF;;;;;;;yCAOyBnH,M,EAAQ;AAC7B,gBAAI,CAACA,MAAL,EAAa;AACT,uBAAOmH,kBAAkB4R,oBAAzB;AACH;AACD,mBAAO9jB,OAAOgH,MAAP,CAAckL,kBAAkB4R,oBAAhC,EAAsD/Y,MAAtD,CAAP;AACH;;AAED;;;;;;;;;AAMA,+BAAatN,KAAb,EAAoB;AAAA;;AAChB,aAAKsmB,MAAL,GAActmB,KAAd;AACH;;AAED;;;;;;;;;;gCAMS;AACL,mBAAO,KAAKsmB,MAAZ;AACH;;AAED;;;;;;;;;mCAMY;AACR,mBAAO/L,OAAO,KAAK+L,MAAZ,CAAP;AACH;;;kCAEgBjM,G,EAAK;AAClB,mBAAQA,eAAe5F,iBAAhB,IAAsC,CAAC,CAACA,kBAAkBC,gBAAlB,GAAqC2F,GAArC,CAA/C;AACH;;;uCAEqBA,G,EAAK;AACvB,mBAAOA,eAAe5F,iBAAf,GAAmC4F,GAAnC,GAAyC5F,kBAAkBC,gBAAlB,GAAqC2F,GAArC,CAAhD;AACH;;;;;;AAGL;;;;;AAGA5F,kBAAkB8R,IAAlB,GAAyB,IAAI9R,iBAAJ,CAAsB,MAAtB,CAAzB;AACAA,kBAAkBoG,EAAlB,GAAuB,IAAIpG,iBAAJ,CAAsB,IAAtB,CAAvB;AACAA,kBAAkB+R,GAAlB,GAAwB,IAAI/R,iBAAJ,CAAsB,KAAtB,CAAxB;;AAEA;;;;;AAKAA,kBAAkB4R,oBAAlB,GAAyC;AACrCI,aAAShS,kBAAkBoG,EADU;AAErC6L,SAAKjS,kBAAkB+R,GAFc;AAGrCG,UAAMlS,kBAAkB8R,IAHa;AAIrC7Z,eAAW+H,kBAAkBoG;AAJQ,CAAzC;;AAOepG,gFAAf,E;;;;;;;;;;;;;;;;;;AC/EA;AACA;;AAEA,IAAMmS,kBAAkB,SAAlBA,eAAkB,CAACC,OAAD,EAAU7Z,KAAV,EAAiBC,GAAjB,EAAyB;AAC7C,QAAM6Z,UAAU,EAAhB;AACA,QAAI5a,OAAOc,KAAX;;AAEA,WAAOd,OAAOe,GAAd,EAAmB;AACf6Z,gBAAQnkB,IAAR,CAAauJ,IAAb;AACAA,gBAAQ2a,OAAR;AACH;AACDC,YAAQnkB,IAAR,CAAauJ,IAAb;;AAEA,WAAO4a,OAAP;AACH,CAXD;;AAaA,IAAMC,kBAAkB,SAAlBA,eAAkB,CAACC,YAAD,EAAehnB,KAAf,EAAyB;AAC7C,QAAIinB,UAAU,CAAd;AACA,QAAIC,WAAWF,aAAajkB,MAAb,GAAsB,CAArC;AACA,QAAIokB,eAAJ;AACA,QAAI1G,cAAJ;;AAEA;AACA,WAAOwG,WAAWC,QAAlB,EAA4B;AACxBC,iBAASF,UAAUhL,KAAKmL,KAAL,CAAW,CAACF,WAAWD,OAAZ,IAAuB,CAAlC,CAAnB;AACAxG,gBAAQuG,aAAaG,MAAb,CAAR;;AAEA,YAAInnB,SAASygB,MAAMzT,KAAf,IAAwBhN,QAAQygB,MAAMxT,GAA1C,EAA+C;AAC3C,mBAAOwT,KAAP;AACH,SAFD,MAEO,IAAIzgB,SAASygB,MAAMxT,GAAnB,EAAwB;AAC3Bga,sBAAUE,SAAS,CAAnB;AACH,SAFM,MAEA,IAAInnB,QAAQygB,MAAMzT,KAAlB,EAAyB;AAC5Bka,uBAAWC,SAAS,CAApB;AACH;AACJ;;AAED,WAAO,IAAP;AACH,CArBD;;AAuBC;;;;;;;;AAQM,SAASpU,qBAAT,CAAgCD,YAAhC,EAA8CnG,UAA9C,EAA0DW,MAA1D,EAAkE;AAAA,QAC/DwZ,OAD+D,GACnBxZ,MADmB,CAC/DwZ,OAD+D;AAAA,QACtDO,SADsD,GACnB/Z,MADmB,CACtD+Z,SADsD;AAAA,QAC3CR,OAD2C,GACnBvZ,MADmB,CAC3CuZ,OAD2C;AAAA,QAClC7Z,KADkC,GACnBM,MADmB,CAClCN,KADkC;AAAA,QAC3BC,GAD2B,GACnBK,MADmB,CAC3BL,GAD2B;;AAAA,+BAEhD6F,aAAawF,MAAb,EAFgD;AAAA;AAAA,QAE9DgP,IAF8D;AAAA,QAExDC,IAFwD;;AAIrE,QAAI,CAACT,OAAL,EAAc;AACV9Z,gBAASA,UAAU,CAAV,KAAgB,CAACA,KAAD,IAAUA,QAAQsa,IAAlC,CAAD,GAA4CA,IAA5C,GAAmDta,KAA3D;AACAC,cAAOA,QAAQ,CAAR,KAAc,CAACA,GAAD,IAAQA,MAAMsa,IAA5B,CAAD,GAAuCA,OAAO,CAA9C,GAAmDta,GAAzD;;AAEA,YAAIoa,SAAJ,EAAe;AACXR,sBAAU5K,KAAKuL,IAAL,CAAUvL,KAAKwL,GAAL,CAASxa,MAAMD,KAAf,IAAwBqa,SAAlC,CAAV;AACH;;AAEDP,kBAAUF,gBAAgBC,OAAhB,EAAyB7Z,KAAzB,EAAgCC,GAAhC,CAAV;AACH;;AAED,QAAI6Z,QAAQ,CAAR,IAAaQ,IAAjB,EAAuB;AACnBR,gBAAQY,OAAR,CAAgBJ,IAAhB;AACH;AACD,QAAIR,QAAQA,QAAQ/jB,MAAR,GAAiB,CAAzB,KAA+BwkB,IAAnC,EAAyC;AACrCT,gBAAQnkB,IAAR,CAAa4kB,OAAO,CAApB;AACH;;AAED,QAAMP,eAAe,EAArB;AACA,SAAK,IAAInlB,IAAI,CAAb,EAAgBA,IAAIilB,QAAQ/jB,MAAR,GAAiB,CAArC,EAAwClB,GAAxC,EAA6C;AACzCmlB,qBAAarkB,IAAb,CAAkB;AACdqK,mBAAO8Z,QAAQjlB,CAAR,CADO;AAEdoL,iBAAK6Z,QAAQjlB,IAAI,CAAZ;AAFS,SAAlB;AAIH;;AAED,QAAMmR,aAAa,EAAnB;AACAhC,oFAAkBA,CAACrE,UAAnB,EAA+B,UAAC9K,CAAD,EAAO;AAClC,YAAM2K,QAAQsG,aAAa3D,YAAb,CAA0BhH,IAA1B,CAA+BtG,CAA/B,CAAd;AACA,YAAI2K,iBAAiBiI,4DAArB,EAAwC;AACpCzB,uBAAWrQ,IAAX,CAAgB6J,KAAhB;AACA;AACH;;AAED,YAAMiU,QAAQsG,gBAAgBC,YAAhB,EAA8Bxa,KAA9B,CAAd;AACAwG,mBAAWrQ,IAAX,CAAmB8d,MAAMzT,KAAzB,SAAkCyT,MAAMxT,GAAxC;AACH,KATD;;AAWA,WAAO,EAAE+F,sBAAF,EAAcC,MAAM6T,OAApB,EAAP;AACH,C;;;;;;;;;;;;;;;;;;;;;;AC1FD;AACA;;AAEA;;;;;;;;;;;;;;AAcA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0CO,IAAM9Q,SAAS,SAATA,MAAS;AAAA,sCAAIpL,IAAJ;AAAIA,YAAJ;AAAA;;AAAA,WAAa;AAAA,eAAM+c,GAAG3R,MAAH,WAAapL,IAAb,CAAN;AAAA,KAAb;AAAA,CAAf;;AAEP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BO,IAAMqL,UAAU,SAAVA,OAAU;AAAA,uCAAIrL,IAAJ;AAAIA,YAAJ;AAAA;;AAAA,WAAa;AAAA,eAAM+c,GAAG1R,OAAH,WAAcrL,IAAd,CAAN;AAAA,KAAb;AAAA,CAAhB;;AAEP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyDO,IAAMmL,MAAM,SAANA,GAAM;AAAA,uCAAInL,IAAJ;AAAIA,YAAJ;AAAA;;AAAA,WAAa;AAAA,eAAM+c,GAAG5R,GAAH,WAAUnL,IAAV,CAAN;AAAA,KAAb;AAAA,CAAZ;;AAEP;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BO,IAAM+C,UAAU,SAAVA,OAAU;AAAA,uCAAI/C,IAAJ;AAAIA,YAAJ;AAAA;;AAAA,WAAa;AAAA,eAAM+c,GAAGha,OAAH,WAAc/C,IAAd,CAAN;AAAA,KAAb;AAAA,CAAhB;;AAEP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkCO,IAAMkL,UAAU,SAAVA,OAAU;AAAA,uCAAI8R,UAAJ;AAAIA,kBAAJ;AAAA;;AAAA,WACnB,UAACD,EAAD,EAAsC;AAAA,YAAjCra,MAAiC,uEAAxB,EAAEC,WAAW,IAAb,EAAwB;;AAClC,YAAIsa,YAAYF,EAAhB;AACA,YAAIG,mBAAJ;AACA,YAAM1E,cAAc,EAApB;;AAEAwE,mBAAWnlB,OAAX,CAAmB,UAAC0a,SAAD,EAAe;AAC9B0K,wBAAY1K,UAAU0K,SAAV,CAAZ;AACAzE,wBAAYzgB,IAAZ,uCAAoBklB,UAAUxK,WAA9B;AACA,gBAAI,CAACyK,UAAL,EAAiB;AACbA,6BAAaD,SAAb;AACH;AACJ,SAND;;AAQA,YAAIC,cAAcA,eAAeD,SAAjC,EAA4C;AACxCC,uBAAWC,OAAX;AACH;;AAED;AACAF,kBAAUjK,mBAAV,GAAgC,EAAhC;AACAhQ,0EAAkBA,CACd+Z,EADJ,EAEIE,SAFJ,EAGI/hB,yDAAcA,CAACI,OAHnB,EAII,IAJJ,EAKIkd,WALJ;;AAQA,YAAI9V,OAAOC,SAAX,EAAsB;AAClBsa,sBAAU9Z,SAAV,CAAoB4Z,EAApB;AACH,SAFD,MAEO;AACHE,sBAAU9Z,SAAV,CAAoB,IAApB;AACH;;AAED,eAAO8Z,SAAP;AACH,KAnCkB;AAAA,CAAhB,C;;;;;;;;;;;;ACvNP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA,SAASG,eAAT,GAA2B;AAAE,WAAO,IAAP;AAAc;;AAE3C;;;;;;;;;;AAUO,SAAS7R,YAAT,CAAuB8R,GAAvB,EAA4BC,GAA5B,EAAiC1D,QAAjC,EAAgG;AAAA,QAArD2D,mBAAqD,uEAA/B,KAA+B;AAAA,QAAxBC,QAAwB,uEAAb9hB,gDAAKA,CAACC,KAAO;;AACnG,QAAM6B,SAAS,EAAf;AACA,QAAMD,OAAO,EAAb;AACA,QAAMkgB,qBAAqB7D,YAAYwD,eAAvC;AACA,QAAMM,gBAAgBL,IAAI1Z,aAAJ,EAAtB;AACA,QAAMga,gBAAgBL,IAAI3Z,aAAJ,EAAtB;AACA,QAAMia,oBAAoBF,cAAc1mB,IAAxC;AACA,QAAM6mB,oBAAoBF,cAAc3mB,IAAxC;AACA,QAAMA,OAAU0mB,cAAc1mB,IAAxB,SAAgC2mB,cAAc3mB,IAApD;AACA,QAAM8mB,mBAAmBC,0EAAeA,CAACL,aAAhB,EAA+BC,aAA/B,CAAzB;;AAEA,QAAIC,sBAAsBC,iBAA1B,EAA6C;AACzC,cAAM,IAAI5f,KAAJ,CAAU,4CAAV,CAAN;AACH;AACD;AACAyf,kBAAcve,MAAd,CAAqBtH,OAArB,CAA6B,UAACuH,KAAD,EAAW;AACpC,YAAM4e,YAAY1G,sDAAOA,CAAC,EAAR,EAAYlY,MAAM5B,MAAN,EAAZ,CAAlB;AACA,YAAIsgB,iBAAiBtc,OAAjB,CAAyBwc,UAAUhnB,IAAnC,MAA6C,CAAC,CAA9C,IAAmD,CAACumB,mBAAxD,EAA6E;AACzES,sBAAUhnB,IAAV,GAAoB0mB,cAAc1mB,IAAlC,SAA0CgnB,UAAUhnB,IAApD;AACH;AACDwG,eAAOzF,IAAP,CAAYimB,SAAZ;AACH,KAND;AAOAL,kBAAcxe,MAAd,CAAqBtH,OAArB,CAA6B,UAACuH,KAAD,EAAW;AACpC,YAAM4e,YAAY1G,sDAAOA,CAAC,EAAR,EAAYlY,MAAM5B,MAAN,EAAZ,CAAlB;AACA,YAAIsgB,iBAAiBtc,OAAjB,CAAyBwc,UAAUhnB,IAAnC,MAA6C,CAAC,CAAlD,EAAqD;AACjD,gBAAI,CAACumB,mBAAL,EAA0B;AACtBS,0BAAUhnB,IAAV,GAAoB2mB,cAAc3mB,IAAlC,SAA0CgnB,UAAUhnB,IAApD;AACAwG,uBAAOzF,IAAP,CAAYimB,SAAZ;AACH;AACJ,SALD,MAKO;AACHxgB,mBAAOzF,IAAP,CAAYimB,SAAZ;AACH;AACJ,KAVD;;AAYA;AACA5X,oFAAkBA,CAACiX,IAAIzc,WAAvB,EAAoC,UAAC3J,CAAD,EAAO;AACvC,YAAIgnB,WAAW,KAAf;AACA,YAAIC,oBAAJ;AACA9X,wFAAkBA,CAACkX,IAAI1c,WAAvB,EAAoC,UAACud,EAAD,EAAQ;AACxC,gBAAMC,QAAQ,EAAd;AACA,gBAAMC,UAAU,EAAhB;AACAA,oBAAQT,iBAAR,IAA6B,EAA7B;AACAS,oBAAQR,iBAAR,IAA6B,EAA7B;AACAH,0BAAcve,MAAd,CAAqBtH,OAArB,CAA6B,UAACuH,KAAD,EAAW;AACpCgf,sBAAMrmB,IAAN,CAAWqH,MAAMmF,YAAN,CAAmBhH,IAAnB,CAAwBtG,CAAxB,CAAX;AACAonB,wBAAQT,iBAAR,EAA2Bxe,MAAMpI,IAAN,EAA3B,IAA2C;AACvC8a,8BAAU1S,MAAMmF,YAAN,CAAmBhH,IAAnB,CAAwBtG,CAAxB,CAD6B;AAEvC4a,oCAAgBzS,MAAMyE,aAAN,GAAsB5M,CAAtB;AAFuB,iBAA3C;AAIH,aAND;AAOA0mB,0BAAcxe,MAAd,CAAqBtH,OAArB,CAA6B,UAACuH,KAAD,EAAW;AACpC,oBAAI,EAAE0e,iBAAiBtc,OAAjB,CAAyBpC,MAAM5B,MAAN,GAAexG,IAAxC,MAAkD,CAAC,CAAnD,IAAwDumB,mBAA1D,CAAJ,EAAoF;AAChFa,0BAAMrmB,IAAN,CAAWqH,MAAMmF,YAAN,CAAmBhH,IAAnB,CAAwB4gB,EAAxB,CAAX;AACH;AACDE,wBAAQR,iBAAR,EAA2Bze,MAAMpI,IAAN,EAA3B,IAA2C;AACvC8a,8BAAU1S,MAAMmF,YAAN,CAAmBhH,IAAnB,CAAwB4gB,EAAxB,CAD6B;AAEvCtM,oCAAgBzS,MAAMyE,aAAN,GAAsBsa,EAAtB;AAFuB,iBAA3C;AAIH,aARD;;AAUA,gBAAInY,cAAc,EAAlB;AACA,gBAAIsY,iBAAiB,SAAjBA,cAAiB;AAAA,uBAAMjB,IAAInX,YAAJ,EAAN;AAAA,aAArB;AACA,gBAAIqY,iBAAiB,SAAjBA,cAAiB;AAAA,uBAAMjB,IAAIpX,YAAJ,EAAN;AAAA,aAArB;;AAEA,gBAAMsY,YAAY5M,+DAAeA,CAACyM,QAAQT,iBAAR,CAAhB,CAAlB;AACA,gBAAMa,YAAY7M,+DAAeA,CAACyM,QAAQR,iBAAR,CAAhB,CAAlB;AACA,gBAAIJ,mBAAmBe,SAAnB,EAA8BC,SAA9B,EAAyCH,cAAzC,EAAyDC,cAAzD,EAAyEvY,WAAzE,CAAJ,EAA2F;AACvF,oBAAM0Y,WAAW,EAAjB;AACAN,sBAAMvmB,OAAN,CAAc,UAAC8mB,OAAD,EAAUC,GAAV,EAAkB;AAC5BF,6BAASlhB,OAAOohB,GAAP,EAAY5nB,IAArB,IAA6B2nB,OAA7B;AACH,iBAFD;AAGA,oBAAIV,YAAYviB,gDAAKA,CAACC,KAAN,KAAgB6hB,QAAhC,EAA0C;AACtCjgB,yBAAK2gB,WAAL,IAAoBQ,QAApB;AACH,iBAFD,MAGK;AACDnhB,yBAAKxF,IAAL,CAAU2mB,QAAV;AACAT,+BAAW,IAAX;AACAC,kCAAcjnB,CAAd;AACH;AACJ,aAbD,MAaO,IAAI,CAACumB,aAAa9hB,gDAAKA,CAACE,SAAnB,IAAgC4hB,aAAa9hB,gDAAKA,CAACG,UAApD,KAAmE,CAACoiB,QAAxE,EAAkF;AACrF,oBAAMS,YAAW,EAAjB;AACA,oBAAI7J,MAAM6I,cAAcve,MAAd,CAAqBhH,MAArB,GAA8B,CAAxC;AACAimB,sBAAMvmB,OAAN,CAAc,UAAC8mB,OAAD,EAAUC,GAAV,EAAkB;AAC5B,wBAAIA,OAAO/J,GAAX,EAAgB;AACZ6J,kCAASlhB,OAAOohB,GAAP,EAAY5nB,IAArB,IAA6B2nB,OAA7B;AACH,qBAFD,MAGK;AACDD,kCAASlhB,OAAOohB,GAAP,EAAY5nB,IAArB,IAA6B,IAA7B;AACH;AACJ,iBAPD;AAQAinB,2BAAW,IAAX;AACAC,8BAAcjnB,CAAd;AACAsG,qBAAKxF,IAAL,CAAU2mB,SAAV;AACH;AACJ,SAxDD;AAyDH,KA5DD;;AA8DA,WAAO,IAAI3e,kDAAJ,CAAcxC,IAAd,EAAoBC,MAApB,EAA4B,EAAExG,UAAF,EAA5B,CAAP;AACH,C;;;;;;;;;;;;;;;;;;ACzHD;AACA;;AAEA;;;;;;;;;;;AAWO,SAAS0J,WAAT,CAAsBgM,UAAtB,EAAkC3K,UAAlC,EAA8CkQ,aAA9C,EAA6D7O,cAA7D,EAA6E3F,OAA7E,EAAsF;AACzF,QAAMyC,aAAa;AACfc,gBAAQ,KADO;AAEfD,oBAAY;AAFG,KAAnB;AAIAtD,cAAU9F,OAAOgH,MAAP,CAAc,EAAd,EAAkBuB,UAAlB,EAA8BzC,OAA9B,CAAV;;AAEA,QAAMohB,SAAS;AACXrhB,gBAAQ,EADG;AAEXD,cAAM,EAFK;AAGX0D,cAAM;AAHK,KAAf;AAKA,QAAMD,SAASvD,QAAQuD,MAAvB;AACA,QAAM8d,aAAa1b,kBAAkBA,eAAejL,MAAf,GAAwB,CAA7D;AACA;AACA,QAAM4mB,aAAa,EAAnB;AACA;AACA,QAAMC,UAAU/M,cAAc/P,KAAd,CAAoB,GAApB,CAAhB;;AAEA8c,YAAQnnB,OAAR,CAAgB,UAAConB,OAAD,EAAa;AACzB,aAAK,IAAIhoB,IAAI,CAAb,EAAgBA,IAAIyV,WAAWvU,MAA/B,EAAuClB,KAAK,CAA5C,EAA+C;AAC3C,gBAAIyV,WAAWzV,CAAX,EAAcD,IAAd,OAAyBioB,OAA7B,EAAsC;AAClCF,2BAAWhnB,IAAX,CAAgB2U,WAAWzV,CAAX,CAAhB;AACA;AACH;AACJ;AACJ,KAPD;;AASA;AACA8nB,eAAWlnB,OAAX,CAAmB,UAACuH,KAAD,EAAW;AAC1B;AACAyf,eAAOrhB,MAAP,CAAczF,IAAd,CAAmBqH,MAAM5B,MAAN,EAAnB;AACH,KAHD;;AAKA,QAAIwD,MAAJ,EAAY;AACR6d,eAAOrhB,MAAP,CAAczF,IAAd,CAAmB;AACff,kBAAM,KADS;AAEf8F,kBAAM;AAFS,SAAnB;AAIH;;AAEDsJ,oFAAkBA,CAACrE,UAAnB,EAA+B,UAAC9K,CAAD,EAAO;AAClC4nB,eAAOthB,IAAP,CAAYxF,IAAZ,CAAiB,EAAjB;AACA,YAAMmnB,YAAYL,OAAOthB,IAAP,CAAYpF,MAAZ,GAAqB,CAAvC;AACA,YAAIiK,QAAQ,CAAZ;AACA2c,mBAAWlnB,OAAX,CAAmB,UAACuH,KAAD,EAAQ+e,EAAR,EAAe;AAC9BU,mBAAOthB,IAAP,CAAY2hB,SAAZ,EAAuBf,KAAK/b,KAA5B,IAAqChD,MAAMmF,YAAN,CAAmBhH,IAAnB,CAAwBtG,CAAxB,CAArC;AACH,SAFD;AAGA,YAAI+J,MAAJ,EAAY;AACR6d,mBAAOthB,IAAP,CAAY2hB,SAAZ,EAAuBH,WAAW5mB,MAAlC,IAA4ClB,CAA5C;AACH;AACD;AACA4nB,eAAO5d,IAAP,CAAYlJ,IAAZ,CAAiBd,CAAjB;;AAEA;AACA;AACA,YAAI6nB,UAAJ,EAAgB;AAAED,mBAAOthB,IAAP,CAAY2hB,SAAZ,EAAuBnnB,IAAvB,CAA4Bd,CAA5B;AAAiC;AACtD,KAhBD;;AAkBA;AACA,QAAI6nB,UAAJ,EAAgB;AACZK,8DAAQA,CAACN,MAAT,EAAiBzb,cAAjB;AACH;;AAED,QAAI3F,QAAQsD,UAAZ,EAAwB;AACpB,YAAMqe,UAAUhnB,0CAASA,MAAMymB,OAAOrhB,MAAP,CAAcrF,MAApB,CAAT,GAAsCpB,GAAtC,CAA0C;AAAA,mBAAM,EAAN;AAAA,SAA1C,CAAhB;AACA8nB,eAAOthB,IAAP,CAAY1F,OAAZ,CAAoB,UAACumB,KAAD,EAAW;AAC3BA,kBAAMvmB,OAAN,CAAc,UAAC0F,IAAD,EAAOtG,CAAP,EAAa;AACvBmoB,wBAAQnoB,CAAR,EAAWc,IAAX,CAAgBwF,IAAhB;AACH,aAFD;AAGH,SAJD;AAKAshB,eAAOthB,IAAP,GAAc6hB,OAAd;AACH;;AAED,WAAOP,MAAP;AACH,C;;;;;;;;;;;;ACzFD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;AAEA;;;;;;;;;AASO,SAASrT,UAAT,CAAqB6R,GAArB,EAA0BC,GAA1B,EAA+B;AAClC,QAAM+B,YAAY,EAAlB;AACA,QAAM7hB,SAAS,EAAf;AACA,QAAM8hB,gBAAgB,EAAtB;AACA,QAAM/hB,OAAO,EAAb;AACA,QAAMmgB,gBAAgBL,IAAI1Z,aAAJ,EAAtB;AACA,QAAMga,gBAAgBL,IAAI3Z,aAAJ,EAAtB;AACA,QAAM4b,wBAAwB7B,cAAclZ,SAAd,EAA9B;AACA,QAAMgb,wBAAwB7B,cAAcnZ,SAAd,EAA9B;AACA,QAAMxN,OAAU0mB,cAAc1mB,IAAxB,eAAsC2mB,cAAc3mB,IAA1D;;AAED;AACC,QAAI,CAACyoB,gEAAUA,CAACpC,IAAIvc,cAAJ,CAAmBoB,KAAnB,CAAyB,GAAzB,EAA8B3B,IAA9B,EAAX,EAAiD+c,IAAIxc,cAAJ,CAAmBoB,KAAnB,CAAyB,GAAzB,EAA8B3B,IAA9B,EAAjD,CAAL,EAA6F;AACzF,eAAO,IAAP;AACH;;AAED;AACC8c,QAAIvc,cAAJ,CAAmBoB,KAAnB,CAAyB,GAAzB,CAAD,CAAgCrK,OAAhC,CAAwC,UAACqM,SAAD,EAAe;AACnD,YAAM9E,QAAQmgB,sBAAsBrb,SAAtB,CAAd;AACA1G,eAAOzF,IAAP,CAAYuf,sDAAOA,CAAC,EAAR,EAAYlY,MAAM5B,MAAN,EAAZ,CAAZ;AACA8hB,sBAAcvnB,IAAd,CAAmBqH,MAAM5B,MAAN,GAAexG,IAAlC;AACH,KAJD;;AAMA;;;;;;;AAOA,aAAS0oB,iBAAT,CAA2B3C,EAA3B,EAA+BvY,SAA/B,EAA0Cmb,OAA1C,EAAmD;AAC/CvZ,wFAAkBA,CAAC2W,GAAGnc,WAAtB,EAAmC,UAAC3J,CAAD,EAAO;AACtC,gBAAMmnB,QAAQ,EAAd;AACA,gBAAIwB,WAAW,EAAf;AACAN,0BAAcznB,OAAd,CAAsB,UAACgoB,UAAD,EAAgB;AAClC,oBAAMzqB,QAAQoP,UAAUqb,UAAV,EAAsBtb,YAAtB,CAAmChH,IAAnC,CAAwCtG,CAAxC,CAAd;AACA2oB,kCAAgBxqB,KAAhB;AACAgpB,sBAAMyB,UAAN,IAAoBzqB,KAApB;AACH,aAJD;AAKA,gBAAI,CAACiqB,UAAUO,QAAV,CAAL,EAA0B;AACtB,oBAAID,OAAJ,EAAa;AAAEpiB,yBAAKxF,IAAL,CAAUqmB,KAAV;AAAmB;AAClCiB,0BAAUO,QAAV,IAAsB,IAAtB;AACH;AACJ,SAZD;AAaH;;AAED;AACAF,sBAAkBpC,GAAlB,EAAuBkC,qBAAvB,EAA8C,KAA9C;AACAE,sBAAkBrC,GAAlB,EAAuBkC,qBAAvB,EAA8C,IAA9C;;AAEA,WAAO,IAAIxf,kDAAJ,CAAcxC,IAAd,EAAoBC,MAApB,EAA4B,EAAExG,UAAF,EAA5B,CAAP;AACH,C;;;;;;;;;;;;ACjED;AAAA;AAAA;;;;;;;;AAQO,SAAS+mB,eAAT,CAA0B+B,GAA1B,EAA+BC,GAA/B,EAAoC;AACvC,QAAMC,SAAS,EAAf;AACA,QAAMC,SAAS,EAAf;AACAH,QAAI3gB,MAAJ,CAAWtH,OAAX,CAAmB,UAACuH,KAAD,EAAW;AAC1B6gB,eAAOloB,IAAP,CAAYqH,MAAM5B,MAAN,GAAexG,IAA3B;AACH,KAFD;AAGA+oB,QAAI5gB,MAAJ,CAAWtH,OAAX,CAAmB,UAACuH,KAAD,EAAW;AAC1B,YAAI6gB,OAAOze,OAAP,CAAepC,MAAM5B,MAAN,GAAexG,IAA9B,MAAwC,CAAC,CAA7C,EAAgD;AAC5CgpB,mBAAOjoB,IAAP,CAAYqH,MAAM5B,MAAN,GAAexG,IAA3B;AACH;AACJ,KAJD;AAKA,WAAOgpB,MAAP;AACH,C;;;;;;;;;;;;;;;;;;;;;;;;;ACpBD;AACA;AACA;;IAEQzV,G,GAAgDD,yD,CAAhDC,G;IAAKC,G,GAA2CF,yD,CAA3CE,G;IAAKG,K,GAAsCL,yD,CAAtCK,K;IAAOC,I,GAA+BN,yD,CAA/BM,I;IAAMC,K,GAAyBP,yD,CAAzBO,K;IAAOC,G,GAAkBR,yD,CAAlBQ,G;IAAKL,G,GAAaH,yD,CAAbG,G;IAAKC,G,GAAQJ,yD,CAARI,G;;;AAEhD,SAASwV,iBAAT,CAA2B7hB,GAA3B,EAAgC;AAC5B,WAAOA,IAAIwS,MAAJ,CAAW;AAAA,eAAQ,EAAEhR,gBAAgBgK,4DAAlB,CAAR;AAAA,KAAX,CAAP;AACH;AACD;;;;;;;AAOA,SAASsW,GAAT,CAAc9hB,GAAd,EAAmB;AACf,QAAIC,sDAAOA,CAACD,GAAR,KAAgB,EAAEA,IAAI,CAAJ,aAAkBjG,KAApB,CAApB,EAAgD;AAC5C,YAAMgoB,iBAAiBF,kBAAkB7hB,GAAlB,CAAvB;AACA,YAAMgiB,WAAWD,eAAejoB,MAAf,GACGioB,eAAephB,MAAf,CAAsB,UAACC,GAAD,EAAMqhB,IAAN;AAAA,mBAAerhB,MAAMqhB,IAArB;AAAA,SAAtB,EAAiD,CAAjD,CADH,GAEKzW,4DAAiBA,CAAC8R,IAFxC;AAGA,eAAO0E,QAAP;AACH;AACD,WAAOxW,4DAAiBA,CAAC8R,IAAzB;AACH;;AAED;;;;;;;AAOA,SAAS4E,GAAT,CAAcliB,GAAd,EAAmB;AACf,QAAIC,sDAAOA,CAACD,GAAR,KAAgB,EAAEA,IAAI,CAAJ,aAAkBjG,KAApB,CAApB,EAAgD;AAC5C,YAAMioB,WAAWF,IAAI9hB,GAAJ,CAAjB;AACA,YAAMwW,MAAMxW,IAAIlG,MAAJ,IAAc,CAA1B;AACA,eAAQgK,OAAO3M,KAAP,CAAa6qB,QAAb,KAA0BA,oBAAoBxW,4DAA/C,GACEA,4DAAiBA,CAAC8R,IADpB,GAC2B0E,WAAWxL,GAD7C;AAEH;AACD,WAAOhL,4DAAiBA,CAAC8R,IAAzB;AACH;;AAED;;;;;;;AAOA,SAAS7N,GAAT,CAAczP,GAAd,EAAmB;AACf,QAAIC,sDAAOA,CAACD,GAAR,KAAgB,EAAEA,IAAI,CAAJ,aAAkBjG,KAApB,CAApB,EAAgD;AAC5C;AACA,YAAMooB,iBAAiBN,kBAAkB7hB,GAAlB,CAAvB;;AAEA,eAAQmiB,eAAeroB,MAAhB,GAA0BkZ,KAAKvD,GAAL,gCAAY0S,cAAZ,EAA1B,GAAwD3W,4DAAiBA,CAAC8R,IAAjF;AACH;AACD,WAAO9R,4DAAiBA,CAAC8R,IAAzB;AACH;;AAED;;;;;;;AAOA,SAAS3N,GAAT,CAAc3P,GAAd,EAAmB;AACf,QAAIC,sDAAOA,CAACD,GAAR,KAAgB,EAAEA,IAAI,CAAJ,aAAkBjG,KAApB,CAApB,EAAgD;AAC5C;AACA,YAAMooB,iBAAiBN,kBAAkB7hB,GAAlB,CAAvB;;AAEA,eAAQmiB,eAAeroB,MAAhB,GAA0BkZ,KAAKrD,GAAL,gCAAYwS,cAAZ,EAA1B,GAAwD3W,4DAAiBA,CAAC8R,IAAjF;AACH;AACD,WAAO9R,4DAAiBA,CAAC8R,IAAzB;AACH;;AAED;;;;;;;AAOA,SAAS8E,KAAT,CAAgBpiB,GAAhB,EAAqB;AACjB,WAAOA,IAAI,CAAJ,CAAP;AACH;;AAED;;;;;;;AAOA,SAASqiB,IAAT,CAAeriB,GAAf,EAAoB;AAChB,WAAOA,IAAIA,IAAIlG,MAAJ,GAAa,CAAjB,CAAP;AACH;;AAED;;;;;;;AAOA,SAASwoB,KAAT,CAAgBtiB,GAAhB,EAAqB;AACjB,QAAIC,sDAAOA,CAACD,GAAR,CAAJ,EAAkB;AACd,eAAOA,IAAIlG,MAAX;AACH;AACD,WAAO0R,4DAAiBA,CAAC8R,IAAzB;AACH;;AAED;;;;;;AAMA,SAASiF,QAAT,CAAmBviB,GAAnB,EAAwB;AACpB,QAAIwiB,OAAON,IAAIliB,GAAJ,CAAX;AACA,WAAOkiB,IAAIliB,IAAItH,GAAJ,CAAQ;AAAA,wBAAQ+pB,MAAMD,IAAd,EAAuB,CAAvB;AAAA,KAAR,CAAJ,CAAP;AACH;;AAED;;;;;;;AAOA,SAASE,GAAT,CAAc1iB,GAAd,EAAmB;AACf,WAAOgT,KAAK2P,IAAL,CAAUJ,SAASviB,GAAT,CAAV,CAAP;AACH;;AAGD,IAAM4iB,iDACD1W,GADC,EACK4V,GADL,4BAED3V,GAFC,EAEK+V,GAFL,4BAGD9V,GAHC,EAGKqD,GAHL,4BAIDpD,GAJC,EAIKsD,GAJL,4BAKDrD,KALC,EAKO8V,KALP,4BAMD7V,IANC,EAMM8V,IANN,4BAOD7V,KAPC,EAOO8V,KAPP,4BAQD7V,GARC,EAQKiW,GARL,WAAN;;AAWA,IAAMzR,qBAAqB/E,GAA3B;;;;;;;;;;;;;;;;;;;;;;;;;;ACpJA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AAOA,SAAS2W,WAAT,CAAsB3I,SAAtB,EAAiC3L,QAAjC,EAA2C;AACvC,QAAMoT,SAAS,EAAf;AACA,QAAMtT,aAAa6L,UAAU5U,aAAV,EAAnB;AACA,QAAMwd,aAAazU,WAAWO,YAAX,EAAnB;;AAEAtV,WAAOga,OAAP,CAAewP,UAAf,EAA2BtpB,OAA3B,CAAmC,gBAAW;AAAA;AAAA,YAAT1C,GAAS;;AAC1C,YAAIyX,YAAYA,SAASzU,MAAzB,EAAiC;AAC7B,gBAAIyU,SAASpL,OAAT,CAAiBrM,GAAjB,MAA0B,CAAC,CAA/B,EAAkC;AAC9B6qB,uBAAOjoB,IAAP,CAAY5C,GAAZ;AACH;AACJ,SAJD,MAIO;AACH6qB,mBAAOjoB,IAAP,CAAY5C,GAAZ;AACH;AACJ,KARD;;AAUA,WAAO6qB,MAAP;AACH;;AAED;;;;;;;AAOA,SAASoB,aAAT,CAAwB7I,SAAxB,EAAkD;AAAA,QAAf9V,QAAe,uEAAJ,EAAI;;AAC9C,QAAMoc,SAAS,EAAf;AACA,QAAMnS,aAAa6L,UAAU5U,aAAV,EAAnB;AACA,QAAM0d,WAAW3U,WAAWK,UAAX,EAAjB;AACA,QAAMuU,aAAape,4DAAYA,CAACD,cAAb,EAAnB;;AAEAtL,WAAOmI,IAAP,CAAYuhB,QAAZ,EAAsBxpB,OAAtB,CAA8B,UAAC0pB,WAAD,EAAiB;AAC3C,YAAI,OAAO9e,SAAS8e,WAAT,CAAP,KAAiC,QAArC,EAA+C;AAC3C9e,qBAAS8e,WAAT,IAAwBF,SAASE,WAAT,EAAsBlS,QAAtB,EAAxB;AACH;AACD,YAAMtG,YAAY7F,4DAAYA,CAACse,OAAb,CAAqB/e,SAAS8e,WAAT,CAArB,CAAlB;AACA,YAAIxY,SAAJ,EAAe;AACX8V,mBAAO0C,WAAP,IAAsBxY,SAAtB;AACH,SAFD,MAEO;AACH8V,mBAAO0C,WAAP,IAAsBD,UAAtB;AACA7e,qBAAS8e,WAAT,IAAwBjS,qEAAxB;AACH;AACJ,KAXD;AAYA,WAAOuP,MAAP;AACH;;AAED;;;;;;;;;AASA,SAAS9b,OAAT,CAAkBwV,SAAlB,EAA6B3L,QAA7B,EAAuCnK,QAAvC,EAAiDgf,iBAAjD,EAAoE;AAChE,QAAMC,YAAYR,YAAY3I,SAAZ,EAAuB3L,QAAvB,CAAlB;AACA,QAAM+U,aAAaP,cAAc7I,SAAd,EAAyB9V,QAAzB,CAAnB;AACA,QAAMiK,aAAa6L,UAAU5U,aAAV,EAAnB;AACA,QAAMuQ,gBAAgBxH,WAAWlI,SAAX,EAAtB;AACA,QAAMod,SAASlV,WAAW1V,IAA1B;AACA,QAAM8R,eAAe,EAArB;AACA,QAAM+Y,aAAa,EAAnB;AACA,QAAMrkB,SAAS,EAAf;AACA,QAAMskB,UAAU,EAAhB;AACA,QAAMvkB,OAAO,EAAb;AACA,QAAIuF,qBAAJ;;AAEA;AACAnL,WAAOga,OAAP,CAAeuC,aAAf,EAA8Brc,OAA9B,CAAsC,iBAAkB;AAAA;AAAA,YAAhB1C,GAAgB;AAAA,YAAXC,KAAW;;AACpD,YAAIssB,UAAUlgB,OAAV,CAAkBrM,GAAlB,MAA2B,CAAC,CAA5B,IAAiCwsB,WAAWxsB,GAAX,CAArC,EAAsD;AAClDqI,mBAAOzF,IAAP,CAAYuf,sDAAOA,CAAC,EAAR,EAAYliB,MAAMoI,MAAN,EAAZ,CAAZ;;AAEA,oBAAQpI,MAAMoI,MAAN,GAAeV,IAAvB;AACA,qBAAKyL,gDAASA,CAAC4B,OAAf;AACI0X,+BAAW9pB,IAAX,CAAgB5C,GAAhB;AACA;AACJ;AACA,qBAAKoT,gDAASA,CAACC,SAAf;AACIM,iCAAa/Q,IAAb,CAAkB5C,GAAlB;AANJ;AAQH;AACJ,KAbD;AAcA;AACA,QAAI4sB,WAAW,CAAf;AACA3b,oFAAkBA,CAACmS,UAAU3X,WAA7B,EAA0C,UAAC3J,CAAD,EAAO;AAC7C,YAAIuW,OAAO,EAAX;AACA1E,qBAAajR,OAAb,CAAqB,UAAC0K,CAAD,EAAO;AACxBiL,mBAAUA,IAAV,SAAkB0G,cAAc3R,CAAd,EAAiBgC,YAAjB,CAA8BhH,IAA9B,CAAmCtG,CAAnC,CAAlB;AACH,SAFD;AAGA,YAAI6qB,QAAQtU,IAAR,MAAkB1L,SAAtB,EAAiC;AAC7BggB,oBAAQtU,IAAR,IAAgBuU,QAAhB;AACAxkB,iBAAKxF,IAAL,CAAU,EAAV;AACA+Q,yBAAajR,OAAb,CAAqB,UAAC0K,CAAD,EAAO;AACxBhF,qBAAKwkB,QAAL,EAAexf,CAAf,IAAoB2R,cAAc3R,CAAd,EAAiBgC,YAAjB,CAA8BhH,IAA9B,CAAmCtG,CAAnC,CAApB;AACH,aAFD;AAGA4qB,uBAAWhqB,OAAX,CAAmB,UAAC0K,CAAD,EAAO;AACtBhF,qBAAKwkB,QAAL,EAAexf,CAAf,IAAoB,CAAC2R,cAAc3R,CAAd,EAAiBgC,YAAjB,CAA8BhH,IAA9B,CAAmCtG,CAAnC,CAAD,CAApB;AACH,aAFD;AAGA8qB,wBAAY,CAAZ;AACH,SAVD,MAUO;AACHF,uBAAWhqB,OAAX,CAAmB,UAAC0K,CAAD,EAAO;AACtBhF,qBAAKukB,QAAQtU,IAAR,CAAL,EAAoBjL,CAApB,EAAuBxK,IAAvB,CAA4Bmc,cAAc3R,CAAd,EAAiBgC,YAAjB,CAA8BhH,IAA9B,CAAmCtG,CAAnC,CAA5B;AACH,aAFD;AAGH;AACJ,KApBD;;AAsBA;AACA,QAAI+O,cAAc,EAAlB;AACA,QAAIC,gBAAgB,SAAhBA,aAAgB;AAAA,eAAMsS,UAAUrS,YAAV,EAAN;AAAA,KAApB;AACA3I,SAAK1F,OAAL,CAAa,UAACN,GAAD,EAAS;AAClB,YAAM6mB,QAAQ7mB,GAAd;AACAsqB,mBAAWhqB,OAAX,CAAmB,UAAC0K,CAAD,EAAO;AACtB6b,kBAAM7b,CAAN,IAAWof,WAAWpf,CAAX,EAAchL,IAAIgL,CAAJ,CAAd,EAAsB0D,aAAtB,EAAqCD,WAArC,CAAX;AACH,SAFD;AAGH,KALD;AAMA,QAAIyb,iBAAJ,EAAuB;AACnBA,0BAAkBxc,qBAAlB;AACAnC,uBAAe2e,iBAAf;AACH,KAHD,MAIK;AACD3e,uBAAe,IAAI/C,+CAAJ,CAAcxC,IAAd,EAAoBC,MAApB,EAA4B,EAAExG,MAAM4qB,MAAR,EAA5B,CAAf;AACH;AACD,WAAO9e,YAAP;AACH;;;;;;;;;;;;;;AC1ID;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACbA;AAAA;AAAA;;;;;;;AAOA,SAASkf,SAAT,CAAoBlR,CAApB,EAAuBC,CAAvB,EAA0B;AACtB,QAAMkR,UAAQnR,CAAd;AACA,QAAMoR,UAAQnR,CAAd;AACA,QAAIkR,KAAKC,EAAT,EAAa;AACT,eAAO,CAAC,CAAR;AACH;AACD,QAAID,KAAKC,EAAT,EAAa;AACT,eAAO,CAAP;AACH;AACD,WAAO,CAAP;AACH;;AAED;;;;;;;;;;AAUA,SAASC,KAAT,CAAgB9jB,GAAhB,EAAqB+jB,EAArB,EAAyBC,GAAzB,EAA8BC,EAA9B,EAAkCC,MAAlC,EAA0C;AACtC,QAAMC,UAAUnkB,GAAhB;AACA,QAAMokB,SAAS,EAAf;AACA,SAAK,IAAIxrB,IAAImrB,EAAb,EAAiBnrB,KAAKqrB,EAAtB,EAA0BrrB,KAAK,CAA/B,EAAkC;AAC9BwrB,eAAOxrB,CAAP,IAAYurB,QAAQvrB,CAAR,CAAZ;AACH;AACD,QAAI6Z,IAAIsR,EAAR;AACA,QAAIrR,IAAIsR,MAAM,CAAd;;AAEA,SAAK,IAAIprB,KAAImrB,EAAb,EAAiBnrB,MAAKqrB,EAAtB,EAA0BrrB,MAAK,CAA/B,EAAkC;AAC9B,YAAI6Z,IAAIuR,GAAR,EAAa;AACTG,oBAAQvrB,EAAR,IAAawrB,OAAO1R,CAAP,CAAb;AACAA,iBAAK,CAAL;AACH,SAHD,MAGO,IAAIA,IAAIuR,EAAR,EAAY;AACfE,oBAAQvrB,EAAR,IAAawrB,OAAO3R,CAAP,CAAb;AACAA,iBAAK,CAAL;AACH,SAHM,MAGA,IAAIyR,OAAOE,OAAO3R,CAAP,CAAP,EAAkB2R,OAAO1R,CAAP,CAAlB,KAAgC,CAApC,EAAuC;AAC1CyR,oBAAQvrB,EAAR,IAAawrB,OAAO3R,CAAP,CAAb;AACAA,iBAAK,CAAL;AACH,SAHM,MAGA;AACH0R,oBAAQvrB,EAAR,IAAawrB,OAAO1R,CAAP,CAAb;AACAA,iBAAK,CAAL;AACH;AACJ;AACJ;;AAED;;;;;;;;;;AAUA,SAASxQ,IAAT,CAAelC,GAAf,EAAoB+jB,EAApB,EAAwBE,EAAxB,EAA4BC,MAA5B,EAAoC;AAChC,QAAID,OAAOF,EAAX,EAAe;AAAE,eAAO/jB,GAAP;AAAa;;AAE9B,QAAMgkB,MAAMD,KAAK/Q,KAAKmL,KAAL,CAAW,CAAC8F,KAAKF,EAAN,IAAY,CAAvB,CAAjB;AACA7hB,SAAKlC,GAAL,EAAU+jB,EAAV,EAAcC,GAAd,EAAmBE,MAAnB;AACAhiB,SAAKlC,GAAL,EAAUgkB,MAAM,CAAhB,EAAmBC,EAAnB,EAAuBC,MAAvB;AACAJ,UAAM9jB,GAAN,EAAW+jB,EAAX,EAAeC,GAAf,EAAoBC,EAApB,EAAwBC,MAAxB;;AAEA,WAAOlkB,GAAP;AACH;;AAED;;;;;;;;;AASO,SAASqkB,SAAT,CAAoBrkB,GAApB,EAA6C;AAAA,QAApBkkB,MAAoB,uEAAXP,SAAW;;AAChD,QAAI3jB,IAAIlG,MAAJ,GAAa,CAAjB,EAAoB;AAChBoI,aAAKlC,GAAL,EAAU,CAAV,EAAaA,IAAIlG,MAAJ,GAAa,CAA1B,EAA6BoqB,MAA7B;AACH;AACD,WAAOlkB,GAAP;AACH,C;;;;;;;;;;;;AC1FD;AAAA;AAAA;AAAA;;AAEA;;;;;;;;;AASO,SAASskB,iBAAT,CAA4BtF,GAA5B,EAAiCC,GAAjC,EAAsC;AACzC,QAAMI,gBAAgBL,IAAI1Z,aAAJ,EAAtB;AACA,QAAMga,gBAAgBL,IAAI3Z,aAAJ,EAAtB;AACA;AACA;AACA,QAAMif,kBAAkB7E,0EAAeA,CAACL,aAAhB,EAA+BC,aAA/B,CAAxB;;AAEA,WAAO,UAACa,SAAD,EAAYC,SAAZ,EAA0B;AAC7B,YAAIoE,cAAc,IAAlB;AACAD,wBAAgB/qB,OAAhB,CAAwB,UAACqM,SAAD,EAAe;AACnC,gBAAIsa,UAAUta,SAAV,EAAqB8Q,aAArB,KACAyJ,UAAUva,SAAV,EAAqB8Q,aADrB,IACsC6N,WAD1C,EACuD;AACnDA,8BAAc,IAAd;AACH,aAHD,MAGO;AACHA,8BAAc,KAAd;AACH;AACJ,SAPD;AAQA,eAAOA,WAAP;AACH,KAXD;AAYH,C;;;;;;;;;;;;AC9BD;AAAA;AAAA;AAAA;AAAA;AACA;;AAEO,SAASpX,WAAT,CAAsBqX,UAAtB,EAAkCC,UAAlC,EAA8C;AACjD,WAAOxX,mEAAYA,CAACuX,UAAb,EAAyBC,UAAzB,EAAqCJ,uFAAiBA,CAACG,UAAlB,EAA8BC,UAA9B,CAArC,EAAgF,IAAhF,CAAP;AACH,C;;;;;;;;;;;;ACLD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;AAGO,SAASrX,aAAT,CAAwBoX,UAAxB,EAAoCC,UAApC,EAAgDnJ,QAAhD,EAA0D;AAC7D,WAAOrO,mEAAYA,CAACuX,UAAb,EAAyBC,UAAzB,EAAqCnJ,QAArC,EAA+C,KAA/C,EAAsDle,gDAAKA,CAACE,SAA5D,CAAP;AACH;;AAEM,SAAS+P,cAAT,CAAyBmX,UAAzB,EAAqCC,UAArC,EAAiDnJ,QAAjD,EAA2D;AAC9D,WAAOrO,mEAAYA,CAACwX,UAAb,EAAyBD,UAAzB,EAAqClJ,QAArC,EAA+C,KAA/C,EAAsDle,gDAAKA,CAACG,UAA5D,CAAP;AACH;;AAEM,SAAS+P,aAAT,CAAwBkX,UAAxB,EAAoCC,UAApC,EAAgDnJ,QAAhD,EAA0D;AAC7D,WAAO/N,oDAAKA,CAACH,cAAcoX,UAAd,EAA0BC,UAA1B,EAAsCnJ,QAAtC,CAAN,EAAuDjO,eAAemX,UAAf,EAA2BC,UAA3B,EAAuCnJ,QAAvC,CAAvD,CAAP;AACH,C;;;;;;;;;;;;ACfD;AAAA;AAAA;AAAA;;;;;;;AAOO,IAAMtO,oBAAoB,SAApBA,iBAAoB;AAAA,oCAAItL,IAAJ;AAAIA,QAAJ;AAAA;;AAAA,SAAa;AAAA,WAAM+c,GAAGzR,iBAAH,WAAwBtL,IAAxB,CAAN;AAAA,GAAb;AAAA,CAA1B;;AAEP;;;;;;;AAOO,IAAMO,OAAO,SAAPA,IAAO;AAAA,qCAAIP,IAAJ;AAAIA,QAAJ;AAAA;;AAAA,SAAa;AAAA,WAAM+c,GAAGxc,IAAH,WAAWP,IAAX,CAAN;AAAA,GAAb;AAAA,CAAb,C;;;;;;;;;;;;AChBP;AAAA;AAAA;;;;;;;AAOO,SAASoG,kBAAT,CAA6BrE,UAA7B,EAAyC6F,QAAzC,EAAmD;AACtD,QAAI7F,WAAW5J,MAAX,GAAoB,CAAxB,EAA2B;AACvB,YAAM6qB,aAAajhB,WAAWG,KAAX,CAAiB,GAAjB,CAAnB;AACA8gB,mBAAWnrB,OAAX,CAAmB,UAACorB,OAAD,EAAa;AAC5B,gBAAMC,aAAaD,QAAQ/gB,KAAR,CAAc,GAAd,CAAnB;AACA,gBAAME,QAAQ,CAAE8gB,WAAW,CAAX,CAAhB;AACA,gBAAM7gB,MAAM,EAAE6gB,WAAW,CAAX,KAAiBA,WAAW,CAAX,CAAnB,CAAZ;AACA,gBAAI7gB,OAAOD,KAAX,EAAkB;AACd,qBAAK,IAAInL,IAAImL,KAAb,EAAoBnL,KAAKoL,GAAzB,EAA8BpL,KAAK,CAAnC,EAAsC;AAClC2Q,6BAAS3Q,CAAT;AACH;AACJ;AACJ,SATD;AAUH;AACJ,C;;;;;;;;;;;;;;;;;;;;;;ACrBD;AACA;AACA;AACA;;AAEA;;;;;;;;AAQA,SAASksB,SAAT,CAAoBC,QAApB,EAA8BC,QAA9B,EAAwC;AACpC,QAAIC,gBAAJ;;AAEA,YAAQF,QAAR;AACA,aAAKrY,qDAAcA,CAACC,UAApB;AACA,aAAKtC,uDAAgBA,CAACwB,QAAtB;AACI,gBAAImZ,aAAa,KAAjB,EAAwB;AACpBC,0BAAU,iBAACxS,CAAD,EAAIC,CAAJ;AAAA,2BAAUD,IAAIC,CAAd;AAAA,iBAAV;AACH,aAFD,MAEO;AACHuS,0BAAU,iBAACxS,CAAD,EAAIC,CAAJ;AAAA,2BAAUA,IAAID,CAAd;AAAA,iBAAV;AACH;AACD;AACJ;AACI,gBAAIuS,aAAa,KAAjB,EAAwB;AACpBC,0BAAU,iBAACxS,CAAD,EAAIC,CAAJ,EAAU;AAChBD,6BAAOA,CAAP;AACAC,6BAAOA,CAAP;AACA,wBAAID,MAAMC,CAAV,EAAa;AACT,+BAAO,CAAP;AACH;AACD,2BAAOD,IAAIC,CAAJ,GAAQ,CAAR,GAAY,CAAC,CAApB;AACH,iBAPD;AAQH,aATD,MASO;AACHuS,0BAAU,iBAACxS,CAAD,EAAIC,CAAJ,EAAU;AAChBD,6BAAOA,CAAP;AACAC,6BAAOA,CAAP;AACA,wBAAID,MAAMC,CAAV,EAAa;AACT,+BAAO,CAAP;AACH;AACD,2BAAOD,IAAIC,CAAJ,GAAQ,CAAC,CAAT,GAAa,CAApB;AACH,iBAPD;AAQH;AA5BL;;AA+BA,WAAOuS,OAAP;AACH;;AAED;;;;;;;AAOA,SAASC,mBAAT,CAA8BC,QAA9B,EAAwCC,YAAxC,EAAsD;AAClD,QAAMC,YAAY/T,OAAO8T,YAAP,EAAqBE,WAArB,OAAuC,MAAvC,GAAgD,MAAhD,GAAyD,KAA3E;AACA,WAAOR,UAAUK,SAAS1mB,IAAnB,EAAyB4mB,SAAzB,CAAP;AACH;;AAED;;;;;;;AAOA,SAASE,SAAT,CAAoBrmB,IAApB,EAA0BoH,UAA1B,EAAsC;AAClC,QAAMmd,UAAU,IAAIzlB,GAAJ,EAAhB;AACA,QAAMwnB,cAAc,EAApB;;AAEAtmB,SAAK1F,OAAL,CAAa,UAAC+J,KAAD,EAAW;AACpB,YAAMkiB,WAAWliB,MAAM+C,UAAN,CAAjB;AACA,YAAImd,QAAQ7kB,GAAR,CAAY6mB,QAAZ,CAAJ,EAA2B;AACvBD,wBAAY/B,QAAQ5kB,GAAR,CAAY4mB,QAAZ,CAAZ,EAAmC,CAAnC,EAAsC/rB,IAAtC,CAA2C6J,KAA3C;AACH,SAFD,MAEO;AACHiiB,wBAAY9rB,IAAZ,CAAiB,CAAC+rB,QAAD,EAAW,CAACliB,KAAD,CAAX,CAAjB;AACAkgB,oBAAQllB,GAAR,CAAYknB,QAAZ,EAAsBD,YAAY1rB,MAAZ,GAAqB,CAA3C;AACH;AACJ,KARD;;AAUA,WAAO0rB,WAAP;AACH;;AAED;;;;;;;;;AASA,SAASE,kBAAT,CAA6BC,YAA7B,EAA2CC,YAA3C,EAAyDC,kBAAzD,EAA6E;AACzE,QAAMC,MAAM;AACRC,eAAOJ,aAAa,CAAb;AADC,KAAZ;;AAIAC,iBAAajlB,MAAb,CAAoB,UAACC,GAAD,EAAMqC,IAAN,EAAYC,GAAZ,EAAoB;AACpCtC,YAAIqC,IAAJ,IAAY0iB,aAAa,CAAb,EAAgBjtB,GAAhB,CAAoB;AAAA,mBAAS6K,MAAMsiB,mBAAmB3iB,GAAnB,EAAwBqE,KAA9B,CAAT;AAAA,SAApB,CAAZ;AACA,eAAO3G,GAAP;AACH,KAHD,EAGGklB,GAHH;;AAKA,WAAOA,GAAP;AACH;;AAED;;;;;;;AAOA,SAASE,iBAAT,CAA4B9mB,IAA5B,EAAkCC,MAAlC,EAA0C4F,cAA1C,EAA0D;AACtD,QAAIc,kBAAJ;AACA,QAAIogB,iBAAJ;AACA,QAAId,iBAAJ;AACA,QAAIvsB,IAAImM,eAAejL,MAAf,GAAwB,CAAhC;;AAEA,WAAOlB,KAAK,CAAZ,EAAeA,GAAf,EAAoB;AAChBiN,oBAAYd,eAAenM,CAAf,EAAkB,CAAlB,CAAZ;AACAqtB,mBAAWlhB,eAAenM,CAAf,EAAkB,CAAlB,CAAX;AACAusB,mBAAWpL,6DAAaA,CAAC5a,MAAd,EAAsB0G,SAAtB,CAAX;;AAEA,YAAI,CAACsf,QAAL,EAAe;AACX;AACA;AACH;;AAED,YAAIe,yDAAUA,CAACD,QAAX,CAAJ,EAA0B;AACtB;AACA5B,yEAASA,CAACnlB,IAAV,EAAgB,UAACuT,CAAD,EAAIC,CAAJ;AAAA,uBAAUuT,SAASxT,EAAE0S,SAAS5d,KAAX,CAAT,EAA4BmL,EAAEyS,SAAS5d,KAAX,CAA5B,CAAV;AAAA,aAAhB;AACH,SAHD,MAGO,IAAItH,sDAAOA,CAACgmB,QAAR,CAAJ,EAAuB;AAAA;AAC1B,oBAAMT,cAAcD,UAAUrmB,IAAV,EAAgBimB,SAAS5d,KAAzB,CAApB;AACA,oBAAM4e,YAAYF,SAASA,SAASnsB,MAAT,GAAkB,CAA3B,CAAlB;AACA,oBAAM8rB,eAAeK,SAASlqB,KAAT,CAAe,CAAf,EAAkBkqB,SAASnsB,MAAT,GAAkB,CAApC,CAArB;AACA,oBAAM+rB,qBAAqBD,aAAaltB,GAAb,CAAiB;AAAA,2BAAKqhB,6DAAaA,CAAC5a,MAAd,EAAsBlG,CAAtB,CAAL;AAAA,iBAAjB,CAA3B;;AAEAusB,4BAAYhsB,OAAZ,CAAoB,UAACmsB,YAAD,EAAkB;AAClCA,iCAAajsB,IAAb,CAAkBgsB,mBAAmBC,YAAnB,EAAiCC,YAAjC,EAA+CC,kBAA/C,CAAlB;AACH,iBAFD;;AAIAxB,6EAASA,CAACmB,WAAV,EAAuB,UAAC/S,CAAD,EAAIC,CAAJ,EAAU;AAC7B,wBAAM0T,IAAI3T,EAAE,CAAF,CAAV;AACA,wBAAMjX,IAAIkX,EAAE,CAAF,CAAV;AACA,2BAAOyT,UAAUC,CAAV,EAAa5qB,CAAb,CAAP;AACH,iBAJD;;AAMA;AACA0D,qBAAKpF,MAAL,GAAc,CAAd;AACA0rB,4BAAYhsB,OAAZ,CAAoB,UAAC+J,KAAD,EAAW;AAC3BrE,yBAAKxF,IAAL,gCAAa6J,MAAM,CAAN,CAAb;AACH,iBAFD;AAlB0B;AAqB7B,SArBM,MAqBA;AAAA;AACH,oBAAM2gB,SAASgB,oBAAoBC,QAApB,EAA8Bc,QAA9B,CAAf;AACA;AACA5B,6EAASA,CAACnlB,IAAV,EAAgB,UAACuT,CAAD,EAAIC,CAAJ;AAAA,2BAAUwR,OAAOzR,EAAE0S,SAAS5d,KAAX,CAAP,EAA0BmL,EAAEyS,SAAS5d,KAAX,CAA1B,CAAV;AAAA,iBAAhB;AAHG;AAIN;AACJ;AACJ;;AAED;;;;;;;;;AASA,IAAM8e,sBAAsB,SAAtBA,mBAAsB,CAACC,UAAD,EAAapnB,IAAb,EAAmBC,MAAnB,EAA2B4F,cAA3B,EAA8C;AACtE,QAAIuhB,WAAWxsB,MAAX,KAAsB,CAA1B,EAA6B;AAAE,eAAOoF,IAAP;AAAc;;AAE7C,QAAMqnB,YAAYD,WAAW,CAAX,CAAlB;AACA,QAAM5tB,MAAM,IAAIsF,GAAJ,EAAZ;;AAEAkB,SAAKyB,MAAL,CAAY,UAACC,GAAD,EAAM4lB,OAAN,EAAkB;AAC1B,YAAMC,OAAOD,QAAQD,UAAUhf,KAAlB,CAAb;AACA,YAAI3G,IAAIhC,GAAJ,CAAQ6nB,IAAR,CAAJ,EAAmB;AACf7lB,gBAAI/B,GAAJ,CAAQ4nB,IAAR,EAAc/sB,IAAd,CAAmB8sB,OAAnB;AACH,SAFD,MAEO;AACH5lB,gBAAIrC,GAAJ,CAAQkoB,IAAR,EAAc,CAACD,OAAD,CAAd;AACH;AACD,eAAO5lB,GAAP;AACH,KARD,EAQGlI,GARH;;AANsE;AAAA;AAAA;;AAAA;AAgBtE,6BAAuBA,GAAvB,8HAA4B;AAAA;;AAAA;;AAAA,gBAAlB5B,GAAkB;AAAA,gBAAbsa,GAAa;;AACxB,gBAAMsV,OAAOL,oBAAoBC,WAAWvqB,KAAX,CAAiB,CAAjB,CAApB,EAAyCqV,GAAzC,EAA8CjS,MAA9C,EAAsD4F,cAAtD,CAAb;AACArM,gBAAI6F,GAAJ,CAAQzH,GAAR,EAAa4vB,IAAb;AACA,gBAAI3sB,MAAMkG,OAAN,CAAcymB,IAAd,CAAJ,EAAyB;AACrBV,kCAAkBU,IAAlB,EAAwBvnB,MAAxB,EAAgC4F,cAAhC;AACH;AACJ;AAtBqE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAwBtE,WAAOrM,GAAP;AACH,CAzBD;;AA2BA;;;;;;;;;AASA,SAASiuB,cAAT,CAAyBznB,IAAzB,EAA+BC,MAA/B,EAAuC4F,cAAvC,EAAuDuhB,UAAvD,EAAmE;AAC/DvhB,qBAAiBA,eAAeyN,MAAf,CAAsB,UAACoU,MAAD,EAAY;AAC/C,YAAIA,OAAO,CAAP,MAAc,IAAlB,EAAwB;AACpBN,uBAAW5sB,IAAX,CAAgBktB,OAAO,CAAP,CAAhB;AACA,mBAAO,KAAP;AACH;AACD,eAAO,IAAP;AACH,KANgB,CAAjB;AAOA,QAAI7hB,eAAejL,MAAf,KAA0B,CAA9B,EAAiC;AAAE,eAAOoF,IAAP;AAAc;;AAEjDonB,iBAAaA,WAAW5tB,GAAX,CAAe;AAAA,eAAKqhB,6DAAaA,CAAC5a,MAAd,EAAsBrD,CAAtB,CAAL;AAAA,KAAf,CAAb;;AAEA,QAAM+qB,iBAAiBR,oBAAoBC,UAApB,EAAgCpnB,IAAhC,EAAsCC,MAAtC,EAA8C4F,cAA9C,CAAvB;AACA,WAAO7F,KAAKxG,GAAL,CAAS,UAACQ,GAAD,EAAS;AACrB,YAAIN,IAAI,CAAR;AACA,YAAIkuB,UAAUD,cAAd;;AAEA,eAAO,CAAC9sB,MAAMkG,OAAN,CAAc6mB,OAAd,CAAR,EAAgC;AAC5BA,sBAAUA,QAAQjoB,GAAR,CAAY3F,IAAIotB,WAAW1tB,GAAX,EAAgB2O,KAApB,CAAZ,CAAV;AACH;;AAED,eAAOuf,QAAQC,KAAR,EAAP;AACH,KATM,CAAP;AAUH;;AAED;;;;;;AAMO,SAASjG,QAAT,CAAmBkG,OAAnB,EAA4BjiB,cAA5B,EAA4C;AAAA,QACzC5F,MADyC,GACxB6nB,OADwB,CACzC7nB,MADyC;AAAA,QACjCD,IADiC,GACxB8nB,OADwB,CACjC9nB,IADiC;;;AAG/C6F,qBAAiBA,eAAeyN,MAAf,CAAsB;AAAA,eAAW,CAAC,CAACuH,6DAAaA,CAAC5a,MAAd,EAAsB8nB,QAAQ,CAAR,CAAtB,CAAb;AAAA,KAAtB,CAAjB;AACA,QAAIliB,eAAejL,MAAf,KAA0B,CAA9B,EAAiC;AAAE;AAAS;;AAE5C,QAAIotB,kBAAkBniB,eAAewB,SAAf,CAAyB;AAAA,eAAW0gB,QAAQ,CAAR,MAAe,IAA1B;AAAA,KAAzB,CAAtB;AACAC,sBAAkBA,oBAAoB,CAAC,CAArB,GAAyBA,eAAzB,GAA2CniB,eAAejL,MAA5E;;AAEA,QAAMqtB,yBAAyBpiB,eAAehJ,KAAf,CAAqB,CAArB,EAAwBmrB,eAAxB,CAA/B;AACA,QAAME,sBAAsBriB,eAAehJ,KAAf,CAAqBmrB,eAArB,CAA5B;;AAEAlB,sBAAkB9mB,IAAlB,EAAwBC,MAAxB,EAAgCgoB,sBAAhC;AACAjoB,WAAOynB,eAAeznB,IAAf,EAAqBC,MAArB,EAA6BioB,mBAA7B,EAAkDD,uBAAuBzuB,GAAvB,CAA2B;AAAA,eAAUkuB,OAAO,CAAP,CAAV;AAAA,KAA3B,CAAlD,CAAP;;AAEAI,YAAQpkB,IAAR,GAAe1D,KAAKxG,GAAL,CAAS;AAAA,eAAOQ,IAAImuB,GAAJ,EAAP;AAAA,KAAT,CAAf;AACAL,YAAQ9nB,IAAR,GAAeA,IAAf;AACH,C;;;;;;;;;;;;AChQD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;AAOO,SAASsO,KAAT,CAAgBwR,GAAhB,EAAqBC,GAArB,EAA0B;AAC7B,QAAM+B,YAAY,EAAlB;AACA,QAAM7hB,SAAS,EAAf;AACA,QAAM8hB,gBAAgB,EAAtB;AACA,QAAM/hB,OAAO,EAAb;AACA,QAAMmgB,gBAAgBL,IAAI1Z,aAAJ,EAAtB;AACA,QAAMga,gBAAgBL,IAAI3Z,aAAJ,EAAtB;AACA,QAAM4b,wBAAwB7B,cAAclZ,SAAd,EAA9B;AACA,QAAMgb,wBAAwB7B,cAAcnZ,SAAd,EAA9B;AACA,QAAMxN,OAAU0mB,cAAc1mB,IAAxB,eAAsC2mB,cAAc3mB,IAA1D;;AAEA;AACA,QAAI,CAACyoB,gEAAUA,CAACpC,IAAIvc,cAAJ,CAAmBoB,KAAnB,CAAyB,GAAzB,EAA8B3B,IAA9B,EAAX,EAAiD+c,IAAIxc,cAAJ,CAAmBoB,KAAnB,CAAyB,GAAzB,EAA8B3B,IAA9B,EAAjD,CAAL,EAA6F;AACzF,eAAO,IAAP;AACH;;AAED;AACC8c,QAAIvc,cAAJ,CAAmBoB,KAAnB,CAAyB,GAAzB,CAAD,CAAgCrK,OAAhC,CAAwC,UAACqM,SAAD,EAAe;AACnD,YAAM9E,QAAQmgB,sBAAsBrb,SAAtB,CAAd;AACA1G,eAAOzF,IAAP,CAAYuf,sDAAOA,CAAC,EAAR,EAAYlY,MAAM5B,MAAN,EAAZ,CAAZ;AACA8hB,sBAAcvnB,IAAd,CAAmBqH,MAAM5B,MAAN,GAAexG,IAAlC;AACH,KAJD;;AAMA;;;;;;AAMA,aAAS0oB,iBAAT,CAA4B3C,EAA5B,EAAgCvY,SAAhC,EAA2C;AACvC4B,wFAAkBA,CAAC2W,GAAGnc,WAAtB,EAAmC,UAAC3J,CAAD,EAAO;AACtC,gBAAMmnB,QAAQ,EAAd;AACA,gBAAIwB,WAAW,EAAf;AACAN,0BAAcznB,OAAd,CAAsB,UAACgoB,UAAD,EAAgB;AAClC,oBAAMzqB,QAAQoP,UAAUqb,UAAV,EAAsBtb,YAAtB,CAAmChH,IAAnC,CAAwCtG,CAAxC,CAAd;AACA2oB,kCAAgBxqB,KAAhB;AACAgpB,sBAAMyB,UAAN,IAAoBzqB,KAApB;AACH,aAJD;AAKA,gBAAI,CAACiqB,UAAUO,QAAV,CAAL,EAA0B;AACtBriB,qBAAKxF,IAAL,CAAUqmB,KAAV;AACAiB,0BAAUO,QAAV,IAAsB,IAAtB;AACH;AACJ,SAZD;AAaH;;AAED;AACAF,sBAAkBrC,GAAlB,EAAuBkC,qBAAvB;AACAG,sBAAkBpC,GAAlB,EAAuBkC,qBAAvB;;AAEA,WAAO,IAAIzf,+CAAJ,CAAcxC,IAAd,EAAoBC,MAApB,EAA4B,EAAExG,UAAF,EAA5B,CAAP;AACH,C;;;;;;;;;;;;;;;;;;;;;AC7DD;AACA;AACA;AAOA;;AAEA;;;;;;;;;;;;IAWMgT,Q;;AAEF;;;;;;;;;;AAUA,wBAAwB;AAAA;;AACpB,YAAI2b,eAAJ;;AAEA,aAAKrM,OAAL,GAAe,IAAf;AACA,aAAK7G,WAAL,GAAmB,EAAnB;AACA,aAAKO,mBAAL,GAA2B,EAA3B;AACA,aAAKoG,SAAL,GAAiB,EAAjB;;AANoB,0CAARvW,MAAQ;AAARA,kBAAQ;AAAA;;AAQpB,YAAIA,OAAO1K,MAAP,KAAkB,CAAlB,IAAwB,CAACwtB,SAAS9iB,OAAO,CAAP,CAAV,aAAgCmH,QAA5D,EAAuE;AACnE;AACA,iBAAKlJ,cAAL,GAAsB6kB,OAAO7kB,cAA7B;AACA,iBAAKF,WAAL,GAAmB+kB,OAAO/kB,WAA1B;AACA,iBAAK8C,WAAL,GAAmBiiB,OAAOjiB,WAA1B;AACA,iBAAK4V,OAAL,GAAeqM,MAAf;AACA,iBAAKvhB,kBAAL,GAA0B,KAAKkV,OAAL,CAAalV,kBAAvC;AACA,iBAAKwhB,eAAL,GAAuB9Y,0DAAWA,EAAlC;AACA,iBAAK7H,qBAAL,GAA6BC,qBAA7B;AACH,SATD,MASO;AACH2S,8DAAUA,mBAAC,IAAX,SAAoBhV,MAApB;AACA,iBAAK+iB,eAAL,GAAuB,KAAKxhB,kBAAL,CAAwBpN,IAA/C;AACA,iBAAKiO,qBAAL,GAA6BC,qBAA7B;AACA,iBAAKgC,qBAAL,GAA6B;AACzB+S,gCAAgB,EADS;AAEzBY,kCAAkB;AAFO,aAA7B;AAIH;AACJ;;AAED;;;;;;;;;;;;;;;;;;;;;;;;oCAoBa;AACT,mBAAO,KAAKlX,aAAL,GAAqBxE,MAArB,CAA4BpI,GAA5B,CAAgC;AAAA,uBAAK8J,EAAErD,MAAF,EAAL;AAAA,aAAhC,CAAP;AACH;;AAED;;;;;;;;;;;kCAQU;AACN,mBAAO,KAAKooB,eAAZ;AACH;;;wCAEgB;AACb,mBAAO,KAAKC,WAAZ;AACH;;;gDAEwB;AACrB,iBAAKA,WAAL,GAAmB9T,4DAAYA,CAAC,CAAC,KAAKnR,WAAN,EAAmB,KAAKE,cAAxB,CAAb,EACd,KAAKN,oBAAL,EADc,EACe,KAAKolB,eADpB,CAAnB;AAEA,mBAAO,IAAP;AACH;;;+CAEuB;AACpB,mBAAO,KAAKxhB,kBAAZ;AACH;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6BA8BM0hB,Q,EAAUlM,Q,EAAU;AACtB,mBAAOrO,8DAAYA,CAAC,IAAb,EAAmBua,QAAnB,EAA6BlM,QAA7B,CAAP;AACH;;AAED;;;;;;;;;;;;;;;;;;;;;;;oCAoBakM,Q,EAAU;AACnB,mBAAOva,8DAAYA,CAAC,IAAb,EAAmBua,QAAnB,EAA6BnD,mEAAiBA,CAAC,IAAlB,EAAwBmD,QAAxB,CAA7B,EAAgE,IAAhE,CAAP;AACH;;AAED;;;;;;;;;;;;;;;;;;;;;8BAkBOC,S,EAAW;AACd,mBAAOla,wDAAM,IAAN,EAAYka,SAAZ,CAAP;AACH;;AAED;;;;;;;;;;;;;;;;;;;;mCAiBYC,c,EAAgB;AACxB,mBAAOxa,6DAAW,IAAX,EAAiBwa,cAAjB,CAAP;AACH;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+BA+CQxR,Q,EAAU9R,M,EAAQ;AACtB,gBAAMsG,YAAY;AACdC,sBAAMC,oDAAaA,CAACC,MADN;AAEdxG,2BAAW;AAFG,aAAlB;AAIAD,qBAAS/K,OAAOgH,MAAP,CAAc,EAAd,EAAkBqK,SAAlB,EAA6BtG,MAA7B,CAAT;AACAA,mBAAOuG,IAAP,GAAcvG,OAAOuG,IAAP,IAAeD,UAAUC,IAAvC;;AAEA,gBAAM4N,cAAc,EAAElU,WAAWD,OAAOC,SAApB,EAApB;AACA,mBAAOiU,+DAAeA,CAClB,IADG,EAEHpC,QAFG,EAGH9R,MAHG,EAIHmU,WAJG,CAAP;AAMH;;AAED;;;;;;;;;;;;;;;;;;;;;kCAkBW;AACP,mBAAO,CAAC,KAAKjW,WAAL,CAAiBzI,MAAlB,IAA4B,CAAC,KAAK2I,cAAL,CAAoB3I,MAAxD;AACH;;AAED;;;;;;;;;;gCAOyB;AAAA,gBAAlBwK,SAAkB,uEAAN,IAAM;;AACrB,gBAAM4R,WAAW,IAAI,KAAK9Q,WAAT,CAAqB,IAArB,CAAjB;AACA,gBAAId,SAAJ,EAAe;AACX4R,yBAASpR,SAAT,CAAmB,IAAnB;AACH,aAFD,MAEO;AACHoR,yBAASpR,SAAT,CAAmB,IAAnB;AACH;AACD,mBAAOoR,QAAP;AACH;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gCA2CS0C,S,EAAWvU,M,EAAQ;AACxB,gBAAMsG,YAAY;AACdC,sBAAMC,oDAAaA,CAACC,MADN;AAEdxG,2BAAW;AAFG,aAAlB;AAIAD,qBAAS/K,OAAOgH,MAAP,CAAc,EAAd,EAAkBqK,SAAlB,EAA6BtG,MAA7B,CAAT;AACA,gBAAM6G,cAAc,KAAKhE,eAAL,EAApB;AACA,gBAAMiE,YAAY7R,OAAOmI,IAAP,CAAYyJ,WAAZ,CAAlB;AAPwB,0BAQP7G,MARO;AAAA,gBAQhBuG,IARgB,WAQhBA,IARgB;;AASxB,gBAAMgS,sBAAsBtR,sEAAsBA,CAACsN,SAAvB,EAAkCzN,SAAlC,EAA6CD,WAA7C,CAA5B;;AAEA,gBAAIgP,kBAAJ;;AAEA,gBAAItP,SAASC,oDAAaA,CAACmB,GAA3B,EAAgC;AAC5B,oBAAI4b,kBAAkBjP,gEAAgBA,CAAC,IAAjB,EAAuBiE,mBAAvB,EAA4C;AAC9DhS,0BAAMC,oDAAaA,CAACC,MAD0C;AAE9DxG,+BAAWD,OAAOC;AAF4C,iBAA5C,EAGnB6G,SAHmB,CAAtB;AAIA,oBAAI0c,iBAAiBlP,gEAAgBA,CAAC,IAAjB,EAAuBiE,mBAAvB,EAA4C;AAC7DhS,0BAAMC,oDAAaA,CAACkB,OADyC;AAE7DzH,+BAAWD,OAAOC;AAF2C,iBAA5C,EAGlB6G,SAHkB,CAArB;AAIA+O,4BAAY,CAAC0N,eAAD,EAAkBC,cAAlB,CAAZ;AACH,aAVD,MAUO;AACH,oBAAID,mBAAkBjP,gEAAgBA,CAAC,IAAjB,EAAuBiE,mBAAvB,EAA4CvY,MAA5C,EAAoD8G,SAApD,CAAtB;AACA+O,4BAAY0N,gBAAZ;AACH;;AAED,mBAAO1N,SAAP;AACH;;;0CAEkB;AACf,mBAAO,KAAK4N,YAAZ;AACH;;;gDAEwB;AACrB,iBAAKA,YAAL,GAAoB,KAAKN,WAAL,CAAiB1mB,MAAjB,CAAwBH,MAAxB,CAA+B,UAACC,GAAD,EAAMmnB,QAAN,EAAgBnvB,CAAhB,EAAsB;AACrEgI,oBAAImnB,SAASpvB,IAAT,EAAJ,IAAuB;AACnB4O,2BAAO3O,CADY;AAEnBmf,yBAAKgQ,SAAS5oB,MAAT;AAFc,iBAAvB;AAIA,uBAAOyB,GAAP;AACH,aANmB,EAMjB,EANiB,CAApB;AAOA,mBAAO,IAAP;AACH;;AAGD;;;;;;;;;kCAMW;AACP,iBAAKqa,OAAL,IAAgB,KAAKA,OAAL,CAAa+M,WAAb,CAAyB,IAAzB,CAAhB;AACA,iBAAK/M,OAAL,GAAe,IAAf;AACA,iBAAKF,SAAL,CAAevhB,OAAf,CAAuB,UAACwhB,KAAD,EAAW;AAC9BA,sBAAMC,OAAN,GAAgB,IAAhB;AACH,aAFD;AAGA,iBAAKF,SAAL,GAAiB,EAAjB;AACH;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oCA0BaC,K,EAAO;AAChB,gBAAI9X,MAAM,KAAK6X,SAAL,CAAexU,SAAf,CAAyB;AAAA,uBAAW0hB,YAAYjN,KAAvB;AAAA,aAAzB,CAAV;AACA9X,oBAAQ,CAAC,CAAT,GAAa,KAAK6X,SAAL,CAAeta,MAAf,CAAsByC,GAAtB,EAA2B,CAA3B,CAAb,GAA6C,IAA7C;AACH;;AAED;;;;;;;;kCAKWglB,M,EAAQ;AACf,iBAAKjN,OAAL,IAAgB,KAAKA,OAAL,CAAa+M,WAAb,CAAyB,IAAzB,CAAhB;AACA,iBAAK/M,OAAL,GAAeiN,MAAf;AACAA,sBAAUA,OAAOnN,SAAP,CAAiBrhB,IAAjB,CAAsB,IAAtB,CAAV;AACH;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;oCAwBa;AACT,mBAAO,KAAKuhB,OAAZ;AACH;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;sCAyBe;AACX,mBAAO,KAAKF,SAAZ;AACH;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;yCAwBkB;AACd,mBAAO,KAAK3G,WAAZ;AACH;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAwB0B;AACtB,mBAAO,KAAKO,mBAAZ;AACH;;;;;;AAGUhJ,uEAAf,E;;;;;;;;;;;;ACjkBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;IAEemW,G,GAAoDc,kE,CAApDd,G;IAAKI,G,GAA+CU,kE,CAA/CV,G;IAAKzS,G,GAA0CmT,kE,CAA1CnT,G;IAAKE,G,GAAqCiT,kE,CAArCjT,G;IAAKyS,K,GAAgCQ,kE,CAAhCR,K;IAAOC,I,GAAyBO,kE,CAAzBP,I;IAAMC,K,GAAmBM,kE,CAAnBN,K;IAAY6F,E,GAAOvF,kE,CAAZF,G;;;;;;;;;;;;;ACFvD;AAAA;;;;;;AAMe,yEAAC3kB,KAAD,EAAW;AACtB,QAAInF,IAAI,CAAR;AACA,WAAO,YAAe;AAAA,0CAAXkI,MAAW;AAAXA,kBAAW;AAAA;;AAClBA,eAAOtH,OAAP,CAAe,UAAC4X,GAAD,EAAM9K,UAAN,EAAqB;AAChC,gBAAI,EAAEvI,MAAMuI,UAAN,aAA6BvM,KAA/B,CAAJ,EAA2C;AACvCgE,sBAAMuI,UAAN,IAAoBvM,MAAM+iB,IAAN,CAAW,EAAEhjB,QAAQlB,CAAV,EAAX,CAApB;AACH;AACDmF,kBAAMuI,UAAN,EAAkB5M,IAAlB,CAAuB0X,GAAvB;AACH,SALD;AAMAxY;AACH,KARD;AASH,CAXD,E;;;;;;;;;;;;;;;;ACNA;;;;;;AAMA,SAASwvB,mBAAT,CAA8BjuB,IAA9B,EAAoC;AAChC,QAAIA,gBAAgB9C,IAApB,EAA0B;AACtB,eAAO8C,IAAP;AACH;;AAED,WAAO,IAAI9C,IAAJ,CAAS8C,IAAT,CAAP;AACH;AACD;;;;;;;AAOA,SAASR,GAAT,CAAc6B,CAAd,EAAiB;AACb,WAAQA,IAAI,EAAL,SAAgBA,CAAhB,GAAuBA,CAA9B;AACH;AACD;;;;;;;;;AASA;;;;;;;AAOAP,OAAOotB,MAAP,GAAgB,UAAUjtB,IAAV,EAAgB;AAC5B,WAAOA,KAAKY,OAAL,CAAa,0BAAb,EAAyC,MAAzC,CAAP;AACH,CAFD;;AAIA;;;;;;;;AAQA,0BAA2B,SAAS4R,iBAAT,CAA4B/V,MAA5B,EAAoC;AAC3D,SAAKA,MAAL,GAAcA,MAAd;AACA,SAAKywB,QAAL,GAAgB7kB,SAAhB;AACA,SAAKyO,UAAL,GAAkBzO,SAAlB;AACH;;AAED;AACAmK,kBAAkB2a,YAAlB,GAAiC,GAAjC;;AAEA;AACA;AACA3a,kBAAkB4a,uBAAlB,GAA4C;AACxCC,UAAM,CADkC;AAExCC,WAAO,CAFiC;AAGxCC,SAAK,CAHmC;AAIxCC,UAAM,CAJkC;AAKxCC,YAAQ,CALgC;AAMxCC,YAAQ,CANgC;AAOxCC,iBAAa;AAP2B,CAA5C;;AAUA;;;;;;;AAOAnb,kBAAkBob,mBAAlB,GAAwC,UAAUC,MAAV,EAAkB;AACtD,WAAO,UAAU7X,GAAV,EAAe;AAClB,YAAIW,kBAAJ;AACA,YAAIkB,SAASlB,YAAYmX,SAAS9X,GAAT,EAAc,EAAd,CAArB,CAAJ,EAA6C;AACzC,mBAAOW,SAAP;AACH;;AAED,eAAOkX,MAAP;AACH,KAPD;AAQH,CATD;;AAWA;;;;;;;;AAQArb,kBAAkBub,kBAAlB,GAAuC,UAAU3R,KAAV,EAAiByR,MAAjB,EAAyB;AAC5D,WAAO,UAAC7X,GAAD,EAAS;AACZ,YAAIxY,UAAJ;AACA,YAAIwwB,UAAJ;;AAEA,YAAI,CAAChY,GAAL,EAAU;AAAE,mBAAO6X,MAAP;AAAgB;;AAE5B,YAAMI,OAAOjY,IAAIkU,WAAJ,EAAb;;AAEA,aAAK1sB,IAAI,CAAJ,EAAOwwB,IAAI5R,MAAM1d,MAAtB,EAA8BlB,IAAIwwB,CAAlC,EAAqCxwB,GAArC,EAA0C;AACtC,gBAAI4e,MAAM5e,CAAN,EAAS0sB,WAAT,OAA2B+D,IAA/B,EAAqC;AACjC,uBAAOzwB,CAAP;AACH;AACJ;;AAED,YAAIA,MAAM6K,SAAV,EAAqB;AACjB,mBAAOwlB,MAAP;AACH;AACD,eAAO,IAAP;AACH,KAlBD;AAmBH,CApBD;;AAsBA;;;;;;;;;;;;;;;;;AAiBArb,kBAAkB0b,mBAAlB,GAAwC,YAAY;AAChD,QAAMC,UAAU;AACZC,eAAO,CACH,KADG,EAEH,KAFG,EAGH,KAHG,EAIH,KAJG,EAKH,KALG,EAMH,KANG,EAOH,KAPG,CADK;AAUZC,cAAM,CACF,QADE,EAEF,QAFE,EAGF,SAHE,EAIF,WAJE,EAKF,UALE,EAMF,QANE,EAOF,UAPE;AAVM,KAAhB;AAoBA,QAAMC,YAAY;AACdF,eAAO,CACH,KADG,EAEH,KAFG,EAGH,KAHG,EAIH,KAJG,EAKH,KALG,EAMH,KANG,EAOH,KAPG,EAQH,KARG,EASH,KATG,EAUH,KAVG,EAWH,KAXG,EAYH,KAZG,CADO;AAedC,cAAM,CACF,SADE,EAEF,UAFE,EAGF,OAHE,EAIF,OAJE,EAKF,KALE,EAMF,MANE,EAOF,MAPE,EAQF,QARE,EASF,WATE,EAUF,SAVE,EAWF,UAXE,EAYF,UAZE;AAfQ,KAAlB;;AA+BA,QAAME,cAAc;AAChBC,WAAG;AACC;AACAjxB,kBAAM,GAFP;AAGC4O,mBAAO,CAHR;AAICsiB,mBAJD,qBAIY;AAAE,uBAAO,QAAP;AAAkB,aAJhC;;AAKC/Y,oBAAQlD,kBAAkBob,mBAAlB,EALT;AAMCjnB,qBAND,qBAMYqP,GANZ,EAMiB;AACZ,oBAAM5O,IAAI4lB,oBAAoBhX,GAApB,CAAV;;AAEA,uBAAO5O,EAAEsnB,QAAF,GAAaC,QAAb,EAAP;AACH;AAVF,SADa;AAahBX,WAAG;AACC;AACAzwB,kBAAM,GAFP;AAGC4O,mBAAO,CAHR;AAICsiB,mBAJD,qBAIY;AAAE,uBAAO,QAAP;AAAkB,aAJhC;;AAKC/Y,oBAAQlD,kBAAkBob,mBAAlB,EALT;AAMCjnB,qBAND,qBAMYqP,GANZ,EAMiB;AACZ,oBAAM5O,IAAI4lB,oBAAoBhX,GAApB,CAAV;AACA,oBAAMhX,QAAQoI,EAAEsnB,QAAF,KAAe,EAA7B;;AAEA,uBAAO,CAAC1vB,UAAU,CAAV,GAAc,EAAd,GAAmBA,KAApB,EAA2B2vB,QAA3B,EAAP;AACH;AAXF,SAba;AA0BhBC,WAAG;AACC;AACArxB,kBAAM,GAFP;AAGC4O,mBAAO,CAHR;AAICsiB,mBAJD,qBAIY;AAAE,uBAAO,SAAP;AAAmB,aAJjC;;AAKC/Y,oBAAQ,gBAACM,GAAD,EAAS;AACb,oBAAIA,GAAJ,EAAS;AACL,2BAAOA,IAAIkU,WAAJ,EAAP;AACH;AACD,uBAAO,IAAP;AACH,aAVF;AAWCvjB,uBAAW,mBAACqP,GAAD,EAAS;AAChB,oBAAM5O,IAAI4lB,oBAAoBhX,GAApB,CAAV;AACA,oBAAMhX,QAAQoI,EAAEsnB,QAAF,EAAd;;AAEA,uBAAQ1vB,QAAQ,EAAR,GAAa,IAAb,GAAoB,IAA5B;AACH;AAhBF,SA1Ba;AA4ChB6vB,WAAG;AACC;AACAtxB,kBAAM,GAFP;AAGC4O,mBAAO,CAHR;AAICsiB,mBAJD,qBAIY;AAAE,uBAAO,SAAP;AAAmB,aAJjC;;AAKC/Y,oBAAQ,gBAACM,GAAD,EAAS;AACb,oBAAIA,GAAJ,EAAS;AACL,2BAAOA,IAAIkU,WAAJ,EAAP;AACH;AACD,uBAAO,IAAP;AACH,aAVF;AAWCvjB,uBAAW,mBAACqP,GAAD,EAAS;AAChB,oBAAM5O,IAAI4lB,oBAAoBhX,GAApB,CAAV;AACA,oBAAMhX,QAAQoI,EAAEsnB,QAAF,EAAd;;AAEA,uBAAQ1vB,QAAQ,EAAR,GAAa,IAAb,GAAoB,IAA5B;AACH;AAhBF,SA5Ca;AA8DhB8vB,WAAG;AACC;AACAvxB,kBAAM,GAFP;AAGC4O,mBAAO,CAHR;AAICsiB,mBAJD,qBAIY;AAAE,uBAAO,QAAP;AAAkB,aAJhC;;AAKC/Y,oBAAQlD,kBAAkBob,mBAAlB,EALT;AAMCjnB,qBAND,qBAMYqP,GANZ,EAMiB;AACZ,oBAAM5O,IAAI4lB,oBAAoBhX,GAApB,CAAV;AACA,oBAAM+Y,OAAO3nB,EAAE4nB,UAAF,EAAb;;AAEA,uBAAOzwB,IAAIwwB,IAAJ,CAAP;AACH;AAXF,SA9Da;AA2EhBE,WAAG;AACC;AACA1xB,kBAAM,GAFP;AAGC4O,mBAAO,CAHR;AAICsiB,mBAJD,qBAIY;AAAE,uBAAO,QAAP;AAAkB,aAJhC;;AAKC/Y,oBAAQlD,kBAAkBob,mBAAlB,EALT;AAMCjnB,qBAND,qBAMYqP,GANZ,EAMiB;AACZ,oBAAM5O,IAAI4lB,oBAAoBhX,GAApB,CAAV;AACA,oBAAM5W,UAAUgI,EAAE8nB,UAAF,EAAhB;;AAEA,uBAAO3wB,IAAIa,OAAJ,CAAP;AACH;AAXF,SA3Ea;AAwFhB+vB,WAAG;AACC;AACA5xB,kBAAM,GAFP;AAGC4O,mBAAO,CAHR;AAICsiB,mBAJD,qBAIY;AAAE,uBAAO,QAAP;AAAkB,aAJhC;;AAKC/Y,oBAAQlD,kBAAkBob,mBAAlB,EALT;AAMCjnB,qBAND,qBAMYqP,GANZ,EAMiB;AACZ,oBAAM5O,IAAI4lB,oBAAoBhX,GAApB,CAAV;AACA,oBAAMoZ,KAAKhoB,EAAEioB,eAAF,EAAX;;AAEA,uBAAOD,GAAGT,QAAH,EAAP;AACH;AAXF,SAxFa;AAqGhBtX,WAAG;AACC;AACA9Z,kBAAM,GAFP;AAGC4O,mBAAO,CAHR;AAICsiB,mBAJD,qBAIY;AAAE,6BAAWN,QAAQC,KAAR,CAAczwB,IAAd,CAAmB,GAAnB,CAAX;AAAwC,aAJtD;;AAKC+X,oBAAQlD,kBAAkBub,kBAAlB,CAAqCI,QAAQC,KAA7C,CALT;AAMCznB,qBAND,qBAMYqP,GANZ,EAMiB;AACZ,oBAAM5O,IAAI4lB,oBAAoBhX,GAApB,CAAV;AACA,oBAAMsZ,MAAMloB,EAAEmoB,MAAF,EAAZ;;AAEA,uBAAQpB,QAAQC,KAAR,CAAckB,GAAd,CAAD,CAAqBX,QAArB,EAAP;AACH;AAXF,SArGa;AAkHhBa,WAAG;AACC;AACAjyB,kBAAM,GAFP;AAGC4O,mBAAO,CAHR;AAICsiB,mBAJD,qBAIY;AAAE,6BAAWN,QAAQE,IAAR,CAAa1wB,IAAb,CAAkB,GAAlB,CAAX;AAAuC,aAJrD;;AAKC+X,oBAAQlD,kBAAkBub,kBAAlB,CAAqCI,QAAQE,IAA7C,CALT;AAMC1nB,qBAND,qBAMYqP,GANZ,EAMiB;AACZ,oBAAM5O,IAAI4lB,oBAAoBhX,GAApB,CAAV;AACA,oBAAMsZ,MAAMloB,EAAEmoB,MAAF,EAAZ;;AAEA,uBAAQpB,QAAQE,IAAR,CAAaiB,GAAb,CAAD,CAAoBX,QAApB,EAAP;AACH;AAXF,SAlHa;AA+HhBjnB,WAAG;AACC;AACAnK,kBAAM,GAFP;AAGC4O,mBAAO,CAHR;AAICsiB,mBAJD,qBAIY;AAAE,uBAAO,QAAP;AAAkB,aAJhC;;AAKC/Y,oBAAQlD,kBAAkBob,mBAAlB,EALT;AAMCjnB,qBAND,qBAMYqP,GANZ,EAMiB;AACZ,oBAAM5O,IAAI4lB,oBAAoBhX,GAApB,CAAV;AACA,oBAAMsZ,MAAMloB,EAAEqoB,OAAF,EAAZ;;AAEA,uBAAOH,IAAIX,QAAJ,EAAP;AACH;AAXF,SA/Ha;AA4IhBvnB,WAAG;AACC;AACA7J,kBAAM,GAFP;AAGC4O,mBAAO,CAHR;AAICsiB,mBAJD,qBAIY;AAAE,uBAAO,QAAP;AAAkB,aAJhC;;AAKC/Y,oBAAQlD,kBAAkBob,mBAAlB,EALT;AAMCjnB,qBAND,qBAMYqP,GANZ,EAMiB;AACZ,oBAAM5O,IAAI4lB,oBAAoBhX,GAApB,CAAV;AACA,oBAAMsZ,MAAMloB,EAAEqoB,OAAF,EAAZ;;AAEA,uBAAOlxB,IAAI+wB,GAAJ,CAAP;AACH;AAXF,SA5Ia;AAyJhBhY,WAAG;AACC;AACA/Z,kBAAM,GAFP;AAGC4O,mBAAO,CAHR;AAICsiB,mBAJD,qBAIY;AAAE,6BAAWH,UAAUF,KAAV,CAAgBzwB,IAAhB,CAAqB,GAArB,CAAX;AAA0C,aAJxD;;AAKC+X,oBAAQlD,kBAAkBub,kBAAlB,CAAqCO,UAAUF,KAA/C,CALT;AAMCznB,qBAND,qBAMYqP,GANZ,EAMiB;AACZ,oBAAM5O,IAAI4lB,oBAAoBhX,GAApB,CAAV;AACA,oBAAM0Z,QAAQtoB,EAAEuoB,QAAF,EAAd;;AAEA,uBAAQrB,UAAUF,KAAV,CAAgBsB,KAAhB,CAAD,CAAyBf,QAAzB,EAAP;AACH;AAXF,SAzJa;AAsKhBiB,WAAG;AACC;AACAryB,kBAAM,GAFP;AAGC4O,mBAAO,CAHR;AAICsiB,mBAJD,qBAIY;AAAE,6BAAWH,UAAUD,IAAV,CAAe1wB,IAAf,CAAoB,GAApB,CAAX;AAAyC,aAJvD;;AAKC+X,oBAAQlD,kBAAkBub,kBAAlB,CAAqCO,UAAUD,IAA/C,CALT;AAMC1nB,qBAND,qBAMYqP,GANZ,EAMiB;AACZ,oBAAM5O,IAAI4lB,oBAAoBhX,GAApB,CAAV;AACA,oBAAM0Z,QAAQtoB,EAAEuoB,QAAF,EAAd;;AAEA,uBAAQrB,UAAUD,IAAV,CAAeqB,KAAf,CAAD,CAAwBf,QAAxB,EAAP;AACH;AAXF,SAtKa;AAmLhB3D,WAAG;AACC;AACAztB,kBAAM,GAFP;AAGC4O,mBAAO,CAHR;AAICsiB,mBAJD,qBAIY;AAAE,uBAAO,QAAP;AAAkB,aAJhC;AAKC/Y,kBALD,kBAKSM,GALT,EAKc;AAAE,uBAAOxD,kBAAkBob,mBAAlB,GAAwC5X,GAAxC,IAA+C,CAAtD;AAA0D,aAL1E;AAMCrP,qBAND,qBAMYqP,GANZ,EAMiB;AACZ,oBAAM5O,IAAI4lB,oBAAoBhX,GAApB,CAAV;AACA,oBAAM0Z,QAAQtoB,EAAEuoB,QAAF,EAAd;;AAEA,uBAAOpxB,IAAImxB,QAAQ,CAAZ,CAAP;AACH;AAXF,SAnLa;AAgMhBG,WAAG;AACC;AACAtyB,kBAAM,GAFP;AAGC4O,mBAAO,CAHR;AAICsiB,mBAJD,qBAIY;AAAE,uBAAO,UAAP;AAAoB,aAJlC;AAKC/Y,kBALD,kBAKSM,GALT,EAKc;AACT,oBAAIG,eAAJ;AACA,oBAAIH,GAAJ,EAAS;AACL,wBAAMgY,IAAIhY,IAAItX,MAAd;AACAsX,0BAAMA,IAAI8Z,SAAJ,CAAc9B,IAAI,CAAlB,EAAqBA,CAArB,CAAN;AACH;AACD,oBAAIrX,YAAYnE,kBAAkBob,mBAAlB,GAAwC5X,GAAxC,CAAhB;AACA,oBAAI+Z,cAAc,IAAI9zB,IAAJ,EAAlB;AACA,oBAAI+zB,cAAcpY,KAAKqY,KAAL,CAAYF,YAAYG,WAAZ,EAAD,GAA8B,GAAzC,CAAlB;;AAEA/Z,8BAAY6Z,WAAZ,GAA0BrZ,SAA1B;;AAEA,oBAAIqW,oBAAoB7W,MAApB,EAA4B+Z,WAA5B,KAA4CH,YAAYG,WAAZ,EAAhD,EAA2E;AACvE/Z,mCAAY6Z,cAAc,CAA1B,IAA8BrZ,SAA9B;AACH;AACD,uBAAOqW,oBAAoB7W,MAApB,EAA4B+Z,WAA5B,EAAP;AACH,aArBF;AAsBCvpB,qBAtBD,qBAsBYqP,GAtBZ,EAsBiB;AACZ,oBAAM5O,IAAI4lB,oBAAoBhX,GAApB,CAAV;AACA,oBAAInX,OAAOuI,EAAE8oB,WAAF,GAAgBvB,QAAhB,EAAX;AACA,oBAAIX,UAAJ;;AAEA,oBAAInvB,IAAJ,EAAU;AACNmvB,wBAAInvB,KAAKH,MAAT;AACAG,2BAAOA,KAAKixB,SAAL,CAAe9B,IAAI,CAAnB,EAAsBA,CAAtB,CAAP;AACH;;AAED,uBAAOnvB,IAAP;AACH;AAjCF,SAhMa;AAmOhBsxB,WAAG;AACC;AACA5yB,kBAAM,GAFP;AAGC4O,mBAAO,CAHR;AAICsiB,mBAJD,qBAIY;AAAE,uBAAO,UAAP;AAAoB,aAJlC;;AAKC/Y,oBAAQlD,kBAAkBob,mBAAlB,EALT;AAMCjnB,qBAND,qBAMYqP,GANZ,EAMiB;AACZ,oBAAM5O,IAAI4lB,oBAAoBhX,GAApB,CAAV;AACA,oBAAMnX,OAAOuI,EAAE8oB,WAAF,GAAgBvB,QAAhB,EAAb;;AAEA,uBAAO9vB,IAAP;AACH;AAXF;AAnOa,KAApB;;AAkPA,WAAO0vB,WAAP;AACH,CAvSD;;AAySA;;;;;;AAMA/b,kBAAkB4d,mBAAlB,GAAwC,YAAY;AAChD,QAAM7B,cAAc/b,kBAAkB0b,mBAAlB,EAApB;;AAEA,WAAO;AACHV,cAAMe,YAAYC,CADf;AAEH6B,iBAAS9B,YAAYP,CAFlB;AAGHsC,wBAAgB/B,YAAYK,CAHzB;AAIH2B,wBAAgBhC,YAAYM,CAJzB;AAKHpB,gBAAQc,YAAYO,CALjB;AAMHpB,gBAAQa,YAAYU,CANjB;AAOHuB,mBAAWjC,YAAYlX,CAPpB;AAQHoZ,kBAAUlC,YAAYiB,CARnB;AASHkB,sBAAcnC,YAAY7mB,CATvB;AAUHipB,qCAA6BpC,YAAYnnB,CAVtC;AAWHwpB,qBAAarC,YAAYjX,CAXtB;AAYHuZ,oBAAYtC,YAAYqB,CAZrB;AAaHkB,uBAAevC,YAAYvD,CAbxB;AAcH+F,oBAAYxC,YAAYsB,CAdrB;AAeHmB,mBAAWzC,YAAY4B;AAfpB,KAAP;AAiBH,CApBD;;AAsBA;;;;;;;AAOA3d,kBAAkBye,aAAlB,GAAkC,YAAY;AAC1C,QAAM1C,cAAc/b,kBAAkB0b,mBAAlB,EAApB;AACA,QAAMgD,kBAAkB,SAAlBA,eAAkB,GAAa;AAAE;AACnC,YAAI1zB,IAAI,CAAR;AACA,YAAIktB,YAAJ;AACA,YAAIyG,oBAAJ;AACA,YAAMnD,IAAI,UAAKtvB,MAAf;;AAEA,eAAOlB,IAAIwwB,CAAX,EAAcxwB,GAAd,EAAmB;AACfktB,sCAAWltB,CAAX,yBAAWA,CAAX;AACA,oCAASA,CAAT,yBAASA,CAAT,GAAa;AACT2zB,8BAAczG,GAAd;AACH;AACJ;;AAED,YAAI,CAACyG,WAAL,EAAkB;AAAE,mBAAO,IAAP;AAAc;;AAElC,eAAOA,YAAY,CAAZ,EAAezb,MAAf,CAAsByb,YAAY,CAAZ,CAAtB,CAAP;AACH,KAhBD;;AAkBA,WAAO;AACH9D,cAAM,CAACkB,YAAYsB,CAAb,EAAgBtB,YAAY4B,CAA5B,EACFe,eADE,CADH;AAIH5D,eAAO,CAACiB,YAAYjX,CAAb,EAAgBiX,YAAYqB,CAA5B,EAA+BrB,YAAYvD,CAA3C,EACHkG,eADG,CAJJ;AAOH3D,aAAK,CAACgB,YAAYlX,CAAb,EAAgBkX,YAAYiB,CAA5B,EAA+BjB,YAAY7mB,CAA3C,EAA8C6mB,YAAYnnB,CAA1D,EACD8pB,eADC,CAPF;AAUH1D,cAAM,CAACe,YAAYC,CAAb,EAAgBD,YAAYP,CAA5B,EAA+BO,YAAYK,CAA3C,EAA8CL,YAAYM,CAA1D,EACF,UAAUuC,YAAV,EAAwBC,YAAxB,EAAsCC,SAAtC,EAAiDC,SAAjD,EAA4D;AACxD,gBAAIJ,oBAAJ;AACA,gBAAIK,eAAJ;AACA,gBAAIC,aAAJ;AACA,gBAAIzb,YAAJ;;AAEA,gBAAIqb,iBAAiBG,SAAUF,aAAaC,SAAxC,CAAJ,EAAyD;AACrD,oBAAIC,OAAO,CAAP,EAAU9b,MAAV,CAAiB8b,OAAO,CAAP,CAAjB,MAAgC,IAApC,EAA0C;AACtCC,2BAAO,IAAP;AACH;;AAEDN,8BAAcE,YAAd;AACH,aAND,MAMO,IAAIA,YAAJ,EAAkB;AACrBF,8BAAcE,YAAd;AACH,aAFM,MAEA;AACHF,8BAAcC,YAAd;AACH;;AAED,gBAAI,CAACD,WAAL,EAAkB;AAAE,uBAAO,IAAP;AAAc;;AAElCnb,kBAAMmb,YAAY,CAAZ,EAAezb,MAAf,CAAsByb,YAAY,CAAZ,CAAtB,CAAN;AACA,gBAAIM,IAAJ,EAAU;AACNzb,uBAAO,EAAP;AACH;AACD,mBAAOA,GAAP;AACH,SA1BC,CAVH;AAsCHyX,gBAAQ,CAACc,YAAYO,CAAb,EACJoC,eADI,CAtCL;AAyCHxD,gBAAQ,CAACa,YAAYU,CAAb,EACJiC,eADI;AAzCL,KAAP;AA6CH,CAjED;;AAmEA;;;;;AAKA1e,kBAAkBkf,UAAlB,GAA+B,UAAUj1B,MAAV,EAAkB;AAC7C,QAAMk1B,cAAcnf,kBAAkB2a,YAAtC;AACA,QAAMoB,cAAc/b,kBAAkB0b,mBAAlB,EAApB;AACA,QAAM0D,gBAAgB1zB,OAAOmI,IAAP,CAAYkoB,WAAZ,CAAtB;AACA,QAAMsD,aAAa,EAAnB;AACA,QAAIr0B,UAAJ;AACA,QAAIs0B,oBAAJ;;AAEA,WAAO,CAACt0B,IAAIf,OAAOsL,OAAP,CAAe4pB,WAAf,EAA4Bn0B,IAAI,CAAhC,CAAL,KAA4C,CAAnD,EAAsD;AAClDs0B,sBAAcr1B,OAAOe,IAAI,CAAX,CAAd;AACA,YAAIo0B,cAAc7pB,OAAd,CAAsB+pB,WAAtB,MAAuC,CAAC,CAA5C,EAA+C;AAAE;AAAW;;AAE5DD,mBAAWvzB,IAAX,CAAgB;AACZ6N,mBAAO3O,CADK;AAEZgD,mBAAOsxB;AAFK,SAAhB;AAIH;;AAED,WAAOD,UAAP;AACH,CAnBD;;AAqBA;;;;;;AAMArf,kBAAkBuF,QAAlB,GAA6B,UAAUhZ,IAAV,EAAgBtC,MAAhB,EAAwB;AACjD,QAAMs1B,QAAQ/E,oBAAoBjuB,IAApB,CAAd;AACA,QAAM8yB,aAAarf,kBAAkBkf,UAAlB,CAA6Bj1B,MAA7B,CAAnB;AACA,QAAM8xB,cAAc/b,kBAAkB0b,mBAAlB,EAApB;AACA,QAAI8D,eAAe9b,OAAOzZ,MAAP,CAAnB;AACA,QAAMk1B,cAAcnf,kBAAkB2a,YAAtC;AACA,QAAI3sB,cAAJ;AACA,QAAIyxB,qBAAJ;AACA,QAAIz0B,UAAJ;AACA,QAAIwwB,UAAJ;;AAEA,SAAKxwB,IAAI,CAAJ,EAAOwwB,IAAI6D,WAAWnzB,MAA3B,EAAmClB,IAAIwwB,CAAvC,EAA0CxwB,GAA1C,EAA+C;AAC3CgD,gBAAQqxB,WAAWr0B,CAAX,EAAcgD,KAAtB;AACAyxB,uBAAe1D,YAAY/tB,KAAZ,EAAmBmG,SAAnB,CAA6BorB,KAA7B,CAAf;AACAC,uBAAeA,aAAapxB,OAAb,CAAqB,IAAIf,MAAJ,CAAW8xB,cAAcnxB,KAAzB,EAAgC,GAAhC,CAArB,EAA2DyxB,YAA3D,CAAf;AACH;;AAED,WAAOD,YAAP;AACH,CAlBD;;AAoBA;;;;;AAKAxf,kBAAkB0f,SAAlB,CAA4B71B,KAA5B,GAAoC,UAAU81B,aAAV,EAAyBnuB,OAAzB,EAAkC;AAClE,QAAMitB,gBAAgBze,kBAAkBye,aAAlB,EAAtB;AACA,QAAM/D,WAAW,KAAKkF,iBAAL,CAAuBD,aAAvB,CAAjB;AACA,QAAME,aAAa7f,kBAAkB4a,uBAArC;AACA,QAAMkF,UAAUtuB,WAAWA,QAAQsuB,OAAnC;AACA,QAAMC,aAAa,EAAnB;AACA,QAAMhsB,OAAO,EAAb;AACA,QAAIisB,oBAAJ;AACA,QAAIC,uBAAJ;AACA,QAAIC,mBAAJ;AACA,QAAI1c,YAAJ;AACA,QAAIxY,UAAJ;AACA,QAAIm1B,cAAJ;AACA,QAAIC,oBAAJ;AACA,QAAI5E,UAAJ;AACA,QAAI7X,SAAS,EAAb;;AAEA,SAAKqc,WAAL,IAAoBvB,aAApB,EAAmC;AAC/B,YAAI,CAAC,GAAG4B,cAAH,CAAkB3rB,IAAlB,CAAuB+pB,aAAvB,EAAsCuB,WAAtC,CAAL,EAAyD;AAAE;AAAW;;AAEtEjsB,aAAK7H,MAAL,GAAc,CAAd;AACA+zB,yBAAiBxB,cAAcuB,WAAd,CAAjB;AACAE,qBAAaD,eAAeptB,MAAf,CAAsBotB,eAAe/zB,MAAf,GAAwB,CAA9C,EAAiD,CAAjD,EAAoD,CAApD,CAAb;;AAEA,aAAKlB,IAAI,CAAJ,EAAOwwB,IAAIyE,eAAe/zB,MAA/B,EAAuClB,IAAIwwB,CAA3C,EAA8CxwB,GAA9C,EAAmD;AAC/Cm1B,oBAAQF,eAAej1B,CAAf,CAAR;AACAwY,kBAAMkX,SAASyF,MAAMp1B,IAAf,CAAN;;AAEA,gBAAIyY,QAAQ3N,SAAZ,EAAuB;AACnB9B,qBAAKjI,IAAL,CAAU,IAAV;AACH,aAFD,MAEO;AACHiI,qBAAKjI,IAAL,CAAU,CAACq0B,KAAD,EAAQ3c,GAAR,CAAV;AACH;AACJ;;AAED4c,sBAAcF,WAAWI,KAAX,CAAiB,IAAjB,EAAuBvsB,IAAvB,CAAd;;AAEA,YAAI,CAACqsB,gBAAgBvqB,SAAhB,IAA6BuqB,gBAAgB,IAA9C,KAAuD,CAACN,OAA5D,EAAqE;AACjE;AACH;;AAEDC,mBAAWF,WAAWG,WAAX,CAAX,IAAsCI,WAAtC;AACH;;AAED,QAAIL,WAAW7zB,MAAX,IAAqB,KAAKq0B,eAAL,CAAqBR,WAAW7zB,MAAhC,CAAzB,EACC;AACGyX,eAAOkN,OAAP,CAAekP,WAAW,CAAX,CAAf,EAA8B,CAA9B,EAAiC,CAAjC;AAAsC,KAF1C,MAGK;AACDpc,eAAOkN,OAAP,eAAkBkP,UAAlB;AACH;;AAED,WAAOpc,MAAP;AACH,CApDD;;AAsDA;;;;;AAKA3D,kBAAkB0f,SAAlB,CAA4BE,iBAA5B,GAAgD,UAAUD,aAAV,EAAyB;AACrE,QAAM11B,SAAS,KAAKA,MAApB;AACA,QAAM8xB,cAAc/b,kBAAkB0b,mBAAlB,EAApB;AACA,QAAMyD,cAAcnf,kBAAkB2a,YAAtC;AACA,QAAM0E,aAAarf,kBAAkBkf,UAAlB,CAA6Bj1B,MAA7B,CAAnB;AACA,QAAMu2B,WAAW,EAAjB;;AAEA,QAAIC,4BAAJ;AACA,QAAIC,eAAJ;AACA,QAAIC,iBAAJ;AACA,QAAIC,mBAAJ;AACA,QAAIC,oBAAJ;;AAEA,QAAIrF,UAAJ;AACA,QAAIxwB,UAAJ;;AAEA61B,kBAAcnd,OAAOzZ,MAAP,CAAd;;AAEA,QAAM62B,WAAWzB,WAAWv0B,GAAX,CAAe;AAAA,eAAO0N,IAAIxK,KAAX;AAAA,KAAf,CAAjB;AACA,QAAM+yB,mBAAmB1B,WAAWnzB,MAApC;AACA,SAAKlB,IAAI+1B,mBAAmB,CAA5B,EAA+B/1B,KAAK,CAApC,EAAuCA,GAAvC,EAA4C;AACxC21B,mBAAWtB,WAAWr0B,CAAX,EAAc2O,KAAzB;;AAEA,YAAIgnB,WAAW,CAAX,KAAiBE,YAAY30B,MAAZ,GAAqB,CAA1C,EAA6C;AACzCu0B,kCAAsBE,QAAtB;AACA;AACH;;AAED,YAAIF,wBAAwB5qB,SAA5B,EAAuC;AACnC4qB,kCAAsBI,YAAY30B,MAAlC;AACH;;AAED00B,qBAAaC,YAAYvD,SAAZ,CAAsBqD,WAAW,CAAjC,EAAoCF,mBAApC,CAAb;AACAI,sBAAcA,YAAYvD,SAAZ,CAAsB,CAAtB,EAAyBqD,WAAW,CAApC,IACVtzB,OAAOotB,MAAP,CAAcmG,UAAd,CADU,GAEVC,YAAYvD,SAAZ,CAAsBmD,mBAAtB,EAA2CI,YAAY30B,MAAvD,CAFJ;;AAIAu0B,8BAAsBE,QAAtB;AACH;;AAED,SAAK31B,IAAI,CAAT,EAAYA,IAAI+1B,gBAAhB,EAAkC/1B,GAAlC,EAAuC;AACnC01B,iBAASrB,WAAWr0B,CAAX,CAAT;AACA61B,sBAAcA,YAAYzyB,OAAZ,CAAoB+wB,cAAcuB,OAAO1yB,KAAzC,EAAgD+tB,YAAY2E,OAAO1yB,KAAnB,EAA0BiuB,OAA1B,EAAhD,CAAd;AACH;;AAED,QAAM+E,gBAAgBrB,cAAc7b,KAAd,CAAoB,IAAIzW,MAAJ,CAAWwzB,WAAX,CAApB,KAAgD,EAAtE;AACAG,kBAAc7H,KAAd;;AAEA,SAAKnuB,IAAI,CAAJ,EAAOwwB,IAAIsF,SAAS50B,MAAzB,EAAiClB,IAAIwwB,CAArC,EAAwCxwB,GAAxC,EAA6C;AACzCw1B,iBAASM,SAAS91B,CAAT,CAAT,IAAwBg2B,cAAch2B,CAAd,CAAxB;AACH;AACD,WAAOw1B,QAAP;AACH,CApDD;;AAsDA;;;;;AAKAxgB,kBAAkB0f,SAAlB,CAA4Bnb,aAA5B,GAA4C,UAAUob,aAAV,EAAyB;AACjE,QAAIpzB,OAAO,IAAX;AACA,QAAI2J,OAAOmP,QAAP,CAAgBsa,aAAhB,CAAJ,EAAoC;AAChCpzB,eAAO,IAAI9C,IAAJ,CAASk2B,aAAT,CAAP;AACH,KAFD,MAEO,IAAI,CAAC,KAAK11B,MAAN,IAAgBR,KAAKI,KAAL,CAAW81B,aAAX,CAApB,EAA+C;AAClDpzB,eAAO,IAAI9C,IAAJ,CAASk2B,aAAT,CAAP;AACH,KAFM,MAGF;AACD,YAAMjF,WAAW,KAAKA,QAAL,GAAgB,KAAK7wB,KAAL,CAAW81B,aAAX,CAAjC;AACA,YAAIjF,SAASxuB,MAAb,EAAqB;AACjB,iBAAKoY,UAAL,sCAAsB7a,IAAtB,mCAA8BixB,QAA9B;AACAnuB,mBAAO,KAAK+X,UAAZ;AACH;AACJ;AACD,WAAO/X,IAAP;AACH,CAfD;;AAiBAyT,kBAAkB0f,SAAlB,CAA4Ba,eAA5B,GAA8C,UAAS3X,GAAT,EAAc;AACxD,WAAOA,QAAQ,CAAR,IAAa,KAAK3e,MAAL,CAAY6Z,KAAZ,CAAkB,MAAlB,EAA0B5X,MAA9C;AACH,CAFD;;AAIA;;;;;;AAMA8T,kBAAkB0f,SAAlB,CAA4Bna,QAA5B,GAAuC,UAAUtb,MAAV,EAAkB01B,aAAlB,EAAiC;AACpE,QAAIrb,mBAAJ;;AAEA,QAAIqb,aAAJ,EAAmB;AACfrb,qBAAa,KAAKA,UAAL,GAAkB,KAAKC,aAAL,CAAmBob,aAAnB,CAA/B;AACH,KAFD,MAEO,IAAI,EAAErb,aAAa,KAAKA,UAApB,CAAJ,EAAqC;AACxCA,qBAAa,KAAKC,aAAL,CAAmBob,aAAnB,CAAb;AACH;;AAED,WAAO3f,kBAAkBuF,QAAlB,CAA2BjB,UAA3B,EAAuCra,MAAvC,CAAP;AACH,CAVD;;;;;;;;;;;;;;ACluBA;AAAA;;;;;;AAMe,yEAACqH,IAAD,EAAU;AACrB,QAAIuQ,MAAM3L,OAAO4L,iBAAjB;AACA,QAAIC,MAAM7L,OAAO8L,iBAAjB;;AAEA1Q,SAAK1F,OAAL,CAAa,UAACgJ,CAAD,EAAO;AAChB,YAAIA,IAAIiN,GAAR,EAAa;AACTA,kBAAMjN,CAAN;AACH;AACD,YAAIA,IAAImN,GAAR,EAAa;AACTA,kBAAMnN,CAAN;AACH;AACJ,KAPD;;AASA,WAAO,CAACiN,GAAD,EAAME,GAAN,CAAP;AACH,CAdD,E;;;;;;;;;;;;;;;;ACNA;AACA,IAAMkf,eAAe,QAArB;AACA,IAAMC,gBAAgBx1B,OAAOg0B,SAAP,CAAiBvD,QAAvC;AACA,IAAMgF,cAAc,iBAApB;AACA,IAAMC,aAAa,gBAAnB;;AAEA,SAASC,cAAT,CAAwB7oB,GAAxB,EAA6B8oB,SAA7B,EAAwC;AACpC,QAAIt2B,IAAIs2B,UAAUp1B,MAAlB;AACA,QAAIq1B,SAAS,CAAC,CAAd;;AAEA,WAAOv2B,CAAP,EAAU;AACN,YAAIwN,QAAQ8oB,UAAUt2B,CAAV,CAAZ,EAA0B;AACtBu2B,qBAASv2B,CAAT;AACA,mBAAOu2B,MAAP;AACH;AACDv2B,aAAK,CAAL;AACH;;AAED,WAAOu2B,MAAP;AACH;;AAED,SAASrL,KAAT,CAAesL,IAAf,EAAqBC,IAArB,EAA2BC,SAA3B,EAAsCC,MAAtC,EAA8CC,MAA9C,EAAsD;AAClD,QAAIhuB,IAAJ,EACIiuB,MADJ,EAEIC,MAFJ,EAGIxuB,GAHJ,EAIIyuB,IAJJ;AAKA;AACA;AACA;;AAEA,QAAI,CAACH,MAAL,EAAa;AACTD,iBAAS,CAACH,IAAD,CAAT;AACAI,iBAAS,CAACH,IAAD,CAAT;AACH,KAHD,MAIK;AACDE,eAAO71B,IAAP,CAAY01B,IAAZ;AACAI,eAAO91B,IAAP,CAAY21B,IAAZ;AACH;;AAED,QAAIA,gBAAgBt1B,KAApB,EAA2B;AACvB,aAAKyH,OAAO,CAAZ,EAAeA,OAAO6tB,KAAKv1B,MAA3B,EAAmC0H,QAAQ,CAA3C,EAA8C;AAC1C,gBAAI;AACAiuB,yBAASL,KAAK5tB,IAAL,CAAT;AACAkuB,yBAASL,KAAK7tB,IAAL,CAAT;AACH,aAHD,CAIA,OAAOsB,CAAP,EAAU;AACN;AACH;;AAED,gBAAI,QAAO4sB,MAAP,yCAAOA,MAAP,OAAkBb,YAAtB,EAAoC;AAChC,oBAAI,EAAES,aAAaI,WAAWjsB,SAA1B,CAAJ,EAA0C;AACtC2rB,yBAAK5tB,IAAL,IAAakuB,MAAb;AACH;AACJ,aAJD,MAKK;AACD,oBAAID,WAAW,IAAX,IAAmB,QAAOA,MAAP,yCAAOA,MAAP,OAAkBZ,YAAzC,EAAuD;AACnDY,6BAASL,KAAK5tB,IAAL,IAAakuB,kBAAkB31B,KAAlB,GAA0B,EAA1B,GAA+B,EAArD;AACH;AACD41B,uBAAOV,eAAeS,MAAf,EAAuBF,MAAvB,CAAP;AACA,oBAAIG,SAAS,CAAC,CAAd,EAAiB;AACbF,6BAASL,KAAK5tB,IAAL,IAAa+tB,OAAOI,IAAP,CAAtB;AACH,iBAFD,MAGK;AACD7L,0BAAM2L,MAAN,EAAcC,MAAd,EAAsBJ,SAAtB,EAAiCC,MAAjC,EAAyCC,MAAzC;AACH;AACJ;AACJ;AACJ,KA5BD,MA6BK;AACD,aAAKhuB,IAAL,IAAa6tB,IAAb,EAAmB;AACf,gBAAI;AACAI,yBAASL,KAAK5tB,IAAL,CAAT;AACAkuB,yBAASL,KAAK7tB,IAAL,CAAT;AACH,aAHD,CAIA,OAAOsB,CAAP,EAAU;AACN;AACH;;AAED,gBAAI4sB,WAAW,IAAX,IAAmB,QAAOA,MAAP,yCAAOA,MAAP,OAAkBb,YAAzC,EAAuD;AACnD;AACA;AACA;AACA;AACA3tB,sBAAM4tB,cAAcxsB,IAAd,CAAmBotB,MAAnB,CAAN;AACA,oBAAIxuB,QAAQ6tB,WAAZ,EAAyB;AACrB,wBAAIU,WAAW,IAAX,IAAmB,QAAOA,MAAP,yCAAOA,MAAP,OAAkBZ,YAAzC,EAAuD;AACnDY,iCAASL,KAAK5tB,IAAL,IAAa,EAAtB;AACH;AACDmuB,2BAAOV,eAAeS,MAAf,EAAuBF,MAAvB,CAAP;AACA,wBAAIG,SAAS,CAAC,CAAd,EAAiB;AACbF,iCAASL,KAAK5tB,IAAL,IAAa+tB,OAAOI,IAAP,CAAtB;AACH,qBAFD,MAGK;AACD7L,8BAAM2L,MAAN,EAAcC,MAAd,EAAsBJ,SAAtB,EAAiCC,MAAjC,EAAyCC,MAAzC;AACH;AACJ,iBAXD,MAYK,IAAItuB,QAAQ8tB,UAAZ,EAAwB;AACzB,wBAAIS,WAAW,IAAX,IAAmB,EAAEA,kBAAkB11B,KAApB,CAAvB,EAAmD;AAC/C01B,iCAASL,KAAK5tB,IAAL,IAAa,EAAtB;AACH;AACDmuB,2BAAOV,eAAeS,MAAf,EAAuBF,MAAvB,CAAP;AACA,wBAAIG,SAAS,CAAC,CAAd,EAAiB;AACbF,iCAASL,KAAK5tB,IAAL,IAAa+tB,OAAOI,IAAP,CAAtB;AACH,qBAFD,MAGK;AACD7L,8BAAM2L,MAAN,EAAcC,MAAd,EAAsBJ,SAAtB,EAAiCC,MAAjC,EAAyCC,MAAzC;AACH;AACJ,iBAXI,MAYA;AACDJ,yBAAK5tB,IAAL,IAAakuB,MAAb;AACH;AACJ,aAjCD,MAkCK;AACD,oBAAIJ,aAAaI,WAAWjsB,SAA5B,EAAuC;AACnC;AACH;AACD2rB,qBAAK5tB,IAAL,IAAakuB,MAAb;AACH;AACJ;AACJ;AACD,WAAON,IAAP;AACH;;AAGD,SAASnW,OAAT,CAAkBmW,IAAlB,EAAwBC,IAAxB,EAA8BC,SAA9B,EAAyC;AACrC;AACA,QAAI,QAAOF,IAAP,yCAAOA,IAAP,OAAgBP,YAAhB,IAAgC,QAAOQ,IAAP,yCAAOA,IAAP,OAAgBR,YAApD,EAAkE;AAC9D,eAAO,IAAP;AACH;;AAED,QAAI,QAAOQ,IAAP,yCAAOA,IAAP,OAAgBR,YAAhB,IAAgCQ,SAAS,IAA7C,EAAmD;AAC/C,eAAOD,IAAP;AACH;;AAED,QAAI,QAAOA,IAAP,yCAAOA,IAAP,OAAgBP,YAApB,EAAkC;AAC9BO,eAAOC,gBAAgBt1B,KAAhB,GAAwB,EAAxB,GAA6B,EAApC;AACH;AACD+pB,UAAMsL,IAAN,EAAYC,IAAZ,EAAkBC,SAAlB;AACA,WAAOF,IAAP;AACH;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5ID;;AAEA;;;;;;AAMO,SAASnvB,OAAT,CAAkBmR,GAAlB,EAAuB;AAC1B,WAAOrX,MAAMkG,OAAN,CAAcmR,GAAd,CAAP;AACH;;AAED;;;;;;AAMO,SAASwe,QAAT,CAAmBxe,GAAnB,EAAwB;AAC3B,WAAOA,QAAQ9X,OAAO8X,GAAP,CAAf;AACH;;AAED;;;;;;AAMO,SAASye,QAAT,CAAmBze,GAAnB,EAAwB;AAC3B,WAAO,OAAOA,GAAP,KAAe,QAAtB;AACH;;AAED;;;;;;AAMO,SAAS8U,UAAT,CAAqB9U,GAArB,EAA0B;AAC7B,WAAO,OAAOA,GAAP,KAAe,UAAtB;AACH;;AAED;;;;;;AAMO,SAAS0e,YAAT,CAAuB5wB,IAAvB,EAA6B;AAChC,wCAAW,IAAIkQ,GAAJ,CAAQlQ,IAAR,CAAX;AACH;;AAEM,IAAMuP,cAAc,SAAdA,WAAc;AAAA,mBAAY,IAAIpX,IAAJ,GAAW+a,OAAX,EAAZ,GAAmCY,KAAK+c,KAAL,CAAW/c,KAAKgd,MAAL,KAAgB,KAA3B,CAAnC;AAAA,CAApB;;AAEP;;;;;;;AAOO,SAAS5O,UAAT,CAAoB6O,IAApB,EAA0BC,IAA1B,EAAgC;AACnC,QAAI,CAACjwB,QAAQgwB,IAAR,CAAD,IAAkB,CAAChwB,QAAQiwB,IAAR,CAAvB,EAAsC;AAClC,eAAOD,SAASC,IAAhB;AACH;;AAED,QAAID,KAAKn2B,MAAL,KAAgBo2B,KAAKp2B,MAAzB,EAAiC;AAC7B,eAAO,KAAP;AACH;;AAED,SAAK,IAAIlB,IAAI,CAAb,EAAgBA,IAAIq3B,KAAKn2B,MAAzB,EAAiClB,GAAjC,EAAsC;AAClC,YAAIq3B,KAAKr3B,CAAL,MAAYs3B,KAAKt3B,CAAL,CAAhB,EAAyB;AACrB,mBAAO,KAAP;AACH;AACJ;;AAED,WAAO,IAAP;AACH;;AAED;;;;;;AAMO,SAASuY,YAAT,CAAsBC,GAAtB,EAA2B;AAC9B,WAAOA,GAAP;AACH;;AAED;;;;;;AAMO,IAAMrR,mBAAmB,SAAnBA,gBAAmB,CAACb,IAAD,EAAU;AACtC,QAAI2wB,SAAS3wB,IAAT,CAAJ,EAAoB;AAChB,eAAOF,iDAAUA,CAACO,OAAlB;AACH,KAFD,MAEO,IAAIU,QAAQf,IAAR,KAAiBe,QAAQf,KAAK,CAAL,CAAR,CAArB,EAAuC;AAC1C,eAAOF,iDAAUA,CAACK,OAAlB;AACH,KAFM,MAEA,IAAIY,QAAQf,IAAR,MAAkBA,KAAKpF,MAAL,KAAgB,CAAhB,IAAqB81B,SAAS1wB,KAAK,CAAL,CAAT,CAAvC,CAAJ,EAA+D;AAClE,eAAOF,iDAAUA,CAACS,SAAlB;AACH;AACD,WAAO,IAAP;AACH,CATM,C;;;;;;;;;;;;AC/FP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACHA;;AAEA;;;;;;;;;IAQM0wB,Y;AACF,4BAAe;AAAA;;AAAA;;AACX,aAAKpyB,KAAL,GAAa,IAAIC,GAAJ,EAAb;AACA,aAAKD,KAAL,CAAWQ,GAAX,CAAe,YAAf,EAA6B0kB,oDAA7B;;AAEA3pB,eAAOga,OAAP,CAAesP,gDAAf,EAAuBppB,OAAvB,CAA+B,UAAC1C,GAAD,EAAS;AACpC,kBAAKiH,KAAL,CAAWQ,GAAX,CAAezH,IAAI,CAAJ,CAAf,EAAuBA,IAAI,CAAJ,CAAvB;AACH,SAFD;AAGH;;AAED;;;;;;;;;;;;;yCAS2B;AACvB,gBAAI,CAAC,UAAOgD,MAAZ,EAAoB;AAChB,uBAAO,KAAKiE,KAAL,CAAWc,GAAX,CAAe,YAAf,CAAP;AACH;;AAED,gBAAIuxB,0DAAJ;;AAEA,gBAAI,OAAOA,OAAP,KAAmB,UAAvB,EAAmC;AAC/B,qBAAKryB,KAAL,CAAWQ,GAAX,CAAe,YAAf,EAA6B6xB,OAA7B;AACH,aAFD,MAEO;AACHA,0BAAU9e,OAAO8e,OAAP,CAAV;AACA,oBAAI92B,OAAOmI,IAAP,CAAYmhB,gDAAZ,EAAoBzf,OAApB,CAA4BitB,OAA5B,MAAyC,CAAC,CAA9C,EAAiD;AAC7C,yBAAKryB,KAAL,CAAWQ,GAAX,CAAe,YAAf,EAA6BqkB,gDAAMA,CAACwN,OAAP,CAA7B;AACH,iBAFD,MAEO;AACH,0BAAM,IAAIxwB,KAAJ,cAAqBwwB,OAArB,4BAAN;AACH;AACJ;AACD,mBAAO,IAAP;AACH;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iCAgCUz3B,I,EAAMy3B,O,EAAS;AAAA;;AACrB,gBAAI,OAAOA,OAAP,KAAmB,UAAvB,EAAmC;AAC/B,sBAAM,IAAIxwB,KAAJ,CAAU,8BAAV,CAAN;AACH;;AAEDjH,mBAAO2Y,OAAO3Y,IAAP,CAAP;AACA,iBAAKoF,KAAL,CAAWQ,GAAX,CAAe5F,IAAf,EAAqBy3B,OAArB;;AAEA,mBAAO,YAAM;AAAE,uBAAKC,YAAL,CAAkB13B,IAAlB;AAA0B,aAAzC;AACH;;;qCAEaA,I,EAAM;AAChB,gBAAI,KAAKoF,KAAL,CAAWa,GAAX,CAAejG,IAAf,CAAJ,EAA0B;AACtB,qBAAKoF,KAAL,CAAWY,MAAX,CAAkBhG,IAAlB;AACH;AACJ;;;gCAEQA,I,EAAM;AACX,gBAAIA,gBAAgBF,QAApB,EAA8B;AAC1B,uBAAOE,IAAP;AACH;AACD,mBAAO,KAAKoF,KAAL,CAAWc,GAAX,CAAelG,IAAf,CAAP;AACH;;;;;;AAGL,IAAMkM,eAAgB,YAAY;AAC9B,QAAI9G,QAAQ,IAAZ;;AAEA,aAASgB,QAAT,GAAqB;AACjB,YAAIhB,UAAU,IAAd,EAAoB;AAChBA,oBAAQ,IAAIoyB,YAAJ,EAAR;AACH;AACD,eAAOpyB,KAAP;AACH;AACD,WAAOgB,UAAP;AACH,CAVqB,EAAtB;;AAYe8F,2EAAf,E;;;;;;;;;;;;;;;;;;ACtHA;;AAEA;;;;;;;IAMMwB,K;;AAEJ;;;;;;AAME,mBAAatP,KAAb,EAAoB0c,QAApB,EAA8B1S,KAA9B,EAAqC;AAAA;;AACjC,YAAMyS,iBAAiBuJ,qEAAqBA,CAAChc,KAAtB,EAA6BhK,KAA7B,CAAvB;;AAEAuC,eAAOg3B,gBAAP,CAAwB,IAAxB,EAA8B;AAC1BjT,oBAAQ;AACJkT,4BAAY,KADR;AAEJC,8BAAc,KAFV;AAGJC,0BAAU,KAHN;AAIJ15B;AAJI,aADkB;AAO1B25B,6BAAiB;AACbH,4BAAY,KADC;AAEbC,8BAAc,KAFD;AAGbC,0BAAU,KAHG;AAIb15B,uBAAOyc;AAJM,aAPS;AAa1Bmd,4BAAgB;AACZJ,4BAAY,KADA;AAEZC,8BAAc,KAFF;AAGZC,0BAAU,KAHE;AAIZ15B,uBAAO0c;AAJK;AAbU,SAA9B;;AAqBA,aAAK1S,KAAL,GAAaA,KAAb;AACH;;AAEH;;;;;;;;;;;AAuBA;;;;;;;mCAOc;AACR,mBAAOuQ,OAAO,KAAKva,KAAZ,CAAP;AACH;;AAEH;;;;;;;;;kCAMa;AACP,mBAAO,KAAKA,KAAZ;AACH;;;4BArCY;AACT,mBAAO,KAAKsmB,MAAZ;AACH;;AAED;;;;;;4BAGsB;AAClB,mBAAO,KAAKqT,eAAZ;AACH;;AAED;;;;;;4BAGqB;AACjB,mBAAO,KAAKC,cAAZ;AACH;;;;;;AAwBUtqB,oEAAf,E","file":"datamodel.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"DataModel\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"DataModel\"] = factory();\n\telse\n\t\troot[\"DataModel\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","export default function autoType(object) {\n  for (var key in object) {\n    var value = object[key].trim(), number;\n    if (!value) value = null;\n    else if (value === \"true\") value = true;\n    else if (value === \"false\") value = false;\n    else if (value === \"NaN\") value = NaN;\n    else if (!isNaN(number = +value)) value = number;\n    else if (/^([-+]\\d{2})?\\d{4}(-\\d{2}(-\\d{2})?)?(T\\d{2}:\\d{2}(:\\d{2}(\\.\\d{3})?)?(Z|[-+]\\d{2}:\\d{2})?)?$/.test(value)) value = new Date(value);\n    else continue;\n    object[key] = value;\n  }\n  return object;\n}\n","import dsv from \"./dsv\";\n\nvar csv = dsv(\",\");\n\nexport var csvParse = csv.parse;\nexport var csvParseRows = csv.parseRows;\nexport var csvFormat = csv.format;\nexport var csvFormatBody = csv.formatBody;\nexport var csvFormatRows = csv.formatRows;\n","var EOL = {},\n    EOF = {},\n    QUOTE = 34,\n    NEWLINE = 10,\n    RETURN = 13;\n\nfunction objectConverter(columns) {\n  return new Function(\"d\", \"return {\" + columns.map(function(name, i) {\n    return JSON.stringify(name) + \": d[\" + i + \"]\";\n  }).join(\",\") + \"}\");\n}\n\nfunction customConverter(columns, f) {\n  var object = objectConverter(columns);\n  return function(row, i) {\n    return f(object(row), i, columns);\n  };\n}\n\n// Compute unique columns in order of discovery.\nfunction inferColumns(rows) {\n  var columnSet = Object.create(null),\n      columns = [];\n\n  rows.forEach(function(row) {\n    for (var column in row) {\n      if (!(column in columnSet)) {\n        columns.push(columnSet[column] = column);\n      }\n    }\n  });\n\n  return columns;\n}\n\nfunction pad(value, width) {\n  var s = value + \"\", length = s.length;\n  return length < width ? new Array(width - length + 1).join(0) + s : s;\n}\n\nfunction formatYear(year) {\n  return year < 0 ? \"-\" + pad(-year, 6)\n    : year > 9999 ? \"+\" + pad(year, 6)\n    : pad(year, 4);\n}\n\nfunction formatDate(date) {\n  var hours = date.getUTCHours(),\n      minutes = date.getUTCMinutes(),\n      seconds = date.getUTCSeconds(),\n      milliseconds = date.getUTCMilliseconds();\n  return isNaN(date) ? \"Invalid Date\"\n      : formatYear(date.getUTCFullYear(), 4) + \"-\" + pad(date.getUTCMonth() + 1, 2) + \"-\" + pad(date.getUTCDate(), 2)\n      + (milliseconds ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \":\" + pad(seconds, 2) + \".\" + pad(milliseconds, 3) + \"Z\"\n      : seconds ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \":\" + pad(seconds, 2) + \"Z\"\n      : minutes || hours ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \"Z\"\n      : \"\");\n}\n\nexport default function(delimiter) {\n  var reFormat = new RegExp(\"[\\\"\" + delimiter + \"\\n\\r]\"),\n      DELIMITER = delimiter.charCodeAt(0);\n\n  function parse(text, f) {\n    var convert, columns, rows = parseRows(text, function(row, i) {\n      if (convert) return convert(row, i - 1);\n      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);\n    });\n    rows.columns = columns || [];\n    return rows;\n  }\n\n  function parseRows(text, f) {\n    var rows = [], // output rows\n        N = text.length,\n        I = 0, // current character index\n        n = 0, // current line number\n        t, // current token\n        eof = N <= 0, // current token followed by EOF?\n        eol = false; // current token followed by EOL?\n\n    // Strip the trailing newline.\n    if (text.charCodeAt(N - 1) === NEWLINE) --N;\n    if (text.charCodeAt(N - 1) === RETURN) --N;\n\n    function token() {\n      if (eof) return EOF;\n      if (eol) return eol = false, EOL;\n\n      // Unescape quotes.\n      var i, j = I, c;\n      if (text.charCodeAt(j) === QUOTE) {\n        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);\n        if ((i = I) >= N) eof = true;\n        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;\n        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }\n        return text.slice(j + 1, i - 1).replace(/\"\"/g, \"\\\"\");\n      }\n\n      // Find next delimiter or newline.\n      while (I < N) {\n        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;\n        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }\n        else if (c !== DELIMITER) continue;\n        return text.slice(j, i);\n      }\n\n      // Return last token before EOF.\n      return eof = true, text.slice(j, N);\n    }\n\n    while ((t = token()) !== EOF) {\n      var row = [];\n      while (t !== EOL && t !== EOF) row.push(t), t = token();\n      if (f && (row = f(row, n++)) == null) continue;\n      rows.push(row);\n    }\n\n    return rows;\n  }\n\n  function preformatBody(rows, columns) {\n    return rows.map(function(row) {\n      return columns.map(function(column) {\n        return formatValue(row[column]);\n      }).join(delimiter);\n    });\n  }\n\n  function format(rows, columns) {\n    if (columns == null) columns = inferColumns(rows);\n    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join(\"\\n\");\n  }\n\n  function formatBody(rows, columns) {\n    if (columns == null) columns = inferColumns(rows);\n    return preformatBody(rows, columns).join(\"\\n\");\n  }\n\n  function formatRows(rows) {\n    return rows.map(formatRow).join(\"\\n\");\n  }\n\n  function formatRow(row) {\n    return row.map(formatValue).join(delimiter);\n  }\n\n  function formatValue(value) {\n    return value == null ? \"\"\n        : value instanceof Date ? formatDate(value)\n        : reFormat.test(value += \"\") ? \"\\\"\" + value.replace(/\"/g, \"\\\"\\\"\") + \"\\\"\"\n        : value;\n  }\n\n  return {\n    parse: parse,\n    parseRows: parseRows,\n    format: format,\n    formatBody: formatBody,\n    formatRows: formatRows\n  };\n}\n","export {default as dsvFormat} from \"./dsv\";\nexport {csvParse, csvParseRows, csvFormat, csvFormatBody, csvFormatRows} from \"./csv\";\nexport {tsvParse, tsvParseRows, tsvFormat, tsvFormatBody, tsvFormatRows} from \"./tsv\";\nexport {default as autoType} from \"./autoType\";\n","import dsv from \"./dsv\";\n\nvar tsv = dsv(\"\\t\");\n\nexport var tsvParse = tsv.parse;\nexport var tsvParseRows = tsv.parseRows;\nexport var tsvFormat = tsv.format;\nexport var tsvFormatBody = tsv.formatBody;\nexport var tsvFormatRows = tsv.formatRows;\n","export { DataFormat, FilteringMode } from '../enums';\n/**\n * The event name for data propagation.\n */\nexport const PROPAGATION = 'propagation';\n\n/**\n * The name of the unique row id column in DataModel.\n */\nexport const ROW_ID = '__id__';\n\n/**\n * The enums for operation names performed on DataModel.\n */\nexport const DM_DERIVATIVES = {\n    SELECT: 'select',\n    PROJECT: 'project',\n    GROUPBY: 'group',\n    COMPOSE: 'compose',\n    CAL_VAR: 'calculatedVariable',\n    BIN: 'bin',\n    SORT: 'sort'\n};\n\nexport const JOINS = {\n    CROSS: 'cross',\n    LEFTOUTER: 'leftOuter',\n    RIGHTOUTER: 'rightOuter',\n    NATURAL: 'natural',\n    FULLOUTER: 'fullOuter'\n};\n\nexport const LOGICAL_OPERATORS = {\n    AND: 'and',\n    OR: 'or'\n};\n","import DataConverter from './model/dataConverter';\nimport { DSVStringConverter, DSVArrayConverter, JSONConverter, AutoDataConverter } from './defaultConverters';\n\nclass DataConverterStore {\n    constructor() {\n        this.store = new Map();\n        this.converters(this._getDefaultConverters());\n    }\n\n    _getDefaultConverters() {\n        return [\n            new DSVStringConverter(),\n            new DSVArrayConverter(),\n            new JSONConverter(),\n            new AutoDataConverter()\n        ];\n    }\n\n    /**\n     * Sets the given converters in the store and returns the store\n     * @param  {Array<DataConverter>} converters : contains array of converter instance\n     * @return { Map<String,DataConverter> }\n     */\n    converters(converters = []) {\n        converters.forEach(converter => this.store.set(converter.type, converter));\n        return this.store;\n    }\n\n    /**\n     * Registers a Converter of type DataConverter\n     * @param {DataConverter} converter : converter Instance\n     * @returns self\n     */\n    register(converter) {\n        if (converter instanceof DataConverter) {\n            this.store.set(converter.type, converter);\n            return this;\n        }\n        return null;\n    }\n\n    /**\n     * Rempves a converter from store\n     * @param {DataConverter} converter : converter Instance\n     * @returns self\n     */\n\n    unregister(converter) {\n        this.store.delete(converter.type);\n        return this;\n    }\n\n    get(name) {\n        if (this.store.has(name)) {\n            return this.store.get(name);\n        }\n        return null;\n    }\n\n}\n\nconst converterStore = (function () {\n    let store = null;\n\n    function getStore () {\n        store = new DataConverterStore();\n        return store;\n    }\n    return store || getStore();\n}());\n\nexport default converterStore;\n","import DataConverter from '../model/dataConverter';\nimport AUTO from '../utils/auto-resolver';\nimport DataFormat from '../../enums/data-format';\n\nexport default class AutoDataConverter extends DataConverter {\n    constructor() {\n        super(DataFormat.AUTO);\n    }\n\n    convert(data, schema, options) {\n        return AUTO(data, schema, options);\n    }\n}\n","import DataConverter from '../model/dataConverter';\nimport DSVArr from '../utils/dsv-arr';\nimport DataFormat from '../../enums/data-format';\n\nexport default class DSVArrayConverter extends DataConverter {\n    constructor() {\n        super(DataFormat.DSV_ARR);\n    }\n\n    convert(data, schema, options) {\n        return DSVArr(data, schema, options);\n    }\n}\n","import DataConverter from '../model/dataConverter';\nimport DSVStr from '../utils/dsv-str';\nimport DataFormat from '../../enums/data-format';\n\nexport default class DSVStringConverter extends DataConverter {\n    constructor() {\n        super(DataFormat.DSV_STR);\n    }\n\n    convert(data, schema, options) {\n        return DSVStr(data, schema, options);\n    }\n}\n","export { default as DSVStringConverter } from './dsvStringConverter';\nexport { default as JSONConverter } from './jsonConverter';\nexport { default as DSVArrayConverter } from './dsvArrayConverter';\nexport { default as AutoDataConverter } from './autoConverter';\n","import DataConverter from '../model/dataConverter';\nimport FlatJSON from '../utils/flat-json';\nimport DataFormat from '../../enums/data-format';\n\nexport default class JSONConverter extends DataConverter {\n    constructor() {\n        super(DataFormat.FLAT_JSON);\n    }\n\n    convert(data, schema, options) {\n        return FlatJSON(data, schema, options);\n    }\n}\n","import converterStore from './dataConverterStore';\nimport DataConverter from './model/dataConverter';\n\nexport { DataConverter, converterStore };\n","/**\n * Interface for all data converters\n */\nexport default class DataConverter {\n    constructor(type) {\n        this._type = type;\n    }\n\n    get type() {\n        return this._type;\n    }\n\n    convert() {\n        throw new Error('Convert method not implemented.');\n    }\n\n}\n","import FlatJSON from './flat-json';\nimport DSVArr from './dsv-arr';\nimport DSVStr from './dsv-str';\nimport { detectDataFormat } from '../../utils';\n\n/**\n * Parses the input data and detect the format automatically.\n *\n * @param {string|Array} data - The input data.\n * @param {Object} options - An optional config specific to data format.\n * @return {Array.<Object>} Returns an array of headers and column major data.\n */\nfunction Auto (data, schema, options) {\n    const converters = { FlatJSON, DSVStr, DSVArr };\n    const dataFormat = detectDataFormat(data);\n\n    if (!dataFormat) {\n        throw new Error('Couldn\\'t detect the data format');\n    }\n\n    return converters[dataFormat](data, schema, options);\n}\n\nexport default Auto;\n","import { columnMajor } from '../../utils';\n\n/**\n * Parses and converts data formatted in DSV array to a manageable internal format.\n *\n * @param {Array.<Array>} arr - A 2D array containing of the DSV data.\n * @param {Object} options - Option to control the behaviour of the parsing.\n * @param {boolean} [options.firstRowHeader=true] - Whether the first row of the dsv data is header or not.\n * @return {Array} Returns an array of headers and column major data.\n * @example\n *\n * // Sample input data:\n * const data = [\n *    [\"a\", \"b\", \"c\"],\n *    [1, 2, 3],\n *    [4, 5, 6],\n *    [7, 8, 9]\n * ];\n */\nfunction DSVArr(arr, schema, options) {\n    if (!Array.isArray(schema)) {\n        throw new Error('Schema missing or is in an unsupported format');\n    }\n    const defaultOption = {\n        firstRowHeader: true,\n    };\n    const schemaFields = schema.map(unitSchema => unitSchema.name);\n    options = Object.assign({}, defaultOption, options);\n\n    const columns = [];\n    const push = columnMajor(columns);\n\n    let headers = schemaFields;\n    if (options.firstRowHeader) {\n        // If header present then remove the first header row.\n        // Do in-place mutation to save space.\n        headers = arr.splice(0, 1)[0];\n    }\n    // create a map of the headers\n    const headerMap = headers.reduce((acc, h, i) => (\n        Object.assign(acc, { [h]: i })\n    ), {});\n\n    arr.forEach((fields) => {\n        const field = [];\n        schemaFields.forEach((schemaField) => {\n            const headIndex = headerMap[schemaField];\n            field.push(fields[headIndex]);\n        });\n        return push(...field);\n    });\n    return [schemaFields, columns];\n}\n\nexport default DSVArr;\n","import { dsvFormat as d3Dsv } from 'd3-dsv';\nimport DSVArr from './dsv-arr';\n\n/**\n * Parses and converts data formatted in DSV string to a manageable internal format.\n *\n * @todo Support to be given for https://tools.ietf.org/html/rfc4180.\n * @todo Sample implementation https://github.com/knrz/CSV.js/.\n *\n * @param {string} str - The input DSV string.\n * @param {Object} options - Option to control the behaviour of the parsing.\n * @param {boolean} [options.firstRowHeader=true] - Whether the first row of the dsv string data is header or not.\n * @param {string} [options.fieldSeparator=\",\"] - The separator of two consecutive field.\n * @return {Array} Returns an array of headers and column major data.\n * @example\n *\n * // Sample input data:\n * const data = `\n * a,b,c\n * 1,2,3\n * 4,5,6\n * 7,8,9\n * `\n */\nfunction DSVStr (str, schema, options) {\n    const defaultOption = {\n        firstRowHeader: true,\n        fieldSeparator: ','\n    };\n    options = Object.assign({}, defaultOption, options);\n\n    const dsv = d3Dsv(options.fieldSeparator);\n    return DSVArr(dsv.parseRows(str), schema, options);\n}\n\nexport default DSVStr;\n","import { columnMajor } from '../../utils';\n\n/**\n * Parses and converts data formatted in JSON to a manageable internal format.\n *\n * @param {Array.<Object>} arr - The input data formatted in JSON.\n * @return {Array.<Object>} Returns an array of headers and column major data.\n * @example\n *\n * // Sample input data:\n * const data = [\n *    {\n *      \"a\": 1,\n *      \"b\": 2,\n *      \"c\": 3\n *    },\n *    {\n *      \"a\": 4,\n *      \"b\": 5,\n *      \"c\": 6\n *    },\n *    {\n *      \"a\": 7,\n *      \"b\": 8,\n *      \"c\": 9\n *    }\n * ];\n */\nfunction FlatJSON (arr, schema) {\n    if (!Array.isArray(schema)) {\n        throw new Error('Schema missing or is in an unsupported format');\n    }\n\n    const header = {};\n    let i = 0;\n    let insertionIndex;\n    const columns = [];\n    const push = columnMajor(columns);\n    const schemaFieldsName = schema.map(unitSchema => unitSchema.name);\n\n    arr.forEach((item) => {\n        const fields = [];\n        schemaFieldsName.forEach((unitSchema) => {\n            if (unitSchema in header) {\n                insertionIndex = header[unitSchema];\n            } else {\n                header[unitSchema] = i++;\n                insertionIndex = i - 1;\n            }\n            fields[insertionIndex] = item[unitSchema];\n        });\n        push(...fields);\n    });\n\n    return [Object.keys(header), columns];\n}\n\nexport default FlatJSON;\n","/* eslint-disable default-case */\n\nimport { FieldType, DimensionSubtype, DataFormat, FilteringMode } from './enums';\nimport {\n    persistDerivations,\n    getRootGroupByModel,\n    propagateToAllDataModels,\n    getRootDataModel,\n    propagateImmutableActions,\n    addToPropNamespace,\n    sanitizeUnitSchema,\n    splitWithSelect,\n    splitWithProject,\n    getNormalizedProFields\n} from './helper';\nimport { DM_DERIVATIVES, PROPAGATION } from './constants';\nimport {\n    dataBuilder,\n    rowDiffsetIterator,\n    groupBy\n} from './operator';\nimport { createBinnedFieldData } from './operator/bucket-creator';\nimport Relation from './relation';\nimport reducerStore from './utils/reducer-store';\nimport { createFields } from './field-creator';\nimport InvalidAwareTypes from './invalid-aware-types';\nimport Value from './value';\nimport { converterStore } from './converter';\nimport { fieldRegistry } from './fields';\n\n/**\n * DataModel is an in-browser representation of tabular data. It supports\n * {@link https://en.wikipedia.org/wiki/Relational_algebra | relational algebra} operators as well as generic data\n * processing opearators.\n * DataModel extends {@link Relation} class which defines all the relational algebra opreators. DataModel gives\n * definition of generic data processing operators which are not relational algebra complient.\n *\n * @public\n * @class\n * @extends Relation\n * @memberof Datamodel\n */\nclass DataModel extends Relation {\n    /**\n     * Creates a new DataModel instance by providing data and schema. Data could be in the form of\n     * - Flat JSON\n     * - DSV String\n     * - 2D Array\n     *\n     * By default DataModel finds suitable adapter to serialize the data. DataModel also expects a\n     * {@link Schema | schema} for identifying the variables present in data.\n     *\n     * @constructor\n     * @example\n     * const data = loadData('cars.csv');\n     * const schema = [\n     *      { name: 'Name', type: 'dimension' },\n     *      { name: 'Miles_per_Gallon', type: 'measure', unit : 'cm', scale: '1000', numberformat: val => `${val}G`},\n     *      { name: 'Cylinders', type: 'dimension' },\n     *      { name: 'Displacement', type: 'measure' },\n     *      { name: 'Horsepower', type: 'measure' },\n     *      { name: 'Weight_in_lbs', type: 'measure' },\n     *      { name: 'Acceleration', type: 'measure' },\n     *      { name: 'Year', type: 'dimension', subtype: 'datetime', format: '%Y' },\n     *      { name: 'Origin', type: 'dimension' }\n     * ];\n     * const dm = new DataModel(data, schema, { name: 'Cars' });\n     * table(dm);\n     *\n     * @public\n     *\n     * @param {Array.<Object> | string | Array.<Array>} data Input data in any of the mentioned formats\n     * @param {Array.<Schema>} schema Defination of the variables. Order of the variables in data and order of the\n     *      variables in schema has to be same.\n     * @param {object} [options] Optional arguments to specify more settings regarding the creation part\n     * @param {string} [options.name] Name of the datamodel instance. If no name is given an auto generated name is\n     *      assigned to the instance.\n     * @param {string} [options.fieldSeparator=','] specify field separator type if the data is of type dsv string.\n     */\n    constructor (...args) {\n        super(...args);\n\n        this._onPropagation = [];\n    }\n\n    /**\n     * Reducers are simple functions which reduces an array of numbers to a representative number of the set.\n     * Like an array of numbers `[10, 20, 5, 15]` can be reduced to `12.5` if average / mean reducer function is\n     * applied. All the measure fields in datamodel (variables in data) needs a reducer to handle aggregation.\n     *\n     * @public\n     *\n     * @return {ReducerStore} Singleton instance of {@link ReducerStore}.\n     */\n    static get Reducers () {\n        return reducerStore;\n    }\n\n    /**\n     * Converters are functions that transforms data in various format tpo datamodel consumabe format.\n     */\n    static get Converters() {\n        return converterStore;\n    }\n\n    /**\n     * Register new type of fields\n     */\n    static get FieldTypes() {\n        return fieldRegistry;\n    }\n\n    /**\n     * Configure null, undefined, invalid values in the source data\n     *\n     * @public\n     *\n     * @param {Object} [config] - Configuration to control how null, undefined and non-parsable values are\n     * represented in DataModel.\n     * @param {string} [config.undefined] - Define how an undefined value will be represented.\n     * @param {string} [config.null] - Define how a null value will be represented.\n     * @param {string} [config.invalid] - Define how a non-parsable value will be represented.\n     */\n    static configureInvalidAwareTypes (config) {\n        return InvalidAwareTypes.invalidAwareVals(config);\n    }\n\n    /**\n     * Retrieve the data attached to an instance in JSON format.\n     *\n     * @example\n     * // DataModel instance is already prepared and assigned to dm variable\n     *  const data = dm.getData({\n     *      order: 'column',\n     *      formatter: {\n     *          origin: (val) => val === 'European Union' ? 'EU' : val;\n     *      }\n     *  });\n     *  console.log(data);\n     *\n     * @public\n     *\n     * @param {Object} [options] Options to control how the raw data is to be returned.\n     * @param {string} [options.order='row'] Defines if data is retieved in row order or column order. Possible values\n     *      are `'rows'` and `'columns'`\n     * @param {Function} [options.formatter=null] Formats the output data. This expects an object, where the keys are\n     *      the name of the variable needs to be formatted. The formatter function is called for each row passing the\n     *      value of the cell for a particular row as arguments. The formatter is a function in the form of\n     *      `function (value, rowId, schema) => { ... }`\n     *      Know more about {@link Fomatter}.\n     *\n     * @return {Array} Returns a multidimensional array of the data with schema. The return format looks like\n     *      ```\n     *          {\n     *              data,\n     *              schema\n     *          }\n     *      ```\n     */\n    getData (options) {\n        const defOptions = {\n            order: 'row',\n            formatter: null,\n            withUid: false,\n            getAllFields: false,\n            sort: []\n        };\n        options = Object.assign({}, defOptions, options);\n        const fields = this.getPartialFieldspace().fields;\n\n        const dataGenerated = dataBuilder.call(\n            this,\n            this.getPartialFieldspace().fields,\n            this._rowDiffset,\n            options.getAllFields ? fields.map(d => d.name()).join() : this._colIdentifier,\n            options.sort,\n            {\n                columnWise: options.order === 'column',\n                addUid: !!options.withUid\n            }\n        );\n\n        if (!options.formatter) {\n            return dataGenerated;\n        }\n\n        const { formatter } = options;\n        const { data, schema, uids } = dataGenerated;\n        const fieldNames = schema.map((e => e.name));\n        const fmtFieldNames = Object.keys(formatter);\n        const fmtFieldIdx = fmtFieldNames.reduce((acc, next) => {\n            const idx = fieldNames.indexOf(next);\n            if (idx !== -1) {\n                acc.push([idx, formatter[next]]);\n            }\n            return acc;\n        }, []);\n\n        if (options.order === 'column') {\n            fmtFieldIdx.forEach((elem) => {\n                const fIdx = elem[0];\n                const fmtFn = elem[1];\n\n                data[fIdx].forEach((datum, datumIdx) => {\n                    data[fIdx][datumIdx] = fmtFn.call(\n                        undefined,\n                        datum,\n                        uids[datumIdx],\n                        schema[fIdx]\n                    );\n                });\n            });\n        } else {\n            data.forEach((datum, datumIdx) => {\n                fmtFieldIdx.forEach((elem) => {\n                    const fIdx = elem[0];\n                    const fmtFn = elem[1];\n\n                    datum[fIdx] = fmtFn.call(\n                        undefined,\n                        datum[fIdx],\n                        uids[datumIdx],\n                        schema[fIdx]\n                    );\n                });\n            });\n        }\n\n        return dataGenerated;\n    }\n\n    /**\n     * Returns the unique ids in an array.\n     *\n     * @return {Array} Returns an array of ids.\n     */\n    getUids () {\n        const rowDiffset = this._rowDiffset;\n        const ids = [];\n\n        if (rowDiffset.length) {\n            const diffSets = rowDiffset.split(',');\n\n            diffSets.forEach((set) => {\n                let [start, end] = set.split('-').map(Number);\n\n                end = end !== undefined ? end : start;\n                ids.push(...Array(end - start + 1).fill().map((_, idx) => start + idx));\n            });\n        }\n\n        return ids;\n    }\n    /**\n     * Groups the data using particular dimensions and by reducing measures. It expects a list of dimensions using which\n     * it projects the datamodel and perform aggregations to reduce the duplicate tuples. Refer this\n     * {@link link_to_one_example_with_group_by | document} to know the intuition behind groupBy.\n     *\n     * DataModel by default provides definition of few {@link reducer | Reducers}.\n     * {@link ReducerStore | User defined reducers} can also be registered.\n     *\n     * This is the chained implementation of `groupBy`.\n     * `groupBy` also supports {@link link_to_compose_groupBy | composability}\n     *\n     * @example\n     * const groupedDM = dm.groupBy(['Year'], { horsepower: 'max' } );\n     * console.log(groupedDm);\n     *\n     * @public\n     *\n     * @param {Array.<string>} fieldsArr - Array containing the name of dimensions\n     * @param {Object} [reducers={}] - A map whose key is the variable name and value is the name of the reducer. If its\n     *      not passed, or any variable is ommitted from the object, default aggregation function is used from the\n     *      schema of the variable.\n     *\n     * @return {DataModel} Returns a new DataModel instance after performing the groupby.\n     */\n    groupBy (fieldsArr, reducers = {}, config = { saveChild: true }) {\n        const groupByString = `${fieldsArr.join()}`;\n        let params = [this, fieldsArr, reducers];\n        const newDataModel = groupBy(...params);\n\n        persistDerivations(\n            this,\n            newDataModel,\n            DM_DERIVATIVES.GROUPBY,\n            { fieldsArr, groupByString, defaultReducer: reducerStore.defaultReducer() },\n            reducers\n        );\n\n        if (config.saveChild) {\n            newDataModel.setParent(this);\n        } else {\n            newDataModel.setParent(null);\n        }\n\n        return newDataModel;\n    }\n\n    /**\n     * Performs sorting operation on the current {@link DataModel} instance according to the specified sorting details.\n     * Like every other operator it doesn't mutate the current DataModel instance on which it was called, instead\n     * returns a new DataModel instance containing the sorted data.\n     *\n     * DataModel support multi level sorting by listing the variables using which sorting needs to be performed and\n     * the type of sorting `ASC` or `DESC`.\n     *\n     * In the following example, data is sorted by `Origin` field in `DESC` order in first level followed by another\n     * level of sorting by `Acceleration` in `ASC` order.\n     *\n     * @example\n     * // here dm is the pre-declared DataModel instance containing the data of 'cars.json' file\n     * let sortedDm = dm.sort([\n     *    [\"Origin\", \"DESC\"]\n     *    [\"Acceleration\"] // Default value is ASC\n     * ]);\n     *\n     * console.log(dm.getData());\n     * console.log(sortedDm.getData());\n     *\n     * // Sort with a custom sorting function\n     * sortedDm = dm.sort([\n     *    [\"Origin\", \"DESC\"]\n     *    [\"Acceleration\", (a, b) => a - b] // Custom sorting function\n     * ]);\n     *\n     * console.log(dm.getData());\n     * console.log(sortedDm.getData());\n     *\n     * @text\n     * DataModel also provides another sorting mechanism out of the box where sort is applied to a variable using\n     * another variable which determines the order.\n     * Like the above DataModel contains three fields `Origin`, `Name` and `Acceleration`. Now, the data in this\n     * model can be sorted by `Origin` field according to the average value of all `Acceleration` for a\n     * particular `Origin` value.\n     *\n     * @example\n     * // here dm is the pre-declared DataModel instance containing the data of 'cars.json' file\n     * const sortedDm = dm.sort([\n     *     ['Origin', ['Acceleration', (a, b) => avg(...a.Acceleration) - avg(...b.Acceleration)]]\n     * ]);\n     *\n     * console.log(dm.getData());\n     * console.log(sortedDm.getData());\n     *\n     * @public\n     *\n     * @param {Array.<Array>} sortingDetails - Sorting details based on which the sorting will be performed.\n     * @return {DataModel} Returns a new instance of DataModel with sorted data.\n     */\n    sort (sortingDetails, config = { saveChild: false }) {\n        const rawData = this.getData({\n            order: 'row',\n            sort: sortingDetails\n        });\n        const header = rawData.schema.map(field => field.name);\n        const dataInCSVArr = [header].concat(rawData.data);\n\n        const sortedDm = new this.constructor(dataInCSVArr, rawData.schema, { dataFormat: 'DSVArr' });\n\n        persistDerivations(\n            this,\n            sortedDm,\n            DM_DERIVATIVES.SORT,\n            config,\n            sortingDetails\n        );\n\n        if (config.saveChild) {\n            sortedDm.setParent(this);\n        } else {\n            sortedDm.setParent(null);\n        }\n\n        return sortedDm;\n    }\n\n    /**\n     * Performs the serialization operation on the current {@link DataModel} instance according to the specified data\n     * type. When an {@link DataModel} instance is created, it de-serializes the input data into its internal format,\n     * and during its serialization process, it converts its internal data format to the specified data type and returns\n     * that data regardless what type of data is used during the {@link DataModel} initialization.\n     *\n     * @example\n     * // here dm is the pre-declared DataModel instance.\n     * const csvData = dm.serialize(DataModel.DataFormat.DSV_STR, { fieldSeparator: \",\" });\n     * console.log(csvData); // The csv formatted data.\n     *\n     * const jsonData = dm.serialize(DataModel.DataFormat.FLAT_JSON);\n     * console.log(jsonData); // The json data.\n     *\n     * @public\n     *\n     * @param {string} type - The data type name for serialization.\n     * @param {Object} options - The optional option object.\n     * @param {string} options.fieldSeparator - The field separator character for DSV data type.\n     * @return {Array|string} Returns the serialized data.\n     */\n    serialize (type, options) {\n        type = type || this._dataFormat;\n        options = Object.assign({}, { fieldSeparator: ',' }, options);\n\n        const fields = this.getFieldspace().fields;\n        const colData = fields.map(f => f.formattedData());\n        const rowsCount = colData[0].length;\n        let serializedData;\n        let rowIdx;\n        let colIdx;\n\n        if (type === DataFormat.FLAT_JSON) {\n            serializedData = [];\n            for (rowIdx = 0; rowIdx < rowsCount; rowIdx++) {\n                const row = {};\n                for (colIdx = 0; colIdx < fields.length; colIdx++) {\n                    row[fields[colIdx].name()] = colData[colIdx][rowIdx];\n                }\n                serializedData.push(row);\n            }\n        } else if (type === DataFormat.DSV_STR) {\n            serializedData = [fields.map(f => f.name()).join(options.fieldSeparator)];\n            for (rowIdx = 0; rowIdx < rowsCount; rowIdx++) {\n                const row = [];\n                for (colIdx = 0; colIdx < fields.length; colIdx++) {\n                    row.push(colData[colIdx][rowIdx]);\n                }\n                serializedData.push(row.join(options.fieldSeparator));\n            }\n            serializedData = serializedData.join('\\n');\n        } else if (type === DataFormat.DSV_ARR) {\n            serializedData = [fields.map(f => f.name())];\n            for (rowIdx = 0; rowIdx < rowsCount; rowIdx++) {\n                const row = [];\n                for (colIdx = 0; colIdx < fields.length; colIdx++) {\n                    row.push(colData[colIdx][rowIdx]);\n                }\n                serializedData.push(row);\n            }\n        } else {\n            throw new Error(`Data type ${type} is not supported`);\n        }\n\n        return serializedData;\n    }\n\n    addField (field) {\n        const fieldName = field.name();\n        this._colIdentifier += `,${fieldName}`;\n        const partialFieldspace = this._partialFieldspace;\n        const cachedValueObjects = partialFieldspace._cachedValueObjects;\n        const formattedData = field.formattedData();\n        const rawData = field.partialField.data;\n\n        if (!partialFieldspace.fieldsObj()[field.name()]) {\n            partialFieldspace.fields.push(field);\n            cachedValueObjects.forEach((obj, i) => {\n                obj[field.name()] = new Value(formattedData[i], rawData[i], field);\n            });\n        } else {\n            const fieldIndex = partialFieldspace.fields.findIndex(fieldinst => fieldinst.name() === fieldName);\n            fieldIndex >= 0 && (partialFieldspace.fields[fieldIndex] = field);\n        }\n\n        // flush out cached namespace values on addition of new fields\n        partialFieldspace._cachedFieldsObj = null;\n        partialFieldspace._cachedDimension = null;\n        partialFieldspace._cachedMeasure = null;\n\n        this.__calculateFieldspace().calculateFieldsConfig();\n        return this;\n    }\n\n    /**\n    * Creates a new variable calculated from existing variables. This method expects the definition of the newly created\n    * variable and a function which resolves the value of the new variable from existing variables.\n    *\n    * Can create a new measure based on existing variables:\n    * @example\n    *  // DataModel already prepared and assigned to dm variable;\n    *  const newDm = dataModel.calculateVariable({\n    *      name: 'powerToWeight',\n    *      type: 'measure'\n    *  }, ['horsepower', 'weight_in_lbs', (hp, weight) => hp / weight ]);\n    *\n    *\n    * Can create a new dimension based on existing variables:\n    * @example\n    *  // DataModel already prepared and assigned to dm variable;\n    *  const child = dataModel.calculateVariable(\n    *     {\n    *       name: 'Efficiency',\n    *       type: 'dimension'\n    *     }, ['horsepower', (hp) => {\n    *      if (hp < 80) { return 'low'; },\n    *      else if (hp < 120) { return 'moderate'; }\n    *      else { return 'high' }\n    *  }]);\n    *\n    * @public\n    *\n    * @param {Object} schema - The schema of newly defined variable.\n    * @param {Array.<string|function>} dependency - An array containing the dependency variable names and a resolver\n    * function as the last element.\n    * @param {Object} config - An optional config object.\n    * @param {boolean} [config.saveChild] - Whether the newly created DataModel will be a child.\n    * @param {boolean} [config.replaceVar] - Whether the newly created variable will replace the existing variable.\n    * @return {DataModel} Returns an instance of DataModel with the new field.\n    */\n    calculateVariable (schema, dependency, config) {\n        schema = sanitizeUnitSchema(schema);\n        config = Object.assign({}, { saveChild: true, replaceVar: false }, config);\n\n        const fieldsConfig = this.getFieldsConfig();\n        const depVars = dependency.slice(0, dependency.length - 1);\n        const retrieveFn = dependency[dependency.length - 1];\n\n        if (fieldsConfig[schema.name] && !config.replaceVar) {\n            throw new Error(`${schema.name} field already exists in datamodel`);\n        }\n\n        const depFieldIndices = depVars.map((field) => {\n            const fieldSpec = fieldsConfig[field];\n            if (!fieldSpec) {\n                // @todo dont throw error here, use warning in production mode\n                throw new Error(`${field} is not a valid column name.`);\n            }\n            return fieldSpec.index;\n        });\n\n        const clone = this.clone(config.saveChild);\n\n        const fs = clone.getFieldspace().fields;\n        const suppliedFields = depFieldIndices.map(idx => fs[idx]);\n\n        let cachedStore = {};\n        let cloneProvider = () => this.detachedRoot();\n\n        const computedValues = [];\n        rowDiffsetIterator(clone._rowDiffset, (i) => {\n            const fieldsData = suppliedFields.map(field => field.partialField.data[i]);\n            computedValues[i] = retrieveFn(...fieldsData, i, cloneProvider, cachedStore);\n        });\n        const [field] = createFields([computedValues], [schema], [schema.name]);\n        clone.addField(field);\n\n        persistDerivations(\n            this,\n            clone,\n            DM_DERIVATIVES.CAL_VAR,\n            { config: schema, fields: depVars },\n            retrieveFn\n        );\n\n        return clone;\n    }\n\n    /**\n     * Propagates changes across all the connected DataModel instances.\n     *\n     * @param {Array} identifiers - A list of identifiers that were interacted with.\n     * @param {Object} payload - The interaction specific details.\n     *\n     * @return {DataModel} DataModel instance.\n     */\n    propagate (identifiers, config = {}, addToNameSpace, propConfig = {}) {\n        const isMutableAction = config.isMutableAction;\n        const propagationSourceId = config.sourceId;\n        const payload = config.payload;\n        const rootModel = getRootDataModel(this);\n        const propagationNameSpace = rootModel._propagationNameSpace;\n        const rootGroupByModel = getRootGroupByModel(this);\n        const rootModels = {\n            groupByModel: rootGroupByModel,\n            model: rootModel\n        };\n\n        addToNameSpace && addToPropNamespace(propagationNameSpace, config, this);\n        propagateToAllDataModels(identifiers, rootModels, { propagationNameSpace, sourceId: propagationSourceId },\n            Object.assign({\n                payload\n            }, config));\n\n        if (isMutableAction) {\n            propagateImmutableActions(propagationNameSpace, rootModels, {\n                config,\n                propConfig\n            }, this);\n        }\n\n        return this;\n    }\n\n    /**\n     * Associates a callback with an event name.\n     *\n     * @param {string} eventName - The name of the event.\n     * @param {Function} callback - The callback to invoke.\n     * @return {DataModel} Returns this current DataModel instance itself.\n     */\n    on (eventName, callback) {\n        switch (eventName) {\n        case PROPAGATION:\n            this._onPropagation.push(callback);\n            break;\n        }\n        return this;\n    }\n\n    /**\n     * Unsubscribes the callbacks for the provided event name.\n     *\n     * @param {string} eventName - The name of the event to unsubscribe.\n     * @return {DataModel} Returns the current DataModel instance itself.\n     */\n    unsubscribe (eventName) {\n        switch (eventName) {\n        case PROPAGATION:\n            this._onPropagation = [];\n            break;\n\n        }\n        return this;\n    }\n\n    /**\n     * This method is used to invoke the method associated with propagation.\n     *\n     * @param {Object} payload The interaction payload.\n     * @param {DataModel} identifiers The propagated DataModel.\n     * @memberof DataModel\n     */\n    handlePropagation (propModel, payload) {\n        let propListeners = this._onPropagation;\n        propListeners.forEach(fn => fn.call(this, propModel, payload));\n    }\n\n    /**\n     * Performs the binning operation on a measure field based on the binning configuration. Binning means discretizing\n     * values of a measure. Binning configuration contains an array; subsequent values from the array marks the boundary\n     * of buckets in [inclusive, exclusive) range format. This operation does not mutate the subject measure field,\n     * instead, it creates a new field (variable) of type dimension and subtype binned.\n     *\n     * Binning can be configured by\n     * - providing custom bin configuration with non-uniform buckets,\n     * - providing bins count,\n     * - providing each bin size,\n     *\n     * When custom `buckets` are provided as part of binning configuration:\n     * @example\n     *  // DataModel already prepared and assigned to dm variable\n     *  const config = { name: 'binnedHP', buckets: [30, 80, 100, 110] }\n     *  const binnedDM = dataModel.bin('horsepower', config);\n     *\n     * @text\n     * When `binsCount` is defined as part of binning configuration:\n     * @example\n     *  // DataModel already prepared and assigned to dm variable\n     *  const config = { name: 'binnedHP', binsCount: 5, start: 0, end: 100 }\n     *  const binDM = dataModel.bin('horsepower', config);\n     *\n     * @text\n     * When `binSize` is defined as part of binning configuration:\n     * @example\n     *  // DataModel already prepared and assigned to dm variable\n     *  const config = { name: 'binnedHorsepower', binSize: 20, start: 5}\n     *  const binDM = dataModel.bin('horsepower', config);\n     *\n     * @public\n     *\n     * @param {string} measureFieldName - The name of the target measure field.\n     * @param {Object} config - The config object.\n     * @param {string} [config.name] - The name of the new field which will be created.\n     * @param {string} [config.buckets] - An array containing the bucket ranges.\n     * @param {string} [config.binSize] - The size of each bin. It is ignored when buckets are given.\n     * @param {string} [config.binsCount] - The total number of bins to generate. It is ignored when buckets are given.\n     * @param {string} [config.start] - The start value of the bucket ranges. It is ignored when buckets are given.\n     * @param {string} [config.end] - The end value of the bucket ranges. It is ignored when buckets are given.\n     * @return {DataModel} Returns a new {@link DataModel} instance with the new field.\n     */\n    bin (measureFieldName, config) {\n        const fieldsConfig = this.getFieldsConfig();\n\n        if (!fieldsConfig[measureFieldName]) {\n            throw new Error(`Field ${measureFieldName} doesn't exist`);\n        }\n\n        const binFieldName = config.name || `${measureFieldName}_binned`;\n\n        if (fieldsConfig[binFieldName]) {\n            throw new Error(`Field ${binFieldName} already exists`);\n        }\n\n        const measureField = this.getFieldspace().fieldsObj()[measureFieldName];\n        const { binnedData, bins } = createBinnedFieldData(measureField, this._rowDiffset, config);\n\n        const binField = createFields([binnedData], [\n            {\n                name: binFieldName,\n                type: FieldType.DIMENSION,\n                subtype: DimensionSubtype.BINNED,\n                bins\n            }], [binFieldName])[0];\n\n        const clone = this.clone(config.saveChild);\n        clone.addField(binField);\n\n        persistDerivations(\n            this,\n            clone,\n            DM_DERIVATIVES.BIN,\n             { measureFieldName, config, binFieldName },\n             null\n        );\n\n        return clone;\n    }\n\n    /**\n     * Creates a new {@link DataModel} instance with completely detached root from current {@link DataModel} instance,\n     * the new {@link DataModel} instance has no parent-children relationship with the current one, but has same data as\n     * the current one.\n     * This API is useful when a completely different {@link DataModel} but with same data as the current instance is\n     * needed.\n     *\n     * @example\n     *  const dm = new DataModel(data, schema);\n     *  const detachedDm = dm.detachedRoot();\n     *\n     * // has different namespace\n     * console.log(dm.getPartialFieldspace().name);\n     * console.log(detachedDm.getPartialFieldspace().name);\n     *\n     * // has same data\n     * console.log(dm.getData());\n     * console.log(detachedDm.getData());\n     *\n     * @public\n     *\n     * @return {DataModel} Returns a detached {@link DataModel} instance.\n     */\n    detachedRoot () {\n        const data = this.serialize(DataFormat.FLAT_JSON);\n        const schema = this.getSchema();\n\n        return new DataModel(data, schema);\n    }\n\n    /**\n     * Creates a set of new {@link DataModel} instances by splitting the set of rows in the source {@link DataModel}\n     * instance based on a set of dimensions.\n     *\n     * For each unique dimensional value, a new split is created which creates a unique {@link DataModel} instance for\n     *  that split\n     *\n     * If multiple dimensions are provided, it splits the source {@link DataModel} instance with all possible\n     * combinations of the dimensional values for all the dimensions provided\n     *\n     * Additionally, it also accepts a predicate function to reduce the set of rows provided. A\n     * {@link link_to_selection | Selection} is performed on all the split {@link DataModel} instances based on\n     * the predicate function\n     *\n     * @example\n     *  // without predicate function:\n     *  const splitDt = dt.splitByRow(['Origin'])\n     *  console.log(splitDt));\n     * // This should give three unique DataModel instances, one each having rows only for 'USA',\n     * // 'Europe' and 'Japan' respectively\n     *\n     * @example\n     *  // without predicate function:\n     *  const splitDtMulti = dt.splitByRow(['Origin', 'Cylinders'])\n     *  console.log(splitDtMulti));\n     * // This should give DataModel instances for all unique combinations of Origin and Cylinder values\n     *\n     * @example\n     * // with predicate function:\n     * const splitWithPredDt = dt.select(['Origin'], fields => fields.Origin.value === \"USA\")\n     * console.log(splitWithPredDt);\n     * // This should not include the DataModel for the Origin : 'USA'\n     *\n     *\n     * @public\n     *\n     * @param {Array} dimensionArr - Set of dimensions based on which the split should occur\n     * @param {Object} config - The configuration object\n     * @param {string} [config.saveChild] - Configuration to save child or not\n     * @param {string}[config.mode=FilteringMode.NORMAL] -The mode of the selection.\n     * @return {Array}  Returns the new DataModel instances after operation.\n     */\n    splitByRow (dimensionArr, reducerFn, config) {\n        const fieldsConfig = this.getFieldsConfig();\n\n        dimensionArr.forEach((fieldName) => {\n            if (!fieldsConfig[fieldName]) {\n                throw new Error(`Field ${fieldName} doesn't exist in the schema`);\n            }\n        });\n\n        const defConfig = {\n            mode: FilteringMode.NORMAL,\n            saveChild: true\n        };\n\n        config = Object.assign({}, defConfig, config);\n\n        return splitWithSelect(this, dimensionArr, reducerFn, config);\n    }\n\n    /**\n     * Creates a set of new {@link DataModel} instances by splitting the set of fields in the source {@link DataModel}\n     * instance based on a set of common and unique field names provided.\n     *\n     * Each DataModel created contains a set of fields which are common to all and a set of unique fields.\n     * It also accepts configurations such as saveChild and mode(inverse or normal) to include/exclude the respective\n     * fields\n     *\n     * @example\n     *  // without predicate function:\n     *  const splitDt = dt.splitByColumn( [['Acceleration'], ['Horsepower']], ['Origin'])\n     *  console.log(splitDt));\n     * // This should give two unique DataModel instances, both having the field 'Origin' and\n     * // one each having 'Acceleration' and 'Horsepower' fields respectively\n     *\n     * @example\n     *  // without predicate function:\n     *  const splitDtInv = dt.splitByColumn( [['Acceleration'], ['Horsepower'],['Origin', 'Cylinders'],\n     *                           {mode: 'inverse'})\n     *  console.log(splitDtInv));\n     * // This should give DataModel instances in the following way:\n     * // All DataModel Instances do not have the fields 'Origin' and 'Cylinders'\n     * // One DataModel Instance has rest of the fields except 'Acceleration' and the other DataModel instance\n     * // has rest of the fields except 'Horsepower'\n     *\n     *\n     *\n     * @public\n     *\n     * @param {Array} uniqueFields - Set of unique fields included in each datamModel instance\n     * @param {Array} commonFields - Set of common fields included in all datamModel instances\n     * @param {Object} config - The configuration object\n     * @param {string} [config.saveChild] - Configuration to save child or not\n     * @param {string}[config.mode=FilteringMode.NORMAL] -The mode of the selection.\n     * @return {Array}  Returns the new DataModel instances after operation.\n     */\n    splitByColumn (uniqueFields = [], commonFields = [], config) {\n        const defConfig = {\n            mode: FilteringMode.NORMAL,\n            saveChild: true\n        };\n        const fieldConfig = this.getFieldsConfig();\n        const allFields = Object.keys(fieldConfig);\n        const normalizedProjFieldSets = [[commonFields]];\n\n        config = Object.assign({}, defConfig, config);\n        uniqueFields = uniqueFields.length ? uniqueFields : [[]];\n\n\n        uniqueFields.forEach((fieldSet, i) => {\n            normalizedProjFieldSets[i] = getNormalizedProFields(\n                [...fieldSet, ...commonFields],\n                allFields,\n                fieldConfig);\n        });\n\n        return splitWithProject(this, normalizedProjFieldSets, config, allFields);\n    }\n\n\n}\n\nexport default DataModel;\n","import { DataFormat } from './enums';\n\nexport default {\n    dataFormat: DataFormat.AUTO\n};\n","/**\n * DataFormat Enum defines the format of the input data.\n * Based on the format of the data the respective adapter is loaded.\n *\n * @readonly\n * @enum {string}\n */\nconst DataFormat = {\n    FLAT_JSON: 'FlatJSON',\n    DSV_STR: 'DSVStr',\n    DSV_ARR: 'DSVArr',\n    AUTO: 'Auto'\n};\n\nexport default DataFormat;\n","/**\n * DimensionSubtype enum defines the sub types of the Dimensional Field.\n *\n * @readonly\n * @enum {string}\n */\nconst DimensionSubtype = {\n    CATEGORICAL: 'categorical',\n    TEMPORAL: 'temporal',\n    BINNED: 'binned'\n};\n\nexport default DimensionSubtype;\n","/**\n * FieldType enum defines the high level field based on which visuals are controlled.\n * Measure in a high level is numeric field and Dimension in a high level is string field.\n *\n * @readonly\n * @enum {string}\n */\nconst FieldType = {\n    MEASURE: 'measure',\n    DIMENSION: 'dimension'\n};\n\nexport default FieldType;\n","/**\n * Filtering mode enum defines the filering modes of DataModel.\n *\n * @readonly\n * @enum {string}\n */\nconst FilteringMode = {\n    NORMAL: 'normal',\n    INVERSE: 'inverse',\n    ALL: 'all'\n};\n\nexport default FilteringMode;\n","/**\n * Group by function names\n *\n * @readonly\n * @enum {string}\n */\nconst GROUP_BY_FUNCTIONS = {\n    SUM: 'sum',\n    AVG: 'avg',\n    MIN: 'min',\n    MAX: 'max',\n    FIRST: 'first',\n    LAST: 'last',\n    COUNT: 'count',\n    STD: 'std'\n};\n\nexport default GROUP_BY_FUNCTIONS;\n","/**\n * FilteringMode determines if resultant DataModel should be created from selection set or rejection set.\n *\n * The following modes are available\n * - `NORMAL`: Only entries from selection set are included in the resulatant DataModel instance\n * - `INVERSE`: Only entries from rejection set are included in the resulatant DataModel instance\n * - ALL: Both the entries from selection and rejection set are returned in two different DataModel instance\n */\n\nexport { default as DataFormat } from './data-format';\nexport { default as DimensionSubtype } from './dimension-subtype';\nexport { default as MeasureSubtype } from './measure-subtype';\nexport { default as FieldType } from './field-type';\nexport { default as FilteringMode } from './filtering-mode';\nexport { default as GROUP_BY_FUNCTIONS } from './group-by-functions';\n","/**\n * MeasureSubtype enum defines the sub types of the Measure Field.\n *\n * @readonly\n * @enum {string}\n */\nconst MeasureSubtype = {\n    CONTINUOUS: 'continuous'\n};\n\nexport default MeasureSubtype;\n","import DataModel from './datamodel';\nimport {\n  compose,\n  bin,\n  select,\n  project,\n  groupby as groupBy,\n  calculateVariable,\n  sort,\n  crossProduct,\n  difference,\n  naturalJoin,\n  leftOuterJoin,\n  rightOuterJoin,\n  fullOuterJoin,\n  union,\n  rowDiffsetIterator\n} from './operator';\nimport * as Stats from './stats';\nimport * as enums from './enums';\nimport { DataConverter } from './converter';\nimport { DateTimeFormatter } from './utils';\nimport { DataFormat, FilteringMode, DM_DERIVATIVES } from './constants';\nimport InvalidAwareTypes from './invalid-aware-types';\nimport pkg from '../package.json';\nimport * as FieldsUtility from './fields';\n\nconst Operators = {\n    compose,\n    bin,\n    select,\n    project,\n    groupBy,\n    calculateVariable,\n    sort,\n    crossProduct,\n    difference,\n    naturalJoin,\n    leftOuterJoin,\n    rightOuterJoin,\n    fullOuterJoin,\n    union,\n    rowDiffsetIterator\n};\n\nconst version = pkg.version;\nObject.assign(DataModel, {\n    Operators,\n    Stats,\n    DM_DERIVATIVES,\n    DateTimeFormatter,\n    DataFormat,\n    FilteringMode,\n    InvalidAwareTypes,\n    version,\n    DataConverter,\n    FieldsUtility\n}, enums);\n\nexport default DataModel;\n","import { FieldType, DimensionSubtype, MeasureSubtype } from './enums';\nimport { fieldRegistry } from './fields';\n\n/**\n * Creates a field instance according to the provided data and schema.\n *\n * @param {Array} data - The field data array.\n * @param {Object} schema - The field schema object.\n * @return {Field} Returns the newly created field instance.\n */\nfunction createUnitField(data, schema) {\n    data = data || [];\n\n    if (fieldRegistry.has(schema.subtype)) {\n        return fieldRegistry.get(schema.subtype)\n                        .BUILDER\n                        .fieldName(schema.name)\n                        .schema(schema)\n                        .data(data)\n                        .rowDiffset(`0-${data.length - 1}`)\n                        .build();\n    }\n    return fieldRegistry\n                    .get(schema.type === FieldType.MEASURE ? MeasureSubtype.CONTINUOUS : DimensionSubtype.CATEGORICAL)\n                    .BUILDER\n                    .fieldName(schema.name)\n                    .schema(schema)\n                    .data(data)\n                    .rowDiffset(`0-${data.length - 1}`)\n                    .build();\n}\n\n\n/**\n * Creates a field instance from partialField and rowDiffset.\n *\n * @param {PartialField} partialField - The corresponding partial field.\n * @param {string} rowDiffset - The data subset config.\n * @return {Field} Returns the newly created field instance.\n */\nexport function createUnitFieldFromPartial(partialField, rowDiffset) {\n    const { schema } = partialField;\n\n    if (fieldRegistry.has(schema.subtype)) {\n        return fieldRegistry.get(schema.subtype)\n                        .BUILDER\n                        .partialField(partialField)\n                        .rowDiffset(rowDiffset)\n                        .build();\n    }\n    return fieldRegistry\n                    .get(schema.type === FieldType.MEASURE ? MeasureSubtype.CONTINUOUS : DimensionSubtype.CATEGORICAL)\n                    .BUILDER\n                    .partialField(partialField)\n                    .rowDiffset(rowDiffset)\n                    .build();\n}\n\n/**\n * Creates the field instances with input data and schema.\n *\n * @param {Array} dataColumn - The data array for fields.\n * @param {Array} schema - The schema array for fields.\n * @param {Array} headers - The array of header names.\n * @return {Array.<Field>} Returns an array of newly created field instances.\n */\nexport function createFields(dataColumn, schema, headers) {\n    const headersObj = {};\n\n    if (!(headers && headers.length)) {\n        headers = schema.map(item => item.name);\n    }\n\n    headers.forEach((header, i) => {\n        headersObj[header] = i;\n    });\n\n    return schema.map(item => createUnitField(dataColumn[headersObj[item.name]], item));\n}\n","import { FieldType } from './enums';\nimport { getUniqueId } from './utils';\n\nconst fieldStore = {\n    data: {},\n\n    createNamespace (fieldArr, name) {\n        const dataId = name || getUniqueId();\n\n        this.data[dataId] = {\n            name: dataId,\n            fields: fieldArr,\n\n            fieldsObj () {\n                let fieldsObj = this._cachedFieldsObj;\n\n                if (!fieldsObj) {\n                    fieldsObj = this._cachedFieldsObj = {};\n                    this.fields.forEach((field) => {\n                        fieldsObj[field.name()] = field;\n                    });\n                }\n                return fieldsObj;\n            },\n            getMeasure () {\n                let measureFields = this._cachedMeasure;\n\n                if (!measureFields) {\n                    measureFields = this._cachedMeasure = {};\n                    this.fields.forEach((field) => {\n                        if (field.schema().type === FieldType.MEASURE) {\n                            measureFields[field.name()] = field;\n                        }\n                    });\n                }\n                return measureFields;\n            },\n            getDimension () {\n                let dimensionFields = this._cachedDimension;\n\n                if (!this._cachedDimension) {\n                    dimensionFields = this._cachedDimension = {};\n                    this.fields.forEach((field) => {\n                        if (field.schema().type === FieldType.DIMENSION) {\n                            dimensionFields[field.name()] = field;\n                        }\n                    });\n                }\n                return dimensionFields;\n            },\n        };\n        return this.data[dataId];\n    },\n};\n\nexport default fieldStore;\n","import Dimension from '../dimension';\nimport BinnedParser from '../parsers/binned-parser';\n\n/**\n * Represents binned field subtype.\n *\n * @public\n * @class\n * @extends Dimension\n */\nexport default class Binned extends Dimension {\n    /**\n     * Calculates the corresponding field domain.\n     *\n     * @public\n     * @override\n     * @return {Array} Returns the last and first values of bins config array.\n     */\n    calculateDataDomain () {\n        const binsArr = this.partialField.schema.bins;\n        return [binsArr[0], binsArr[binsArr.length - 1]];\n    }\n\n    /**\n     * Returns the bins config provided while creating the field instance.\n     *\n     * @public\n     * @return {Array} Returns the bins array config.\n     */\n    bins () {\n        return this.partialField.schema.bins;\n    }\n\n    static parser() {\n        return new BinnedParser();\n    }\n}\n","import { rowDiffsetIterator } from '../../operator/row-diffset-iterator';\nimport { DimensionSubtype } from '../../enums';\nimport Dimension from '../dimension';\nimport CategoricalParser from '../parsers/categorical-parser';\n/**\n * Represents categorical field subtype.\n *\n * @public\n * @class\n * @extends Dimension\n */\nexport default class Categorical extends Dimension {\n    /**\n     * Returns the subtype of the field.\n     *\n     * @public\n     * @override\n     * @return {string} Returns the subtype of the field.\n     */\n    subtype () {\n        return DimensionSubtype.CATEGORICAL;\n    }\n\n    /**\n     * Calculates the corresponding field domain.\n     *\n     * @public\n     * @override\n     * @return {Array} Returns the unique values.\n     */\n    calculateDataDomain () {\n        const hash = new Set();\n        const domain = [];\n\n        // here don't use this.data() as the iteration will be occurred two times on same data.\n        rowDiffsetIterator(this.rowDiffset, (i) => {\n            const datum = this.partialField.data[i];\n            if (!hash.has(datum)) {\n                hash.add(datum);\n                domain.push(datum);\n            }\n        });\n        return domain;\n    }\n\n    static parser() {\n        return new CategoricalParser();\n    }\n}\n","import { rowDiffsetIterator } from '../../operator/row-diffset-iterator';\nimport { MeasureSubtype } from '../../enums';\nimport Measure from '../measure';\nimport InvalidAwareTypes from '../../invalid-aware-types';\nimport ContinuousParser from '../parsers/continuous-parser';\n\n/**\n * Represents continuous field subtype.\n *\n * @public\n * @class\n * @extends Measure\n */\nexport default class Continuous extends Measure {\n    /**\n     * Returns the subtype of the field.\n     *\n     * @public\n     * @override\n     * @return {string} Returns the subtype of the field.\n     */\n    subtype () {\n        return MeasureSubtype.CONTINUOUS;\n    }\n\n    /**\n     * Calculates the corresponding field domain.\n     *\n     * @public\n     * @override\n     * @return {Array} Returns the min and max values.\n     */\n    calculateDataDomain () {\n        let min = Number.POSITIVE_INFINITY;\n        let max = Number.NEGATIVE_INFINITY;\n\n        // here don't use this.data() as the iteration will be occurred two times on same data.\n        rowDiffsetIterator(this.rowDiffset, (i) => {\n            const datum = this.partialField.data[i];\n            if (datum instanceof InvalidAwareTypes) {\n                return;\n            }\n\n            if (datum < min) {\n                min = datum;\n            }\n            if (datum > max) {\n                max = datum;\n            }\n        });\n\n        return [min, max];\n    }\n\n    static parser() {\n        return new ContinuousParser();\n    }\n}\n","import Field from '../field';\n\n/**\n * Represents dimension field type.\n *\n * @public\n * @class\n * @extends Field\n */\nexport default class Dimension extends Field {\n    /**\n     * Returns the domain for the dimension field.\n     *\n     * @override\n     * @public\n     * @return {any} Returns the calculated domain.\n     */\n    domain () {\n        if (!this._cachedDomain) {\n            this._cachedDomain = this.calculateDataDomain();\n        }\n        return this._cachedDomain;\n    }\n\n    /**\n     * Calculates the corresponding field domain.\n     *\n     * @public\n     * @abstract\n     */\n    calculateDataDomain () {\n        throw new Error('Not yet implemented');\n    }\n\n     /**\n     * Returns the formatted version of the underlying field data.\n     *\n     * @public\n     * @override\n     * @return {Array} Returns the formatted data.\n     */\n    formattedData () {\n        return this.data();\n    }\n}\n","import Categorical from './categorical';\nimport Temporal from './temporal';\nimport Binned from './binned';\nimport Continuous from './continuous';\nimport { DimensionSubtype, MeasureSubtype } from '../enums';\n\n\nclass FieldTypeRegistry {\n    constructor() {\n        this._fieldType = new Map();\n    }\n\n    registerFieldType(subtype, dimension) {\n        this._fieldType.set(subtype, dimension);\n        return this;\n    }\n\n    has(type) {\n        return this._fieldType.has(type);\n    }\n\n    get(type) {\n        return this._fieldType.get(type);\n    }\n}\n\nconst registerDefaultFields = (store) => {\n    store\n                    .registerFieldType(DimensionSubtype.CATEGORICAL, Categorical)\n                    .registerFieldType(DimensionSubtype.TEMPORAL, Temporal)\n                    .registerFieldType(DimensionSubtype.BINNED, Binned)\n                    .registerFieldType(MeasureSubtype.CONTINUOUS, Continuous);\n};\n\nconst fieldRegistry = (function () {\n    let store = null;\n    function getStore () {\n        store = new FieldTypeRegistry();\n        registerDefaultFields(store);\n        return store;\n    }\n    return store || getStore();\n}());\n\nexport default fieldRegistry;\n\n","import { rowDiffsetIterator } from '../../operator/row-diffset-iterator';\nimport PartialField from '../partial-field';\n\n/**\n * In {@link DataModel}, every tabular data consists of column, a column is stored as field.\n * Field contains all the data for a given column in an array.\n *\n * Each record consists of several fields; the fields of all records form the columns.\n * Examples of fields: name, gender, sex etc.\n *\n * In DataModel, each field can have multiple attributes which describes its data and behaviour.\n * A field can have two types of data: Measure and Dimension.\n *\n * A Dimension Field is the context on which a data is categorized and the measure is the numerical values that\n * quantify the data set.\n * In short a dimension is the lens through which you are looking at your measure data.\n *\n * Refer to {@link Schema} to get info about possible field attributes.\n *\n * @public\n * @class\n */\nexport default class Field {\n    /**\n     * Initialize a new instance.\n     *\n     * @public\n     * @param {PartialField} partialField - The partialField instance which holds the whole data.\n     * @param {string} rowDiffset - The data subset definition.\n     */\n    constructor (partialField, rowDiffset) {\n        this.partialField = partialField;\n        this.rowDiffset = rowDiffset;\n    }\n\n    static parser() {\n        throw new Error('Not yet implemented');\n    }\n\n    /**\n     * Generates the field type specific domain.\n     *\n     * @public\n     * @abstract\n     */\n    domain () {\n        throw new Error('Not yet implemented');\n    }\n\n    /**\n     * Returns the the field schema.\n     *\n     * @public\n     * @return {string} Returns the field schema.\n     */\n    schema () {\n        return this.partialField.schema;\n    }\n\n    /**\n     * Returns the name of the field.\n     *\n     * @public\n     * @return {string} Returns the name of the field.\n     */\n    name () {\n        return this.partialField.name;\n    }\n\n    /**\n     * Returns the type of the field.\n     *\n     * @public\n     * @return {string} Returns the type of the field.\n     */\n    type () {\n        return this.partialField.schema.type;\n    }\n\n    /**\n     * Returns the subtype of the field.\n     *\n     * @public\n     * @return {string} Returns the subtype of the field.\n     */\n    subtype () {\n        return this.partialField.schema.subtype;\n    }\n\n    /**\n     * Returns the description of the field.\n     *\n     * @public\n     * @return {string} Returns the description of the field.\n     */\n    description () {\n        return this.partialField.schema.description;\n    }\n\n    /**\n     * Returns the display name of the field.\n     *\n     * @public\n     * @return {string} Returns the display name of the field.\n     */\n    displayName () {\n        return this.partialField.schema.displayName || this.partialField.schema.name;\n    }\n\n    /**\n     * Returns the data associated with the field.\n     *\n     * @public\n     * @return {Array} Returns the data.\n     */\n    data () {\n        const data = [];\n        rowDiffsetIterator(this.rowDiffset, (i) => {\n            data.push(this.partialField.data[i]);\n        });\n        return data;\n    }\n\n    /**\n     * Returns the formatted version of the underlying field data.\n     *\n     * @public\n     * @abstract\n     */\n    formattedData () {\n        throw new Error('Not yet implemented');\n    }\n\n    static get BUILDER() {\n        const builder = {\n            _params: {},\n            _context: this,\n            fieldName(name) {\n                this._params.name = name;\n                return this;\n            },\n            schema(schema) {\n                this._params.schema = schema;\n                return this;\n            },\n            data(data) {\n                this._params.data = data;\n                return this;\n            },\n            partialField(partialField) {\n                this._params.partialField = partialField;\n                return this;\n            },\n            rowDiffset(rowDiffset) {\n                this._params.rowDiffset = rowDiffset;\n                return this;\n            },\n            build() {\n                let partialField = null;\n                if (this._params.partialField instanceof PartialField) {\n                    partialField = this._params.partialField;\n                } else if (this._params.schema && this._params.data) {\n                    partialField = new PartialField(this._params.name,\n                                        this._params.data,\n                                        this._params.schema,\n                                        this._context.parser());\n                }\n                else {\n                    throw new Error('Invalid Field parameters');\n                }\n                return new this._context(partialField, this._params.rowDiffset);\n            }\n        };\n        return builder;\n    }\n}\n","export { default as Dimension } from './dimension';\nexport { default as Measure } from './measure';\nexport { default as FieldParser } from './parsers/field-parser';\nexport { default as fieldRegistry } from './field-registry';\nexport { columnMajor } from '../utils';\n","import { formatNumber } from '../../utils';\nimport { defaultReducerName } from '../../operator/group-by-function';\nimport Field from '../field';\n\n/**\n * Represents measure field type.\n *\n * @public\n * @class\n * @extends Field\n */\nexport default class Measure extends Field {\n  /**\n   * Returns the domain for the measure field.\n   *\n   * @override\n   * @public\n   * @return {any} Returns the calculated domain.\n   */\n    domain () {\n        if (!this._cachedDomain) {\n            this._cachedDomain = this.calculateDataDomain();\n        }\n        return this._cachedDomain;\n    }\n\n  /**\n   * Returns the unit of the measure field.\n   *\n   * @public\n   * @return {string} Returns unit of the field.\n   */\n    unit () {\n        return this.partialField.schema.unit;\n    }\n\n  /**\n   * Returns the aggregation function name of the measure field.\n   *\n   * @public\n   * @return {string} Returns aggregation function name of the field.\n   */\n    defAggFn () {\n        return this.partialField.schema.defAggFn || defaultReducerName;\n    }\n\n  /**\n   * Returns the number format of the measure field.\n   *\n   * @public\n   * @return {Function} Returns number format of the field.\n   */\n    numberFormat () {\n        const { numberFormat } = this.partialField.schema;\n        return numberFormat instanceof Function ? numberFormat : formatNumber;\n    }\n\n  /**\n   * Calculates the corresponding field domain.\n   *\n   * @public\n   * @abstract\n   */\n    calculateDataDomain () {\n        throw new Error('Not yet implemented');\n    }\n\n    /**\n     * Returns the formatted version of the underlying field data.\n     *\n     * @public\n     * @override\n     * @return {Array} Returns the formatted data.\n     */\n    formattedData () {\n        return this.data();\n    }\n}\n","import FieldParser from '../field-parser';\nimport InvalidAwareTypes from '../../../invalid-aware-types';\n\n/**\n * A FieldParser which parses the binned values.\n *\n * @public\n * @class\n * @implements {FieldParser}\n */\nexport default class BinnedParser extends FieldParser {\n  /**\n   * Parses a single binned value of a field and returns the sanitized value.\n   *\n   * @public\n   * @param {string} val - The value of the field.\n   * @return {string} Returns the sanitized value.\n   */\n    parse (val) {\n        const regex = /^\\s*([+-]?\\d+(?:\\.\\d+)?)\\s*-\\s*([+-]?\\d+(?:\\.\\d+)?)\\s*$/;\n        val = String(val);\n        let result;\n        // check if invalid date value\n        if (!InvalidAwareTypes.isInvalid(val)) {\n            let matched = val.match(regex);\n            result = matched ? `${Number.parseFloat(matched[1])}-${Number.parseFloat(matched[2])}`\n                             : InvalidAwareTypes.NA;\n        } else {\n            result = InvalidAwareTypes.getInvalidType(val);\n        }\n        return result;\n    }\n}\n","import FieldParser from '../field-parser';\nimport InvalidAwareTypes from '../../../invalid-aware-types';\n\n/**\n * A FieldParser which parses the categorical values.\n *\n * @public\n * @class\n * @implements {FieldParser}\n */\nexport default class CategoricalParser extends FieldParser {\n  /**\n   * Parses a single value of a field and returns the stringified form.\n   *\n   * @public\n   * @param {string|number} val - The value of the field.\n   * @return {string} Returns the stringified value.\n   */\n    parse (val) {\n        let result;\n        // check if invalid date value\n        if (!InvalidAwareTypes.isInvalid(val)) {\n            result = String(val).trim();\n        } else {\n            result = InvalidAwareTypes.getInvalidType(val);\n        }\n        return result;\n    }\n}\n","import FieldParser from '../field-parser';\nimport InvalidAwareTypes from '../../../invalid-aware-types';\n\n/**\n * A FieldParser which parses the continuous values.\n *\n * @public\n * @class\n * @implements {FieldParser}\n */\nexport default class ContinuousParser extends FieldParser {\n  /**\n   * Parses a single value of a field and returns the number form.\n   *\n   * @public\n   * @param {string|number} val - The value of the field.\n   * @return {string} Returns the number value.\n   */\n    parse (val) {\n        let result;\n        // check if invalid date value\n        if (!InvalidAwareTypes.isInvalid(val)) {\n            let parsedVal = parseFloat(val, 10);\n            result = Number.isNaN(parsedVal) ? InvalidAwareTypes.NA : parsedVal;\n        } else {\n            result = InvalidAwareTypes.getInvalidType(val);\n        }\n        return result;\n    }\n}\n","/**\n * A interface to represent a parser which is responsible to parse the field.\n *\n * @public\n * @interface\n */\nexport default class FieldParser {\n    /**\n     * Parses a single value of a field and return the sanitized form.\n     *\n     * @public\n     * @abstract\n     */\n    parse () {\n        throw new Error('Not yet implemented');\n    }\n}\n","import { DateTimeFormatter } from '../../../utils';\nimport FieldParser from '../field-parser';\nimport InvalidAwareTypes from '../../../invalid-aware-types';\n\n/**\n * A FieldParser which parses the temporal values.\n *\n * @public\n * @class\n * @implements {FieldParser}\n */\nexport default class TemporalParser extends FieldParser {\n\n    /**\n     * Parses a single value of a field and returns the millisecond value.\n     *\n     * @public\n     * @param {string|number} val - The value of the field.\n     * @return {number} Returns the millisecond value.\n     */\n    parse (val, { format }) {\n        let result;\n        // check if invalid date value\n        if (!this._dtf) {\n            this._dtf = new DateTimeFormatter(format);\n        }\n        if (!InvalidAwareTypes.isInvalid(val)) {\n            let nativeDate = this._dtf.getNativeDate(val);\n            result = nativeDate ? nativeDate.getTime() : InvalidAwareTypes.NA;\n        } else {\n            result = InvalidAwareTypes.getInvalidType(val);\n        }\n        return result;\n    }\n}\n","/**\n * Stores the full data and the metadata of a field. It provides\n * a single source of data from which the future Field\n * instance can get a subset of it with a rowDiffset config.\n *\n * @class\n * @public\n */\nexport default class PartialField {\n    /**\n     * Initialize a new instance.\n     *\n     * @public\n     * @param {string} name - The name of the field.\n     * @param {Array} data - The data array.\n     * @param {Object} schema - The schema object of the corresponding field.\n     * @param {FieldParser} parser - The parser instance corresponding to that field.\n     */\n    constructor (name, data, schema, parser) {\n        this.name = name;\n        this.schema = schema;\n        this.parser = parser;\n        this.data = this._sanitize(data);\n    }\n\n    /**\n     * Sanitizes the field data.\n     *\n     * @private\n     * @param {Array} data - The actual input data.\n     * @return {Array} Returns the sanitized data.\n     */\n    _sanitize (data) {\n        return data.map(datum => this.parser.parse(datum, { format: this.schema.format }));\n    }\n}\n","import { rowDiffsetIterator } from '../../operator/row-diffset-iterator';\nimport Dimension from '../dimension';\nimport { DateTimeFormatter } from '../../utils';\nimport InvalidAwareTypes from '../../invalid-aware-types';\nimport TemporalParser from '../parsers/temporal-parser';\n\n/**\n * Represents temporal field subtype.\n *\n * @public\n * @class\n * @extends Dimension\n */\nexport default class Temporal extends Dimension {\n     /**\n     * Initialize a new instance.\n     *\n     * @public\n     * @param {PartialField} partialField - The partialField instance which holds the whole data.\n     * @param {string} rowDiffset - The data subset definition.\n     */\n    constructor (partialField, rowDiffset) {\n        super(partialField, rowDiffset);\n\n        this._cachedMinDiff = null;\n    }\n\n     /**\n     * Calculates the corresponding field domain.\n     *\n     * @public\n     * @override\n     * @return {Array} Returns the unique values.\n     */\n    calculateDataDomain () {\n        const hash = new Set();\n        const domain = [];\n\n        // here don't use this.data() as the iteration will be\n        // occurred two times on same data.\n        rowDiffsetIterator(this.rowDiffset, (i) => {\n            const datum = this.partialField.data[i];\n            if (!hash.has(datum)) {\n                hash.add(datum);\n                domain.push(datum);\n            }\n        });\n\n        return domain;\n    }\n\n\n    /**\n     * Calculates the minimum consecutive difference from the associated field data.\n     *\n     * @public\n     * @return {number} Returns the minimum consecutive diff in milliseconds.\n     */\n    minimumConsecutiveDifference () {\n        if (this._cachedMinDiff) {\n            return this._cachedMinDiff;\n        }\n\n        const sortedData = this.data().filter(item => !(item instanceof InvalidAwareTypes)).sort((a, b) => a - b);\n        const arrLn = sortedData.length;\n        let minDiff = Number.POSITIVE_INFINITY;\n        let prevDatum;\n        let nextDatum;\n        let processedCount = 0;\n\n        for (let i = 1; i < arrLn; i++) {\n            prevDatum = sortedData[i - 1];\n            nextDatum = sortedData[i];\n\n            if (nextDatum === prevDatum) {\n                continue;\n            }\n\n            minDiff = Math.min(minDiff, nextDatum - sortedData[i - 1]);\n            processedCount++;\n        }\n\n        if (!processedCount) {\n            minDiff = null;\n        }\n        this._cachedMinDiff = minDiff;\n\n        return this._cachedMinDiff;\n    }\n\n    /**\n     * Returns the format specified in the input schema while creating field.\n     *\n     * @public\n     * @return {string} Returns the datetime format.\n     */\n    format () {\n        return this.partialField.schema.format;\n    }\n\n    /**\n     * Returns the formatted version of the underlying field data\n     * If data is of type invalid or has missing format use the raw value\n     * @public\n     * @override\n     * @return {Array} Returns the formatted data.\n     */\n    formattedData () {\n        const data = [];\n        const dataFormat = this.format();\n\n        rowDiffsetIterator(this.rowDiffset, (i) => {\n            const datum = this.partialField.data[i];\n            // If value is of invalid type or format is missing\n            if (InvalidAwareTypes.isInvalid(datum) || (!dataFormat && Number.isFinite(datum))) {\n                // Use the invalid map value or the raw value\n                const parsedDatum = InvalidAwareTypes.getInvalidType(datum) || datum;\n                data.push(parsedDatum);\n            } else {\n                data.push(DateTimeFormatter.formatAs(datum, dataFormat));\n            }\n        });\n        return data;\n    }\n\n    static parser() {\n        return new TemporalParser();\n    }\n}\n\n","import { FieldType, FilteringMode, DimensionSubtype, MeasureSubtype, DataFormat } from './enums';\nimport fieldStore from './field-store';\nimport Value from './value';\nimport {\n    rowDiffsetIterator\n} from './operator';\nimport { DM_DERIVATIVES, LOGICAL_OPERATORS, ROW_ID } from './constants';\nimport { createFields, createUnitFieldFromPartial } from './field-creator';\nimport defaultConfig from './default-config';\nimport { converterStore } from './converter';\nimport { fieldRegistry } from './fields';\nimport { extend2, detectDataFormat } from './utils';\n\n/**\n * Prepares the selection data.\n */\nfunction prepareSelectionData (fields, formattedData, rawData, i) {\n    const resp = {};\n\n    for (const [key, field] of fields.entries()) {\n        resp[field.name()] = new Value(formattedData[key][i], rawData[key][i], field);\n    }\n    return resp;\n}\n\nexport function prepareJoinData (fields) {\n    const resp = {};\n\n    for (const key in fields) {\n        resp[key] = new Value(fields[key].formattedValue, fields[key].rawValue, key);\n    }\n    return resp;\n}\n\nexport const updateFields = ([rowDiffset, colIdentifier], partialFieldspace, fieldStoreName) => {\n    let collID = colIdentifier.length ? colIdentifier.split(',') : [];\n    let partialFieldMap = partialFieldspace.fieldsObj();\n    let newFields = collID.map(coll => createUnitFieldFromPartial(partialFieldMap[coll].partialField, rowDiffset));\n    return fieldStore.createNamespace(newFields, fieldStoreName);\n};\n\nexport const persistCurrentDerivation = (model, operation, config = {}, criteriaFn) => {\n    if (operation === DM_DERIVATIVES.COMPOSE) {\n        model._derivation.length = 0;\n        model._derivation.push(...criteriaFn);\n    } else {\n        model._derivation.push({\n            op: operation,\n            meta: config,\n            criteria: criteriaFn\n        });\n    }\n};\nexport const persistAncestorDerivation = (sourceDm, newDm) => {\n    newDm._ancestorDerivation.push(...sourceDm._ancestorDerivation, ...sourceDm._derivation);\n};\n\nexport const persistDerivations = (sourceDm, model, operation, config = {}, criteriaFn) => {\n    persistCurrentDerivation(model, operation, config, criteriaFn);\n    persistAncestorDerivation(sourceDm, model);\n};\n\nconst selectModeMap = {\n    [FilteringMode.NORMAL]: {\n        diffIndex: ['rowDiffset'],\n        calcDiff: [true, false]\n    },\n    [FilteringMode.INVERSE]: {\n        diffIndex: ['rejectRowDiffset'],\n        calcDiff: [false, true]\n    },\n    [FilteringMode.ALL]: {\n        diffIndex: ['rowDiffset', 'rejectRowDiffset'],\n        calcDiff: [true, true]\n    }\n};\n\nconst generateRowDiffset = (rowDiffset, i, lastInsertedValue) => {\n    if (lastInsertedValue !== -1 && i === (lastInsertedValue + 1)) {\n        const li = rowDiffset.length - 1;\n\n        rowDiffset[li] = `${rowDiffset[li].split('-')[0]}-${i}`;\n    } else {\n        rowDiffset.push(`${i}`);\n    }\n};\n\nexport const selectRowDiffsetIterator = (rowDiffset, checker, mode) => {\n    let lastInsertedValueSel = -1;\n    let lastInsertedValueRej = -1;\n    const newRowDiffSet = [];\n    const rejRowDiffSet = [];\n\n    const [shouldSelect, shouldReject] = selectModeMap[mode].calcDiff;\n\n    rowDiffsetIterator(rowDiffset, (i) => {\n        const checkerResult = checker(i);\n        checkerResult && shouldSelect && generateRowDiffset(newRowDiffSet, i, lastInsertedValueSel);\n        !checkerResult && shouldReject && generateRowDiffset(rejRowDiffSet, i, lastInsertedValueRej);\n    });\n    return {\n        rowDiffset: newRowDiffSet.join(','),\n        rejectRowDiffset: rejRowDiffSet.join(',')\n    };\n};\n\n\nexport const rowSplitDiffsetIterator = (rowDiffset, checker, mode, dimensionArr, fieldStoreObj) => {\n    let lastInsertedValue = {};\n    const splitRowDiffset = {};\n    const dimensionMap = {};\n\n    rowDiffsetIterator(rowDiffset, (i) => {\n        if (checker(i)) {\n            let hash = '';\n\n            let dimensionSet = { keys: {} };\n\n            dimensionArr.forEach((_) => {\n                const data = fieldStoreObj[_].partialField.data[i];\n                hash = `${hash}-${data}`;\n                dimensionSet.keys[_] = data;\n            });\n\n            if (splitRowDiffset[hash] === undefined) {\n                splitRowDiffset[hash] = [];\n                lastInsertedValue[hash] = -1;\n                dimensionMap[hash] = dimensionSet;\n            }\n\n            generateRowDiffset(splitRowDiffset[hash], i, lastInsertedValue[hash]);\n            lastInsertedValue[hash] = i;\n        }\n    });\n\n    return {\n        splitRowDiffset,\n        dimensionMap\n    };\n};\n\n\nexport const selectHelper = (clonedDm, selectFn, config, sourceDm, iterator) => {\n    let cachedStore = {};\n    let cloneProvider = () => sourceDm.detachedRoot();\n    const { mode } = config;\n    const rowDiffset = clonedDm._rowDiffset;\n    const cachedValueObjects = clonedDm._partialFieldspace._cachedValueObjects;\n\n    const selectorHelperFn = index => selectFn(\n        cachedValueObjects[index],\n        index,\n        cloneProvider,\n        cachedStore\n    );\n\n    return iterator(rowDiffset, selectorHelperFn, mode);\n};\n\nexport const cloneWithAllFields = (model) => {\n    const clonedDm = model.clone(false);\n    const partialFieldspace = model.getPartialFieldspace();\n    clonedDm._colIdentifier = partialFieldspace.fields.map(f => f.name()).join(',');\n\n    // flush out cached namespace values on addition of new fields\n    partialFieldspace._cachedFieldsObj = null;\n    partialFieldspace._cachedDimension = null;\n    partialFieldspace._cachedMeasure = null;\n    clonedDm.__calculateFieldspace().calculateFieldsConfig();\n\n    return clonedDm;\n};\n\nconst getKey = (arr, data, fn) => {\n    let key = fn(arr, data, 0);\n\n    for (let i = 1, len = arr.length; i < len; i++) {\n        key = `${key},${fn(arr, data, i)}`;\n    }\n    return key;\n};\n\nconst keyFn = (arr, fields, idx, rowId) => {\n    const val = fields[arr[idx]].internalValue;\n    return arr[idx] === ROW_ID ? rowId : val;\n};\n\nconst boundsChecker = {\n    [MeasureSubtype.CONTINUOUS]: (val, domain) => {\n        const domainArr = domain[0] instanceof Array ? domain : [domain];\n        return domainArr.some(dom => val >= dom[0] && val <= dom[1]);\n    }\n};\n\nconst isWithinDomain = (value, domain, fieldType) => boundsChecker[fieldType](value, domain);\n\nexport const filterPropagationModel = (model, propModels, config = {}) => {\n    let fns = [];\n    const operation = config.operation || LOGICAL_OPERATORS.AND;\n    const filterByMeasure = config.filterByMeasure || false;\n    const clonedModel = cloneWithAllFields(model);\n    const modelFieldsConfig = clonedModel.getFieldsConfig();\n\n    if (!propModels.length) {\n        fns = [() => false];\n    } else {\n        fns = propModels.map(propModel => ((criteria = {}) => {\n            const { identifiers = [[], []], range } = criteria;\n            const [fieldNames = [], values = []] = identifiers;\n            const dLen = fieldNames.length;\n            const valuesMap = {};\n\n            if (dLen) {\n                for (let i = 1, len = identifiers.length; i < len; i++) {\n                    const row = identifiers[i];\n                    const key = row.join();\n                    valuesMap[key] = 1;\n                }\n            }\n            const rangeKeys = Object.keys(range || {});\n            return values.length || rangeKeys.length ? (fields, i) => {\n                const present = dLen ? valuesMap[getKey(fieldNames, fields, keyFn, i)] : true;\n\n                if (filterByMeasure) {\n                    return rangeKeys.every((field) => {\n                        const val = fields[field].internalValue;\n                        return isWithinDomain(val, range[field], modelFieldsConfig[field].def.subtype);\n                    }) && present;\n                }\n                return present;\n            } : () => false;\n        })(propModel));\n    }\n\n    let filteredModel;\n    if (operation === LOGICAL_OPERATORS.AND) {\n        filteredModel = clonedModel.select(fields => fns.every(fn => fn(fields)), {\n            saveChild: false\n        });\n    } else {\n        filteredModel = clonedModel.select(fields => fns.some(fn => fn(fields)), {\n            saveChild: false\n        });\n    }\n\n    return filteredModel;\n};\n\n\nexport const splitWithSelect = (sourceDm, dimensionArr, reducerFn = val => val, config) => {\n    const {\n        saveChild,\n    } = config;\n    const fieldStoreObj = sourceDm.getFieldspace().fieldsObj();\n\n    const {\n        splitRowDiffset,\n        dimensionMap\n    } = selectHelper(\n        sourceDm.clone(saveChild),\n        reducerFn,\n        config,\n        sourceDm,\n        (...params) => rowSplitDiffsetIterator(...params, dimensionArr, fieldStoreObj)\n        );\n\n    const clonedDMs = [];\n    Object.keys(splitRowDiffset).sort().forEach((e) => {\n        if (splitRowDiffset[e]) {\n            const cloned = sourceDm.clone(saveChild);\n            const derivation = dimensionMap[e];\n            cloned._rowDiffset = splitRowDiffset[e].join(',');\n            cloned.__calculateFieldspace().calculateFieldsConfig();\n\n            const derivationFormula = fields => dimensionArr.every(_ => fields[_].internalValue === derivation.keys[_]);\n            // Store reference to child model and selector function\n            if (saveChild) {\n                persistDerivations(sourceDm, cloned, DM_DERIVATIVES.SELECT, config, derivationFormula);\n            }\n            cloned._derivation[cloned._derivation.length - 1].meta = dimensionMap[e];\n\n            clonedDMs.push(cloned);\n        }\n    });\n\n\n    return clonedDMs;\n};\nexport const addDiffsetToClonedDm = (clonedDm, rowDiffset, sourceDm, selectConfig, selectFn) => {\n    clonedDm._rowDiffset = rowDiffset;\n    clonedDm.__calculateFieldspace().calculateFieldsConfig();\n    persistDerivations(\n        sourceDm,\n        clonedDm,\n        DM_DERIVATIVES.SELECT,\n         { config: selectConfig },\n          selectFn\n    );\n};\n\n\nexport const cloneWithSelect = (sourceDm, selectFn, selectConfig, cloneConfig) => {\n    let extraCloneDm = {};\n\n    let { mode } = selectConfig;\n\n    const cloned = sourceDm.clone(cloneConfig.saveChild);\n    const setOfRowDiffsets = selectHelper(\n        cloned,\n        selectFn,\n        selectConfig,\n        sourceDm,\n        selectRowDiffsetIterator\n    );\n    const diffIndex = selectModeMap[mode].diffIndex;\n\n    addDiffsetToClonedDm(cloned, setOfRowDiffsets[diffIndex[0]], sourceDm, selectConfig, selectFn);\n\n    if (diffIndex.length > 1) {\n        extraCloneDm = sourceDm.clone(cloneConfig.saveChild);\n        addDiffsetToClonedDm(extraCloneDm, setOfRowDiffsets[diffIndex[1]], sourceDm, selectConfig, selectFn);\n        return [cloned, extraCloneDm];\n    }\n\n    return cloned;\n};\n\nexport const cloneWithProject = (sourceDm, projField, config, allFields) => {\n    const cloned = sourceDm.clone(config.saveChild);\n    let projectionSet = projField;\n    if (config.mode === FilteringMode.INVERSE) {\n        projectionSet = allFields.filter(fieldName => projField.indexOf(fieldName) === -1);\n    }\n    // cloned._colIdentifier = sourceDm._colIdentifier.split(',')\n    //                         .filter(coll => projectionSet.indexOf(coll) !== -1).join();\n    cloned._colIdentifier = projectionSet.join(',');\n    cloned.__calculateFieldspace().calculateFieldsConfig();\n\n    persistDerivations(\n        sourceDm,\n        cloned,\n        DM_DERIVATIVES.PROJECT,\n        { projField, config, actualProjField: projectionSet },\n        null\n    );\n\n    return cloned;\n};\n\n\nexport const splitWithProject = (sourceDm, projFieldSet, config, allFields) =>\n    projFieldSet.map(projFields =>\n        cloneWithProject(sourceDm, projFields, config, allFields));\n\nexport const sanitizeUnitSchema = (unitSchema) => {\n    // Do deep clone of the unit schema as the user might change it later.\n    unitSchema = extend2({}, unitSchema);\n    if (!unitSchema.type) {\n        unitSchema.type = FieldType.DIMENSION;\n    }\n\n    if (!unitSchema.subtype) {\n        switch (unitSchema.type) {\n        case FieldType.MEASURE:\n            unitSchema.subtype = MeasureSubtype.CONTINUOUS;\n            break;\n        default:\n        case FieldType.DIMENSION:\n            unitSchema.subtype = DimensionSubtype.CATEGORICAL;\n            break;\n        }\n    }\n\n    return unitSchema;\n};\n\nexport const validateUnitSchema = (unitSchema) => {\n    const { type, subtype, name } = unitSchema;\n    if (type === FieldType.DIMENSION || type === FieldType.MEASURE) {\n        if (!fieldRegistry.has(subtype)) {\n            throw new Error(`DataModel doesn't support measure field subtype ${subtype} used for ${name} field`);\n        }\n    } else {\n        throw new Error(`DataModel doesn't support field type ${type} used for ${name} field`);\n    }\n};\n\nexport const sanitizeAndValidateSchema = schema => schema.map((unitSchema) => {\n    unitSchema = sanitizeUnitSchema(unitSchema);\n    validateUnitSchema(unitSchema);\n    return unitSchema;\n});\n\nexport const resolveFieldName = (schema, dataHeader) => {\n    schema.forEach((unitSchema) => {\n        const fieldNameAs = unitSchema.as;\n        if (!fieldNameAs) { return; }\n\n        const idx = dataHeader.indexOf(unitSchema.name);\n        dataHeader[idx] = fieldNameAs;\n        unitSchema.name = fieldNameAs;\n        delete unitSchema.as;\n    });\n};\n\nexport const updateData = (relation, data, schema, options) => {\n    schema = sanitizeAndValidateSchema(schema);\n    options = Object.assign(Object.assign({}, defaultConfig), options);\n    const converter = converterStore.get(options.dataFormat);\n\n\n    if (!converter) {\n        throw new Error(`No converter function found for ${options.dataFormat} format`);\n    }\n\n    const [header, formattedData] = converter.convert(data, schema, options);\n    resolveFieldName(schema, header);\n    const fieldArr = createFields(formattedData, schema, header);\n\n    // This will create a new fieldStore with the fields\n    const nameSpace = fieldStore.createNamespace(fieldArr, options.name);\n    relation._partialFieldspace = nameSpace;\n\n    // If data is provided create the default colIdentifier and rowDiffset\n    relation._rowDiffset = formattedData.length && formattedData[0].length ? `0-${formattedData[0].length - 1}` : '';\n\n    // This stores the value objects which is passed to the filter method when selection operation is done.\n    const valueObjects = [];\n    const { fields } = nameSpace;\n    const rawFieldsData = fields.map(field => field.data());\n    const formattedFieldsData = fields.map(field => field.formattedData());\n    rowDiffsetIterator(relation._rowDiffset, (i) => {\n        valueObjects[i] = prepareSelectionData(fields, formattedFieldsData, rawFieldsData, i);\n    });\n    nameSpace._cachedValueObjects = valueObjects;\n\n    relation._colIdentifier = (schema.map(_ => _.name)).join();\n    relation._dataFormat = options.dataFormat === DataFormat.AUTO ? detectDataFormat(data) : options.dataFormat;\n    return relation;\n};\n\nexport const fieldInSchema = (schema, field) => {\n    let i = 0;\n\n    for (; i < schema.length; ++i) {\n        if (field === schema[i].name) {\n            return {\n                name: field,\n                type: schema[i].subtype || schema[i].type,\n                index: i,\n            };\n        }\n    }\n    return null;\n};\n\nexport const getDerivationArguments = (derivation) => {\n    let params = [];\n    let operation;\n    operation = derivation.op;\n    switch (operation) {\n    case DM_DERIVATIVES.SELECT:\n        params = [derivation.criteria];\n        break;\n    case DM_DERIVATIVES.PROJECT:\n        params = [derivation.meta.actualProjField];\n        break;\n    case DM_DERIVATIVES.SORT:\n        params = [derivation.criteria];\n        break;\n    case DM_DERIVATIVES.GROUPBY:\n        operation = 'groupBy';\n        params = [derivation.meta.groupByString.split(','), derivation.criteria];\n        break;\n    default:\n        operation = null;\n    }\n\n    return {\n        operation,\n        params\n    };\n};\n\nconst applyExistingOperationOnModel = (propModel, dataModel) => {\n    const derivations = dataModel.getDerivations();\n    let selectionModel = propModel;\n\n    derivations.forEach((derivation) => {\n        if (!derivation) {\n            return;\n        }\n\n        const { operation, params } = getDerivationArguments(derivation);\n        if (operation) {\n            selectionModel = selectionModel[operation](...params, {\n                saveChild: false\n            });\n        }\n    });\n\n    return selectionModel;\n};\n\nconst getFilteredModel = (propModel, path) => {\n    for (let i = 0, len = path.length; i < len; i++) {\n        const model = path[i];\n        propModel = applyExistingOperationOnModel(propModel, model);\n    }\n    return propModel;\n};\n\nconst propagateIdentifiers = (dataModel, propModel, config = {}, propModelInf = {}) => {\n    const nonTraversingModel = propModelInf.nonTraversingModel;\n    const excludeModels = propModelInf.excludeModels || [];\n\n    if (dataModel === nonTraversingModel) {\n        return;\n    }\n\n    const propagate = excludeModels.length ? excludeModels.indexOf(dataModel) === -1 : true;\n\n    propagate && dataModel.handlePropagation(propModel, config);\n\n    const children = dataModel._children;\n    children.forEach((child) => {\n        const selectionModel = applyExistingOperationOnModel(propModel, child);\n        propagateIdentifiers(child, selectionModel, config, propModelInf);\n    });\n};\n\nexport const getRootGroupByModel = (model) => {\n    while (model._parent && model._derivation.find(d => d.op !== DM_DERIVATIVES.GROUPBY)) {\n        model = model._parent;\n    }\n    return model;\n};\n\nexport const getRootDataModel = (model) => {\n    while (model._parent) {\n        model = model._parent;\n    }\n    return model;\n};\n\nexport const getPathToRootModel = (model, path = []) => {\n    while (model._parent) {\n        path.push(model);\n        model = model._parent;\n    }\n    return path;\n};\n\nexport const propagateToAllDataModels = (identifiers, rootModels, propagationInf, config) => {\n    let criteria;\n    let propModel;\n    const { propagationNameSpace, propagateToSource } = propagationInf;\n    const propagationSourceId = propagationInf.sourceId;\n    const propagateInterpolatedValues = config.propagateInterpolatedValues;\n    const filterFn = (entry) => {\n        const filter = config.filterFn || (() => true);\n        return filter(entry, config);\n    };\n\n    let criterias = [];\n\n    if (identifiers === null && config.persistent !== true) {\n        criterias = [{\n            criteria: []\n        }];\n        criteria = [];\n    } else {\n        let actionCriterias = Object.values(propagationNameSpace.mutableActions);\n        if (propagateToSource !== false) {\n            actionCriterias = actionCriterias.filter(d => d.config.sourceId !== propagationSourceId);\n        }\n\n        const filteredCriteria = actionCriterias.filter(filterFn).map(action => action.config.criteria);\n\n        const excludeModels = [];\n\n        if (propagateToSource !== false) {\n            const sourceActionCriterias = Object.values(propagationNameSpace.mutableActions);\n\n            sourceActionCriterias.forEach((actionInf) => {\n                const actionConf = actionInf.config;\n                if (actionConf.applyOnSource === false && actionConf.action === config.action &&\n                        actionConf.sourceId !== propagationSourceId) {\n                    excludeModels.push(actionInf.model);\n                    criteria = sourceActionCriterias.filter(d => d !== actionInf).map(d => d.config.criteria);\n                    criteria.length && criterias.push({\n                        criteria,\n                        models: actionInf.model,\n                        path: getPathToRootModel(actionInf.model)\n                    });\n                }\n            });\n        }\n\n\n        criteria = [].concat(...[...filteredCriteria, identifiers]).filter(d => d !== null);\n        criterias.push({\n            criteria,\n            excludeModels: [...excludeModels, ...config.excludeModels || []]\n        });\n    }\n\n    const rootModel = rootModels.model;\n\n    const propConfig = Object.assign({\n        sourceIdentifiers: identifiers,\n        propagationSourceId\n    }, config);\n\n    const rootGroupByModel = rootModels.groupByModel;\n    if (propagateInterpolatedValues && rootGroupByModel) {\n        propModel = filterPropagationModel(rootGroupByModel, criteria, {\n            filterByMeasure: propagateInterpolatedValues\n        });\n        propagateIdentifiers(rootGroupByModel, propModel, propConfig);\n    }\n\n    criterias.forEach((inf) => {\n        const propagationModel = filterPropagationModel(rootModel, inf.criteria);\n        const path = inf.path;\n\n        if (path) {\n            const filteredModel = getFilteredModel(propagationModel, path.reverse());\n            inf.models.handlePropagation(filteredModel, propConfig);\n        } else {\n            propagateIdentifiers(rootModel, propagationModel, propConfig, {\n                excludeModels: inf.excludeModels,\n                nonTraversingModel: propagateInterpolatedValues && rootGroupByModel\n            });\n        }\n    });\n};\n\nexport const propagateImmutableActions = (propagationNameSpace, rootModels, propagationInf) => {\n    const immutableActions = propagationNameSpace.immutableActions;\n\n    for (const action in immutableActions) {\n        const actionInf = immutableActions[action];\n        const actionConf = actionInf.config;\n        const propagationSourceId = propagationInf.config.sourceId;\n        const filterImmutableAction = propagationInf.propConfig.filterImmutableAction ?\n            propagationInf.propConfig.filterImmutableAction(actionConf, propagationInf.config) : true;\n        if (actionConf.sourceId !== propagationSourceId && filterImmutableAction) {\n            const criteriaModel = actionConf.criteria;\n            propagateToAllDataModels(criteriaModel, rootModels, {\n                propagationNameSpace,\n                propagateToSource: false,\n                sourceId: propagationSourceId\n            }, actionConf);\n        }\n    }\n};\n\nexport const addToPropNamespace = (propagationNameSpace, config = {}, model) => {\n    let sourceNamespace;\n    const isMutableAction = config.isMutableAction;\n    const criteria = config.criteria;\n    const key = `${config.action}-${config.sourceId}`;\n\n    if (isMutableAction) {\n        sourceNamespace = propagationNameSpace.mutableActions;\n    } else {\n        sourceNamespace = propagationNameSpace.immutableActions;\n    }\n\n    if (criteria === null) {\n        delete sourceNamespace[key];\n    } else {\n        sourceNamespace[key] = {\n            model,\n            config\n        };\n    }\n\n    return this;\n};\n\n\nexport const getNormalizedProFields = (projField, allFields, fieldConfig) => {\n    const normalizedProjField = projField.reduce((acc, field) => {\n        if (field.constructor.name === 'RegExp') {\n            acc.push(...allFields.filter(fieldName => fieldName.search(field) !== -1));\n        } else if (field in fieldConfig) {\n            acc.push(field);\n        }\n        return acc;\n    }, []);\n    return Array.from(new Set(normalizedProjField)).map(field => field.trim());\n};\n\n/**\n * Get the numberFormatted value if numberFormat present,\n * else returns the supplied value.\n * @param {Object} field Field Instance\n * @param {Number|String} value\n * @return {Number|String}\n */\nexport const getNumberFormattedVal = (field, value) => {\n    if (field.numberFormat) {\n        return field.numberFormat()(value);\n    }\n    return value;\n};\n","const DataModel = require('./export');\n\nmodule.exports = DataModel.default ? DataModel.default : DataModel;\n","/**\n * A parser to parser null, undefined, invalid and NIL values.\n *\n * @public\n * @class\n */\nclass InvalidAwareTypes {\n    /**\n     * Static method which gets/sets the invalid value registry.\n     *\n     * @public\n     * @param {Object} config - The custom configuration supplied by user.\n     * @return {Object} Returns the invalid values registry.\n     */\n    static invalidAwareVals (config) {\n        if (!config) {\n            return InvalidAwareTypes._invalidAwareValsMap;\n        }\n        return Object.assign(InvalidAwareTypes._invalidAwareValsMap, config);\n    }\n\n    /**\n     * Initialize a new instance.\n     *\n     * @public\n     * @param {string} value - The value of the invalid data type.\n     */\n    constructor (value) {\n        this._value = value;\n    }\n\n    /**\n     * Returns the current value of the instance.\n     *\n     * @public\n     * @return {string} Returns the value of the invalid data type.\n     */\n    value () {\n        return this._value;\n    }\n\n    /**\n     * Returns the current value of the instance in string format.\n     *\n     * @public\n     * @return {string} Returns the value of the invalid data type.\n     */\n    toString () {\n        return String(this._value);\n    }\n\n    static isInvalid(val) {\n        return (val instanceof InvalidAwareTypes) || !!InvalidAwareTypes.invalidAwareVals()[val];\n    }\n\n    static getInvalidType(val) {\n        return val instanceof InvalidAwareTypes ? val : InvalidAwareTypes.invalidAwareVals()[val];\n    }\n}\n\n/**\n * Enums for Invalid types.\n */\nInvalidAwareTypes.NULL = new InvalidAwareTypes('null');\nInvalidAwareTypes.NA = new InvalidAwareTypes('na');\nInvalidAwareTypes.NIL = new InvalidAwareTypes('nil');\n\n/**\n * Default Registry for mapping the invalid values.\n *\n * @private\n */\nInvalidAwareTypes._invalidAwareValsMap = {\n    invalid: InvalidAwareTypes.NA,\n    nil: InvalidAwareTypes.NIL,\n    null: InvalidAwareTypes.NULL,\n    undefined: InvalidAwareTypes.NA\n};\n\nexport default InvalidAwareTypes;\n","import { rowDiffsetIterator } from './row-diffset-iterator';\nimport InvalidAwareTypes from '../invalid-aware-types';\n\nconst generateBuckets = (binSize, start, end) => {\n    const buckets = [];\n    let next = start;\n\n    while (next < end) {\n        buckets.push(next);\n        next += binSize;\n    }\n    buckets.push(next);\n\n    return buckets;\n};\n\nconst findBucketRange = (bucketRanges, value) => {\n    let leftIdx = 0;\n    let rightIdx = bucketRanges.length - 1;\n    let midIdx;\n    let range;\n\n    // Here use binary search as the bucketRanges is a sorted array\n    while (leftIdx <= rightIdx) {\n        midIdx = leftIdx + Math.floor((rightIdx - leftIdx) / 2);\n        range = bucketRanges[midIdx];\n\n        if (value >= range.start && value < range.end) {\n            return range;\n        } else if (value >= range.end) {\n            leftIdx = midIdx + 1;\n        } else if (value < range.start) {\n            rightIdx = midIdx - 1;\n        }\n    }\n\n    return null;\n};\n\n /**\n  * Creates the bin data from input measure field and supplied configs.\n  *\n  * @param {Measure} measureField - The Measure field instance.\n  * @param {string} rowDiffset - The datamodel rowDiffset values.\n  * @param {Object} config - The config object.\n  * @return {Object} Returns the binned data and the corresponding bins.\n  */\nexport function createBinnedFieldData (measureField, rowDiffset, config) {\n    let { buckets, binsCount, binSize, start, end } = config;\n    const [dMin, dMax] = measureField.domain();\n\n    if (!buckets) {\n        start = (start !== 0 && (!start || start > dMin)) ? dMin : start;\n        end = (end !== 0 && (!end || end < dMax)) ? (dMax + 1) : end;\n\n        if (binsCount) {\n            binSize = Math.ceil(Math.abs(end - start) / binsCount);\n        }\n\n        buckets = generateBuckets(binSize, start, end);\n    }\n\n    if (buckets[0] > dMin) {\n        buckets.unshift(dMin);\n    }\n    if (buckets[buckets.length - 1] <= dMax) {\n        buckets.push(dMax + 1);\n    }\n\n    const bucketRanges = [];\n    for (let i = 0; i < buckets.length - 1; i++) {\n        bucketRanges.push({\n            start: buckets[i],\n            end: buckets[i + 1]\n        });\n    }\n\n    const binnedData = [];\n    rowDiffsetIterator(rowDiffset, (i) => {\n        const datum = measureField.partialField.data[i];\n        if (datum instanceof InvalidAwareTypes) {\n            binnedData.push(datum);\n            return;\n        }\n\n        const range = findBucketRange(bucketRanges, datum);\n        binnedData.push(`${range.start}-${range.end}`);\n    });\n\n    return { binnedData, bins: buckets };\n}\n","import { persistDerivations } from '../helper';\nimport { DM_DERIVATIVES } from '../constants';\n\n/**\n * DataModel's opearators are exposed as composable functional operators as well as chainable operators. Chainable\n * operators are called on the instances of {@link Datamodel} and {@link Relation} class.\n *\n * Those same operators can be used as composable operators from `DataModel.Operators` namespace.\n *\n * All these operators have similar behaviour. All these operators when called with the argument returns a function\n * which expects a DataModel instance.\n *\n * @public\n * @module Operators\n * @namespace DataModel\n */\n\n/**\n * This is functional version of selection operator. {@link link_to_selection | Selection} is a row filtering operation.\n * It takes {@link SelectionPredicate | predicate} for filtering criteria and returns a function.\n * The returned function is called with the DataModel instance on which the action needs to be performed.\n *\n * {@link SelectionPredicate} is a function which returns a boolean value. For selection opearation the selection\n * function is called for each row of DataModel instance with the current row passed as argument.\n *\n * After executing {@link SelectionPredicate} the rows are labeled as either an entry of selection set or an entry\n * of rejection set.\n *\n * {@link FilteringMode} operates on the selection and rejection set to determine which one would reflect in the\n * resulatant datamodel.\n *\n * @warning\n * [Warn] Selection and rejection set is only a logical idea for concept explanation purpose.\n *\n * @error\n * [Error] `FilteringMode.ALL` is not a valid working mode for functional version of `select`. Its only avialable on the\n * chained version.\n *\n * @example\n * const select = DataModel.Operators.select;\n * usaCarsFn = select(fields => fields.Origin.value === 'USA');\n * usaCarsDm = usaCarsFn(dm);\n * console.log(usaCarsDm);\n *\n * @public\n * @namespace DataModel\n * @module Operators\n *\n * @param {SelectionPredicate} selectFn - Predicate funciton which is called for each row with the current row\n *      ```\n *          function (row, i)  { ... }\n *      ```\n * @param {Object} [config] - The configuration object to control the inclusion exclusion of a row in resultant\n *      DataModel instance\n * @param {FilteringMode} [config.mode=FilteringMode.NORMAL] - The mode of the selection\n *\n * @return {PreparatorFunction} Function which expects an instance of DataModel on which the operator needs to be\n *      applied.\n */\nexport const select = (...args) => dm => dm.select(...args);\n\n/**\n * This is functional version of projection operator. {@link link_to_projection | Projection} is a column filtering\n * operation.It expects list of fields name and either include those or exclude those based on {@link FilteringMode} on\n * the  resultant variable.It returns a function which is called with the DataModel instance on which the action needs\n * to be performed.\n *\n * Projection expects array of fields name based on which it creates the selection and rejection set. All the field\n * whose name is present in array goes in selection set and rest of the fields goes in rejection set.\n *\n * {@link FilteringMode} operates on the selection and rejection set to determine which one would reflect in the\n * resulatant datamodel.\n *\n * @warning\n * Selection and rejection set is only a logical idea for concept explanation purpose.\n *\n * @error\n * `FilteringMode.ALL` is not a valid working mode for functional version of `select`. Its only avialable on the\n * chained version.\n *\n * @public\n * @namespace DataModel\n * @module Operators\n *\n * @param {Array.<string | Regexp>} projField - An array of column names in string or regular expression.\n * @param {Object} [config] - An optional config to control the creation of new DataModel\n * @param {FilteringMode} [config.mode=FilteringMode.NORMAL] - Mode of the projection\n *\n * @return {PreparatorFunction} Function which expects an instance of DataModel on which the operator needs to be\n *      applied.\n */\nexport const project = (...args) => dm => dm.project(...args);\n\n/**\n * This is functional version of binnig operator. Binning happens on a measure field based on a binning configuration.\n * Binning in DataModel does not aggregate the number of rows present in DataModel instance after binning, it just adds\n * a new field with the binned value. Refer binning {@link example_of_binning | example} to have a intuition of what\n * binning is and the use case.\n *\n * Binning can be configured by\n * - providing custom bin configuration with non uniform buckets\n * - providing bin count\n * - providing each bin size\n *\n * When custom buckets are provided as part of binning configuration\n * @example\n *  // DataModel already prepared and assigned to dm vairable\n *  const buckets = {\n *      start: 30\n *      stops: [80, 100, 110]\n *  };\n *  const config = { buckets, name: 'binnedHP' }\n *  const binFn = bin('horsepower', config);\n *  const binnedDm = binFn(dm);\n *\n * @text\n * When `binCount` is defined as part of binning configuration\n * @example\n *  // DataModel already prepared and assigned to dm vairable\n *  const config = { binCount: 5, name: 'binnedHP' }\n *  const binFn = bin('horsepower', config);\n *  const binnedDm = binFn(Dm);\n *\n * @text\n * When `binSize` is defined as part of binning configuration\n * @example\n *  // DataModel already prepared and assigned to dm vairable\n *  const config = { binSize: 200, name: 'binnedHorsepower' }\n *  const binnedDm = dataModel.bin('horsepower', config);\n *  const binnedDm = binFn(Dm);\n *\n * @public\n * @namespace DataModel\n * @module Operators\n *\n * @param {String} name Name of measure which will be used to create bin\n * @param {Object} config Config required for bin creation\n * @param {Array.<Number>} config.bucketObj.stops Defination of bucket ranges. Two subsequent number from arrays\n *      are picked and a range is created. The first number from range is inclusive and the second number from range\n *      is exclusive.\n * @param {Number} [config.bucketObj.startAt] Force the start of the bin from a particular number.\n *      If not mentioned, the start of the bin or the lower domain of the data if stops is not mentioned, else its\n *      the first value of the stop.\n * @param {Number} config.binSize Bucket size for each bin\n * @param {Number} config.binCount Number of bins which will be created\n * @param {String} config.name Name of the new binned field to be created\n *\n * @return {PreparatorFunction} Function which expects an instance of DataModel on which the operator needs to be\n *      applied.\n */\nexport const bin = (...args) => dm => dm.bin(...args);\n\n/**\n * This is functional version of `groupBy` operator.Groups the data using particular dimensions and by reducing\n * measures. It expects a list of dimensions using which it projects the datamodel and perform aggregations to reduce\n * the duplicate tuples. Refer this {@link link_to_one_example_with_group_by | document} to know the intuition behind\n * groupBy.\n *\n * DataModel by default provides definition of few {@link reducer | Reducers}.\n * {@link ReducerStore | User defined reducers} can also be registered.\n *\n * This is the chained implementation of `groupBy`.\n * `groupBy` also supports {@link link_to_compose_groupBy | composability}\n *\n * @example\n * const groupBy = DataModel.Operators.groupBy;\n * const groupedFn = groupBy(['Year'], { horsepower: 'max' } );\n * groupedDM = groupByFn(dm);\n *\n * @public\n *\n * @param {Array.<string>} fieldsArr - Array containing the name of dimensions\n * @param {Object} [reducers={}] - A map whose key is the variable name and value is the name of the reducer. If its\n *      not passed, or any variable is ommitted from the object, default aggregation function is used from the\n *      schema of the variable.\n *\n * @return {PreparatorFunction} Function which expects an instance of DataModel on which the operator needs to be\n *      applied.\n */\nexport const groupBy = (...args) => dm => dm.groupBy(...args);\n\n/**\n * Enables composing operators to run multiple operations and save group of operataion as named opration on a DataModel.\n * The resulting DataModel will be the result of all the operation provided. The operations provided will be executed in\n * a serial manner ie. result of one operation will be the input for the next operations (like pipe operator in unix).\n *\n * Suported operations in compose are\n * - `select`\n * - `project`\n * - `groupBy`\n * - `bin`\n * - `compose`\n *\n * @example\n * const compose = DataModel.Operators.compose;\n * const select = DataModel.Operators.select;\n * const project = DataModel.Operators.project;\n *\n * let composedFn = compose(\n *    select(fields => fields.netprofit.value <= 15),\n *    project(['netprofit', 'netsales']));\n *\n * const dataModel = new DataModel(data1, schema1);\n *\n * let composedDm = composedFn(dataModel);\n *\n * @public\n * @namespace DataModel\n * @module Operators\n *\n * @param {Array.<Operators>} operators: An array of operation that will be applied on the\n * datatable.\n *\n * @returns {DataModel} Instance of resultant DataModel\n */\nexport const compose = (...operations) =>\n    (dm, config = { saveChild: true }) => {\n        let currentDM = dm;\n        let firstChild;\n        const derivations = [];\n\n        operations.forEach((operation) => {\n            currentDM = operation(currentDM);\n            derivations.push(...currentDM._derivation);\n            if (!firstChild) {\n                firstChild = currentDM;\n            }\n        });\n\n        if (firstChild && firstChild !== currentDM) {\n            firstChild.dispose();\n        }\n\n        // reset all ancestorDerivation saved in-between compose\n        currentDM._ancestorDerivation = [];\n        persistDerivations(\n            dm,\n            currentDM,\n            DM_DERIVATIVES.COMPOSE,\n            null,\n            derivations\n        );\n\n        if (config.saveChild) {\n            currentDM.setParent(dm);\n        } else {\n            currentDM.setParent(null);\n        }\n\n        return currentDM;\n    };\n","import DataModel from '../datamodel';\nimport { extend2 } from '../utils';\nimport { getCommonSchema } from './get-common-schema';\nimport { rowDiffsetIterator } from './row-diffset-iterator';\nimport { JOINS } from '../constants';\nimport { prepareJoinData } from '../helper';\n/**\n * Default filter function for crossProduct.\n *\n * @return {boolean} Always returns true.\n */\nfunction defaultFilterFn() { return true; }\n\n/**\n * Implementation of cross product operation between two DataModel instances.\n * It internally creates the data and schema for the new DataModel.\n *\n * @param {DataModel} dataModel1 - The left DataModel instance.\n * @param {DataModel} dataModel2 - The right DataModel instance.\n * @param {Function} filterFn - The filter function which is used to filter the tuples.\n * @param {boolean} [replaceCommonSchema=false] - The flag if the common name schema should be there.\n * @return {DataModel} Returns The newly created DataModel instance from the crossProduct operation.\n */\nexport function crossProduct (dm1, dm2, filterFn, replaceCommonSchema = false, jointype = JOINS.CROSS) {\n    const schema = [];\n    const data = [];\n    const applicableFilterFn = filterFn || defaultFilterFn;\n    const dm1FieldStore = dm1.getFieldspace();\n    const dm2FieldStore = dm2.getFieldspace();\n    const dm1FieldStoreName = dm1FieldStore.name;\n    const dm2FieldStoreName = dm2FieldStore.name;\n    const name = `${dm1FieldStore.name}.${dm2FieldStore.name}`;\n    const commonSchemaList = getCommonSchema(dm1FieldStore, dm2FieldStore);\n\n    if (dm1FieldStoreName === dm2FieldStoreName) {\n        throw new Error('DataModels must have different alias names');\n    }\n    // Here prepare the schema\n    dm1FieldStore.fields.forEach((field) => {\n        const tmpSchema = extend2({}, field.schema());\n        if (commonSchemaList.indexOf(tmpSchema.name) !== -1 && !replaceCommonSchema) {\n            tmpSchema.name = `${dm1FieldStore.name}.${tmpSchema.name}`;\n        }\n        schema.push(tmpSchema);\n    });\n    dm2FieldStore.fields.forEach((field) => {\n        const tmpSchema = extend2({}, field.schema());\n        if (commonSchemaList.indexOf(tmpSchema.name) !== -1) {\n            if (!replaceCommonSchema) {\n                tmpSchema.name = `${dm2FieldStore.name}.${tmpSchema.name}`;\n                schema.push(tmpSchema);\n            }\n        } else {\n            schema.push(tmpSchema);\n        }\n    });\n\n    // Here prepare Data\n    rowDiffsetIterator(dm1._rowDiffset, (i) => {\n        let rowAdded = false;\n        let rowPosition;\n        rowDiffsetIterator(dm2._rowDiffset, (ii) => {\n            const tuple = [];\n            const userArg = {};\n            userArg[dm1FieldStoreName] = {};\n            userArg[dm2FieldStoreName] = {};\n            dm1FieldStore.fields.forEach((field) => {\n                tuple.push(field.partialField.data[i]);\n                userArg[dm1FieldStoreName][field.name()] = {\n                    rawValue: field.partialField.data[i],\n                    formattedValue: field.formattedData()[i],\n                };\n            });\n            dm2FieldStore.fields.forEach((field) => {\n                if (!(commonSchemaList.indexOf(field.schema().name) !== -1 && replaceCommonSchema)) {\n                    tuple.push(field.partialField.data[ii]);\n                }\n                userArg[dm2FieldStoreName][field.name()] = {\n                    rawValue: field.partialField.data[ii],\n                    formattedValue: field.formattedData()[ii],\n                };\n            });\n\n            let cachedStore = {};\n            let cloneProvider1 = () => dm1.detachedRoot();\n            let cloneProvider2 = () => dm2.detachedRoot();\n\n            const dm1Fields = prepareJoinData(userArg[dm1FieldStoreName]);\n            const dm2Fields = prepareJoinData(userArg[dm2FieldStoreName]);\n            if (applicableFilterFn(dm1Fields, dm2Fields, cloneProvider1, cloneProvider2, cachedStore)) {\n                const tupleObj = {};\n                tuple.forEach((cellVal, iii) => {\n                    tupleObj[schema[iii].name] = cellVal;\n                });\n                if (rowAdded && JOINS.CROSS !== jointype) {\n                    data[rowPosition] = tupleObj;\n                }\n                else {\n                    data.push(tupleObj);\n                    rowAdded = true;\n                    rowPosition = i;\n                }\n            } else if ((jointype === JOINS.LEFTOUTER || jointype === JOINS.RIGHTOUTER) && !rowAdded) {\n                const tupleObj = {};\n                let len = dm1FieldStore.fields.length - 1;\n                tuple.forEach((cellVal, iii) => {\n                    if (iii <= len) {\n                        tupleObj[schema[iii].name] = cellVal;\n                    }\n                    else {\n                        tupleObj[schema[iii].name] = null;\n                    }\n                });\n                rowAdded = true;\n                rowPosition = i;\n                data.push(tupleObj);\n            }\n        });\n    });\n\n    return new DataModel(data, schema, { name });\n}\n","import { rowDiffsetIterator } from './row-diffset-iterator';\nimport { sortData } from './sort';\n\n/**\n * Builds the actual data array.\n *\n * @param {Array} fieldStore - An array of field.\n * @param {string} rowDiffset - A string consisting of which rows to be included eg. '0-2,4,6';\n * @param {string} colIdentifier - A string consisting of the details of which column\n * to be included eg 'date,sales,profit';\n * @param {Object} sortingDetails - An object containing the sorting details of the DataModel instance.\n * @param {Object} options - The options required to create the type of the data.\n * @return {Object} Returns an object containing the multidimensional array and the relative schema.\n */\nexport function dataBuilder (fieldStore, rowDiffset, colIdentifier, sortingDetails, options) {\n    const defOptions = {\n        addUid: false,\n        columnWise: false\n    };\n    options = Object.assign({}, defOptions, options);\n\n    const retObj = {\n        schema: [],\n        data: [],\n        uids: []\n    };\n    const addUid = options.addUid;\n    const reqSorting = sortingDetails && sortingDetails.length > 0;\n    // It stores the fields according to the colIdentifier argument\n    const tmpDataArr = [];\n    // Stores the fields according to the colIdentifier argument\n    const colIArr = colIdentifier.split(',');\n\n    colIArr.forEach((colName) => {\n        for (let i = 0; i < fieldStore.length; i += 1) {\n            if (fieldStore[i].name() === colName) {\n                tmpDataArr.push(fieldStore[i]);\n                break;\n            }\n        }\n    });\n\n    // Inserts the schema to the schema object\n    tmpDataArr.forEach((field) => {\n        /** @todo Need to use extend2 here otherwise user can overwrite the schema. */\n        retObj.schema.push(field.schema());\n    });\n\n    if (addUid) {\n        retObj.schema.push({\n            name: 'uid',\n            type: 'identifier'\n        });\n    }\n\n    rowDiffsetIterator(rowDiffset, (i) => {\n        retObj.data.push([]);\n        const insertInd = retObj.data.length - 1;\n        let start = 0;\n        tmpDataArr.forEach((field, ii) => {\n            retObj.data[insertInd][ii + start] = field.partialField.data[i];\n        });\n        if (addUid) {\n            retObj.data[insertInd][tmpDataArr.length] = i;\n        }\n        // Creates an array of unique identifiers for each row\n        retObj.uids.push(i);\n\n        // If sorting needed then there is the need to expose the index\n        // mapping from the old index to its new index\n        if (reqSorting) { retObj.data[insertInd].push(i); }\n    });\n\n    // Handles the sort functionality\n    if (reqSorting) {\n        sortData(retObj, sortingDetails);\n    }\n\n    if (options.columnWise) {\n        const tmpData = Array(...Array(retObj.schema.length)).map(() => []);\n        retObj.data.forEach((tuple) => {\n            tuple.forEach((data, i) => {\n                tmpData[i].push(data);\n            });\n        });\n        retObj.data = tmpData;\n    }\n\n    return retObj;\n}\n","import DataModel from '../datamodel';\nimport { extend2 } from '../utils';\nimport { rowDiffsetIterator } from './row-diffset-iterator';\nimport { isArrEqual } from '../utils/helper';\n\n/**\n * Performs the union operation between two dm instances.\n *\n * @todo Fix the conflicts between union and difference terminology here.\n *\n * @param {dm} dm1 - The first dm instance.\n * @param {dm} dm2 - The second dm instance.\n * @return {dm} Returns the newly created dm after union operation.\n */\nexport function difference (dm1, dm2) {\n    const hashTable = {};\n    const schema = [];\n    const schemaNameArr = [];\n    const data = [];\n    const dm1FieldStore = dm1.getFieldspace();\n    const dm2FieldStore = dm2.getFieldspace();\n    const dm1FieldStoreFieldObj = dm1FieldStore.fieldsObj();\n    const dm2FieldStoreFieldObj = dm2FieldStore.fieldsObj();\n    const name = `${dm1FieldStore.name} union ${dm2FieldStore.name}`;\n\n   // For union the columns should match otherwise return a clone of the dm1\n    if (!isArrEqual(dm1._colIdentifier.split(',').sort(), dm2._colIdentifier.split(',').sort())) {\n        return null;\n    }\n\n    // Prepare the schema\n    (dm1._colIdentifier.split(',')).forEach((fieldName) => {\n        const field = dm1FieldStoreFieldObj[fieldName];\n        schema.push(extend2({}, field.schema()));\n        schemaNameArr.push(field.schema().name);\n    });\n\n    /**\n     * The helper function to create the data.\n     *\n     * @param {dm} dm - The dm instance for which the data is inserted.\n     * @param {Object} fieldsObj - The fieldStore object format.\n     * @param {boolean} addData - If true only tuple will be added to the data.\n     */\n    function prepareDataHelper(dm, fieldsObj, addData) {\n        rowDiffsetIterator(dm._rowDiffset, (i) => {\n            const tuple = {};\n            let hashData = '';\n            schemaNameArr.forEach((schemaName) => {\n                const value = fieldsObj[schemaName].partialField.data[i];\n                hashData += `-${value}`;\n                tuple[schemaName] = value;\n            });\n            if (!hashTable[hashData]) {\n                if (addData) { data.push(tuple); }\n                hashTable[hashData] = true;\n            }\n        });\n    }\n\n    // Prepare the data\n    prepareDataHelper(dm2, dm2FieldStoreFieldObj, false);\n    prepareDataHelper(dm1, dm1FieldStoreFieldObj, true);\n\n    return new DataModel(data, schema, { name });\n}\n\n","/**\n * The helper function that returns an array of common schema\n * from two fieldStore instances.\n *\n * @param {FieldStore} fs1 - The first FieldStore instance.\n * @param {FieldStore} fs2 - The second FieldStore instance.\n * @return {Array} An array containing the common schema.\n */\nexport function getCommonSchema (fs1, fs2) {\n    const retArr = [];\n    const fs1Arr = [];\n    fs1.fields.forEach((field) => {\n        fs1Arr.push(field.schema().name);\n    });\n    fs2.fields.forEach((field) => {\n        if (fs1Arr.indexOf(field.schema().name) !== -1) {\n            retArr.push(field.schema().name);\n        }\n    });\n    return retArr;\n}\n","import { isArray } from '../utils';\nimport InvalidAwareTypes from '../invalid-aware-types';\nimport { GROUP_BY_FUNCTIONS } from '../enums';\n\nconst { SUM, AVG, FIRST, LAST, COUNT, STD, MIN, MAX } = GROUP_BY_FUNCTIONS;\n\nfunction getFilteredValues(arr) {\n    return arr.filter(item => !(item instanceof InvalidAwareTypes));\n}\n/**\n * Reducer function that returns the sum of all the values.\n *\n * @public\n * @param  {Array.<number>} arr - The input array.\n * @return {number} Returns the sum of the array.\n */\nfunction sum (arr) {\n    if (isArray(arr) && !(arr[0] instanceof Array)) {\n        const filteredNumber = getFilteredValues(arr);\n        const totalSum = filteredNumber.length ?\n                            filteredNumber.reduce((acc, curr) => acc + curr, 0)\n                            : InvalidAwareTypes.NULL;\n        return totalSum;\n    }\n    return InvalidAwareTypes.NULL;\n}\n\n/**\n * Reducer function that returns the average of all the values.\n *\n * @public\n * @param  {Array.<number>} arr - The input array.\n * @return {number} Returns the mean value of the array.\n */\nfunction avg (arr) {\n    if (isArray(arr) && !(arr[0] instanceof Array)) {\n        const totalSum = sum(arr);\n        const len = arr.length || 1;\n        return (Number.isNaN(totalSum) || totalSum instanceof InvalidAwareTypes) ?\n                 InvalidAwareTypes.NULL : totalSum / len;\n    }\n    return InvalidAwareTypes.NULL;\n}\n\n/**\n * Reducer function that gives the min value amongst all the values.\n *\n * @public\n * @param  {Array.<number>} arr - The input array.\n * @return {number} Returns the minimum value of the array.\n */\nfunction min (arr) {\n    if (isArray(arr) && !(arr[0] instanceof Array)) {\n        // Filter out undefined, null and NaN values\n        const filteredValues = getFilteredValues(arr);\n\n        return (filteredValues.length) ? Math.min(...filteredValues) : InvalidAwareTypes.NULL;\n    }\n    return InvalidAwareTypes.NULL;\n}\n\n/**\n * Reducer function that gives the max value amongst all the values.\n *\n * @public\n * @param  {Array.<number>} arr - The input array.\n * @return {number} Returns the maximum value of the array.\n */\nfunction max (arr) {\n    if (isArray(arr) && !(arr[0] instanceof Array)) {\n        // Filter out undefined, null and NaN values\n        const filteredValues = getFilteredValues(arr);\n\n        return (filteredValues.length) ? Math.max(...filteredValues) : InvalidAwareTypes.NULL;\n    }\n    return InvalidAwareTypes.NULL;\n}\n\n/**\n * Reducer function that gives the first value of the array.\n *\n * @public\n * @param  {Array} arr - The input array.\n * @return {number} Returns the first value of the array.\n */\nfunction first (arr) {\n    return arr[0];\n}\n\n/**\n * Reducer function that gives the last value of the array.\n *\n * @public\n * @param  {Array} arr - The input array.\n * @return {number} Returns the last value of the array.\n */\nfunction last (arr) {\n    return arr[arr.length - 1];\n}\n\n/**\n * Reducer function that gives the count value of the array.\n *\n * @public\n * @param  {Array} arr - The input array.\n * @return {number} Returns the length of the array.\n */\nfunction count (arr) {\n    if (isArray(arr)) {\n        return arr.length;\n    }\n    return InvalidAwareTypes.NULL;\n}\n\n/**\n * Calculates the variance of the input array.\n *\n * @param  {Array.<number>} arr - The input array.\n * @return {number} Returns the variance of the input array.\n */\nfunction variance (arr) {\n    let mean = avg(arr);\n    return avg(arr.map(num => (num - mean) ** 2));\n}\n\n/**\n * Calculates the square root of the variance of the input array.\n *\n * @public\n * @param  {Array.<number>} arr - The input array.\n * @return {number} Returns the square root of the variance.\n */\nfunction std (arr) {\n    return Math.sqrt(variance(arr));\n}\n\n\nconst fnList = {\n    [SUM]: sum,\n    [AVG]: avg,\n    [MIN]: min,\n    [MAX]: max,\n    [FIRST]: first,\n    [LAST]: last,\n    [COUNT]: count,\n    [STD]: std\n};\n\nconst defaultReducerName = SUM;\n\nexport {\n    defaultReducerName,\n    sum as defReducer,\n    fnList,\n};\n","import { extend2 } from '../utils';\nimport { rowDiffsetIterator } from './row-diffset-iterator';\nimport DataModel from '../export';\nimport reducerStore from '../utils/reducer-store';\nimport { defaultReducerName } from './group-by-function';\nimport { FieldType } from '../enums';\n\n/**\n * This function sanitize the user given field and return a common Array structure field\n * list\n * @param  {DataModel} dataModel the dataModel operating on\n * @param  {Array} fieldArr  user input of field Array\n * @return {Array}           arrays of field name\n */\nfunction getFieldArr (dataModel, fieldArr) {\n    const retArr = [];\n    const fieldStore = dataModel.getFieldspace();\n    const dimensions = fieldStore.getDimension();\n\n    Object.entries(dimensions).forEach(([key]) => {\n        if (fieldArr && fieldArr.length) {\n            if (fieldArr.indexOf(key) !== -1) {\n                retArr.push(key);\n            }\n        } else {\n            retArr.push(key);\n        }\n    });\n\n    return retArr;\n}\n\n/**\n * This sanitize the reducer provide by the user and create a common type of object.\n * user can give function Also\n * @param  {DataModel} dataModel     dataModel to worked on\n * @param  {Object|function} [reducers={}] reducer provided by the users\n * @return {Object}               object containing reducer function for every measure\n */\nfunction getReducerObj (dataModel, reducers = {}) {\n    const retObj = {};\n    const fieldStore = dataModel.getFieldspace();\n    const measures = fieldStore.getMeasure();\n    const defReducer = reducerStore.defaultReducer();\n\n    Object.keys(measures).forEach((measureName) => {\n        if (typeof reducers[measureName] !== 'string') {\n            reducers[measureName] = measures[measureName].defAggFn();\n        }\n        const reducerFn = reducerStore.resolve(reducers[measureName]);\n        if (reducerFn) {\n            retObj[measureName] = reducerFn;\n        } else {\n            retObj[measureName] = defReducer;\n            reducers[measureName] = defaultReducerName;\n        }\n    });\n    return retObj;\n}\n\n/**\n * main function which perform the group-by operations which reduce the measures value is the\n * fields are common according to the reducer function provided\n * @param  {DataModel} dataModel the dataModel to worked\n * @param  {Array} fieldArr  fields according to which the groupby should be worked\n * @param  {Object|Function} reducers  reducers function\n * @param {DataModel} existingDataModel Existing datamodel instance\n * @return {DataModel} new dataModel with the group by\n */\nfunction groupBy (dataModel, fieldArr, reducers, existingDataModel) {\n    const sFieldArr = getFieldArr(dataModel, fieldArr);\n    const reducerObj = getReducerObj(dataModel, reducers);\n    const fieldStore = dataModel.getFieldspace();\n    const fieldStoreObj = fieldStore.fieldsObj();\n    const dbName = fieldStore.name;\n    const dimensionArr = [];\n    const measureArr = [];\n    const schema = [];\n    const hashMap = {};\n    const data = [];\n    let newDataModel;\n\n    // Prepare the schema\n    Object.entries(fieldStoreObj).forEach(([key, value]) => {\n        if (sFieldArr.indexOf(key) !== -1 || reducerObj[key]) {\n            schema.push(extend2({}, value.schema()));\n\n            switch (value.schema().type) {\n            case FieldType.MEASURE:\n                measureArr.push(key);\n                break;\n            default:\n            case FieldType.DIMENSION:\n                dimensionArr.push(key);\n            }\n        }\n    });\n    // Prepare the data\n    let rowCount = 0;\n    rowDiffsetIterator(dataModel._rowDiffset, (i) => {\n        let hash = '';\n        dimensionArr.forEach((_) => {\n            hash = `${hash}-${fieldStoreObj[_].partialField.data[i]}`;\n        });\n        if (hashMap[hash] === undefined) {\n            hashMap[hash] = rowCount;\n            data.push({});\n            dimensionArr.forEach((_) => {\n                data[rowCount][_] = fieldStoreObj[_].partialField.data[i];\n            });\n            measureArr.forEach((_) => {\n                data[rowCount][_] = [fieldStoreObj[_].partialField.data[i]];\n            });\n            rowCount += 1;\n        } else {\n            measureArr.forEach((_) => {\n                data[hashMap[hash]][_].push(fieldStoreObj[_].partialField.data[i]);\n            });\n        }\n    });\n\n    // reduction\n    let cachedStore = {};\n    let cloneProvider = () => dataModel.detachedRoot();\n    data.forEach((row) => {\n        const tuple = row;\n        measureArr.forEach((_) => {\n            tuple[_] = reducerObj[_](row[_], cloneProvider, cachedStore);\n        });\n    });\n    if (existingDataModel) {\n        existingDataModel.__calculateFieldspace();\n        newDataModel = existingDataModel;\n    }\n    else {\n        newDataModel = new DataModel(data, schema, { name: dbName });\n    }\n    return newDataModel;\n}\n\nexport { groupBy, getFieldArr, getReducerObj };\n","export { createBinnedFieldData } from './bucket-creator';\nexport { compose, bin, select, project, groupBy as groupby } from './compose';\nexport { calculateVariable, sort } from './pure-operators';\nexport { crossProduct } from './cross-product';\nexport { dataBuilder } from './data-builder';\nexport { difference } from './difference';\nexport { getCommonSchema } from './get-common-schema';\nexport { defReducer, fnList } from './group-by-function';\nexport { groupBy, getFieldArr, getReducerObj } from './group-by';\nexport { mergeSort } from './merge-sort';\nexport { naturalJoinFilter } from './natural-join-filter-function';\nexport { naturalJoin } from './natural-join';\nexport { leftOuterJoin, rightOuterJoin, fullOuterJoin } from './outer-join';\nexport { rowDiffsetIterator } from './row-diffset-iterator';\nexport { union } from './union';\n","/**\n * The default sort function.\n *\n * @param {*} a - The first value.\n * @param {*} b - The second value.\n * @return {number} Returns the comparison result e.g. 1 or 0 or -1.\n */\nfunction defSortFn (a, b) {\n    const a1 = `${a}`;\n    const b1 = `${b}`;\n    if (a1 < b1) {\n        return -1;\n    }\n    if (a1 > b1) {\n        return 1;\n    }\n    return 0;\n}\n\n/**\n * The helper function for merge sort which creates the sorted array\n * from the two halves of the input array.\n *\n * @param {Array} arr - The target array which needs to be merged.\n * @param {number} lo - The starting index of the first array half.\n * @param {number} mid - The ending index of the first array half.\n * @param {number} hi - The ending index of the second array half.\n * @param {Function} sortFn - The sort function.\n */\nfunction merge (arr, lo, mid, hi, sortFn) {\n    const mainArr = arr;\n    const auxArr = [];\n    for (let i = lo; i <= hi; i += 1) {\n        auxArr[i] = mainArr[i];\n    }\n    let a = lo;\n    let b = mid + 1;\n\n    for (let i = lo; i <= hi; i += 1) {\n        if (a > mid) {\n            mainArr[i] = auxArr[b];\n            b += 1;\n        } else if (b > hi) {\n            mainArr[i] = auxArr[a];\n            a += 1;\n        } else if (sortFn(auxArr[a], auxArr[b]) <= 0) {\n            mainArr[i] = auxArr[a];\n            a += 1;\n        } else {\n            mainArr[i] = auxArr[b];\n            b += 1;\n        }\n    }\n}\n\n/**\n * The helper function for merge sort which would be called\n * recursively for sorting the array halves.\n *\n * @param {Array} arr - The target array which needs to be sorted.\n * @param {number} lo - The starting index of the array half.\n * @param {number} hi - The ending index of the array half.\n * @param {Function} sortFn - The sort function.\n * @return {Array} Returns the target array itself.\n */\nfunction sort (arr, lo, hi, sortFn) {\n    if (hi === lo) { return arr; }\n\n    const mid = lo + Math.floor((hi - lo) / 2);\n    sort(arr, lo, mid, sortFn);\n    sort(arr, mid + 1, hi, sortFn);\n    merge(arr, lo, mid, hi, sortFn);\n\n    return arr;\n}\n\n/**\n * The implementation of merge sort.\n * It is used in DataModel for stable sorting as it is not sure\n * what the sorting algorithm used by browsers is stable or not.\n *\n * @param {Array} arr - The target array which needs to be sorted.\n * @param {Function} [sortFn=defSortFn] - The sort function.\n * @return {Array} Returns the input array itself in sorted order.\n */\nexport function mergeSort (arr, sortFn = defSortFn) {\n    if (arr.length > 1) {\n        sort(arr, 0, arr.length - 1, sortFn);\n    }\n    return arr;\n}\n","import { getCommonSchema } from './get-common-schema';\n\n/**\n * The filter function used in natural join.\n * It generates a function that will have the logic to join two\n * DataModel instances by the process of natural join.\n *\n * @param {DataModel} dm1 - The left DataModel instance.\n * @param {DataModel} dm2 - The right DataModel instance.\n * @return {Function} Returns a function that is used in cross-product operation.\n */\nexport function naturalJoinFilter (dm1, dm2) {\n    const dm1FieldStore = dm1.getFieldspace();\n    const dm2FieldStore = dm2.getFieldspace();\n    // const dm1FieldStoreName = dm1FieldStore.name;\n    // const dm2FieldStoreName = dm2FieldStore.name;\n    const commonSchemaArr = getCommonSchema(dm1FieldStore, dm2FieldStore);\n\n    return (dm1Fields, dm2Fields) => {\n        let retainTuple = true;\n        commonSchemaArr.forEach((fieldName) => {\n            if (dm1Fields[fieldName].internalValue ===\n                dm2Fields[fieldName].internalValue && retainTuple) {\n                retainTuple = true;\n            } else {\n                retainTuple = false;\n            }\n        });\n        return retainTuple;\n    };\n}\n","import { crossProduct } from './cross-product';\nimport { naturalJoinFilter } from './natural-join-filter-function';\n\nexport function naturalJoin (dataModel1, dataModel2) {\n    return crossProduct(dataModel1, dataModel2, naturalJoinFilter(dataModel1, dataModel2), true);\n}\n","import { crossProduct } from './cross-product';\nimport { JOINS } from '../constants';\nimport { union } from './union';\n\n\nexport function leftOuterJoin (dataModel1, dataModel2, filterFn) {\n    return crossProduct(dataModel1, dataModel2, filterFn, false, JOINS.LEFTOUTER);\n}\n\nexport function rightOuterJoin (dataModel1, dataModel2, filterFn) {\n    return crossProduct(dataModel2, dataModel1, filterFn, false, JOINS.RIGHTOUTER);\n}\n\nexport function fullOuterJoin (dataModel1, dataModel2, filterFn) {\n    return union(leftOuterJoin(dataModel1, dataModel2, filterFn), rightOuterJoin(dataModel1, dataModel2, filterFn));\n}\n","/**\n * Wrapper on calculateVariable() method of DataModel to behave\n * the pure-function functionality.\n *\n * @param {Array} args - The argument list.\n * @return {any} Returns the returned value of calling function.\n */\nexport const calculateVariable = (...args) => dm => dm.calculateVariable(...args);\n\n/**\n * Wrapper on sort() method of DataModel to behave\n * the pure-function functionality.\n *\n * @param {Array} args - The argument list.\n * @return {any} Returns the returned value of calling function.\n */\nexport const sort = (...args) => dm => dm.sort(...args);\n","/**\n * Iterates through the diffSet array and call the callback with the current\n * index.\n *\n * @param {string} rowDiffset - The row diffset string e.g. '0-4,6,10-13'.\n * @param {Function} callback - The callback function to be called with every index.\n */\nexport function rowDiffsetIterator (rowDiffset, callback) {\n    if (rowDiffset.length > 0) {\n        const rowDiffArr = rowDiffset.split(',');\n        rowDiffArr.forEach((diffStr) => {\n            const diffStsArr = diffStr.split('-');\n            const start = +(diffStsArr[0]);\n            const end = +(diffStsArr[1] || diffStsArr[0]);\n            if (end >= start) {\n                for (let i = start; i <= end; i += 1) {\n                    callback(i);\n                }\n            }\n        });\n    }\n}\n","import { DimensionSubtype, MeasureSubtype } from '../enums';\nimport { mergeSort } from './merge-sort';\nimport { fieldInSchema } from '../helper';\nimport { isCallable, isArray } from '../utils';\n\n/**\n * Generates the sorting functions to sort the data of a DataModel instance\n * according to the input data type.\n *\n * @param {string} dataType - The data type e.g. 'measure', 'datetime' etc.\n * @param {string} sortType - The sorting order i.e. 'asc' or 'desc'.\n * @return {Function} Returns the the sorting function.\n */\nfunction getSortFn (dataType, sortType) {\n    let retFunc;\n\n    switch (dataType) {\n    case MeasureSubtype.CONTINUOUS:\n    case DimensionSubtype.TEMPORAL:\n        if (sortType === 'asc') {\n            retFunc = (a, b) => a - b;\n        } else {\n            retFunc = (a, b) => b - a;\n        }\n        break;\n    default:\n        if (sortType === 'asc') {\n            retFunc = (a, b) => {\n                a = `${a}`;\n                b = `${b}`;\n                if (a === b) {\n                    return 0;\n                }\n                return a > b ? 1 : -1;\n            };\n        } else {\n            retFunc = (a, b) => {\n                a = `${a}`;\n                b = `${b}`;\n                if (a === b) {\n                    return 0;\n                }\n                return a > b ? -1 : 1;\n            };\n        }\n    }\n\n    return retFunc;\n}\n\n/**\n * Resolves the actual sorting function based on sorting string value.\n *\n * @param {Object} fDetails - The target field info.\n * @param {string} strSortOrder - The sort order value.\n * @return {Function} Returns the sorting function.\n */\nfunction resolveStrSortOrder (fDetails, strSortOrder) {\n    const sortOrder = String(strSortOrder).toLowerCase() === 'desc' ? 'desc' : 'asc';\n    return getSortFn(fDetails.type, sortOrder);\n}\n\n/**\n * Groups the data according to the specified target field.\n *\n * @param {Array} data - The input data array.\n * @param {number} fieldIndex - The target field index within schema array.\n * @return {Array} Returns an array containing the grouped data.\n */\nfunction groupData (data, fieldIndex) {\n    const hashMap = new Map();\n    const groupedData = [];\n\n    data.forEach((datum) => {\n        const fieldVal = datum[fieldIndex];\n        if (hashMap.has(fieldVal)) {\n            groupedData[hashMap.get(fieldVal)][1].push(datum);\n        } else {\n            groupedData.push([fieldVal, [datum]]);\n            hashMap.set(fieldVal, groupedData.length - 1);\n        }\n    });\n\n    return groupedData;\n}\n\n/**\n * Creates the argument value used for sorting function when sort is done\n * with another fields.\n *\n * @param {Array} groupedDatum - The grouped datum for a single dimension field value.\n * @param {Array} targetFields - An array of the sorting fields.\n * @param {Array} targetFieldDetails - An array of the sorting field details in schema.\n * @return {Object} Returns an object containing the value of sorting fields and the target field name.\n */\nfunction createSortingFnArg (groupedDatum, targetFields, targetFieldDetails) {\n    const arg = {\n        label: groupedDatum[0]\n    };\n\n    targetFields.reduce((acc, next, idx) => {\n        acc[next] = groupedDatum[1].map(datum => datum[targetFieldDetails[idx].index]);\n        return acc;\n    }, arg);\n\n    return arg;\n}\n\n/**\n * Sorts the data by applying the standard sorting mechanism.\n *\n * @param {Array} data - The input data array.\n * @param {Array} schema - The data schema.\n * @param {Array} sortingDetails - An array containing the sorting configs.\n */\nfunction applyStandardSort (data, schema, sortingDetails) {\n    let fieldName;\n    let sortMeta;\n    let fDetails;\n    let i = sortingDetails.length - 1;\n\n    for (; i >= 0; i--) {\n        fieldName = sortingDetails[i][0];\n        sortMeta = sortingDetails[i][1];\n        fDetails = fieldInSchema(schema, fieldName);\n\n        if (!fDetails) {\n            // eslint-disable-next-line no-continue\n            continue;\n        }\n\n        if (isCallable(sortMeta)) {\n            // eslint-disable-next-line no-loop-func\n            mergeSort(data, (a, b) => sortMeta(a[fDetails.index], b[fDetails.index]));\n        } else if (isArray(sortMeta)) {\n            const groupedData = groupData(data, fDetails.index);\n            const sortingFn = sortMeta[sortMeta.length - 1];\n            const targetFields = sortMeta.slice(0, sortMeta.length - 1);\n            const targetFieldDetails = targetFields.map(f => fieldInSchema(schema, f));\n\n            groupedData.forEach((groupedDatum) => {\n                groupedDatum.push(createSortingFnArg(groupedDatum, targetFields, targetFieldDetails));\n            });\n\n            mergeSort(groupedData, (a, b) => {\n                const m = a[2];\n                const n = b[2];\n                return sortingFn(m, n);\n            });\n\n            // Empty the array\n            data.length = 0;\n            groupedData.forEach((datum) => {\n                data.push(...datum[1]);\n            });\n        } else {\n            const sortFn = resolveStrSortOrder(fDetails, sortMeta);\n            // eslint-disable-next-line no-loop-func\n            mergeSort(data, (a, b) => sortFn(a[fDetails.index], b[fDetails.index]));\n        }\n    }\n}\n\n/**\n * Creates a map based on grouping.\n *\n * @param {Array} depColumns - The dependency columns' info.\n * @param {Array} data - The input data.\n * @param {Array} schema - The data schema.\n * @param {Array} sortingDetails - The sorting details for standard sorting.\n * @return {Map} Returns a map.\n */\nconst makeGroupMapAndSort = (depColumns, data, schema, sortingDetails) => {\n    if (depColumns.length === 0) { return data; }\n\n    const targetCol = depColumns[0];\n    const map = new Map();\n\n    data.reduce((acc, currRow) => {\n        const fVal = currRow[targetCol.index];\n        if (acc.has(fVal)) {\n            acc.get(fVal).push(currRow);\n        } else {\n            acc.set(fVal, [currRow]);\n        }\n        return acc;\n    }, map);\n\n    for (let [key, val] of map) {\n        const nMap = makeGroupMapAndSort(depColumns.slice(1), val, schema, sortingDetails);\n        map.set(key, nMap);\n        if (Array.isArray(nMap)) {\n            applyStandardSort(nMap, schema, sortingDetails);\n        }\n    }\n\n    return map;\n};\n\n/**\n * Sorts the data by retaining the position/order of a particular field.\n *\n * @param {Array} data - The input data array.\n * @param {Array} schema - The data schema.\n * @param {Array} sortingDetails - An array containing the sorting configs.\n * @param {Array} depColumns - The dependency column list.\n * @return {Array} Returns the sorted data.\n */\nfunction applyGroupSort (data, schema, sortingDetails, depColumns) {\n    sortingDetails = sortingDetails.filter((detail) => {\n        if (detail[1] === null) {\n            depColumns.push(detail[0]);\n            return false;\n        }\n        return true;\n    });\n    if (sortingDetails.length === 0) { return data; }\n\n    depColumns = depColumns.map(c => fieldInSchema(schema, c));\n\n    const sortedGroupMap = makeGroupMapAndSort(depColumns, data, schema, sortingDetails);\n    return data.map((row) => {\n        let i = 0;\n        let nextMap = sortedGroupMap;\n\n        while (!Array.isArray(nextMap)) {\n            nextMap = nextMap.get(row[depColumns[i++].index]);\n        }\n\n        return nextMap.shift();\n    });\n}\n\n/**\n * Sorts the data.\n *\n * @param {Object} dataObj - An object containing the data and schema.\n * @param {Array} sortingDetails - An array containing the sorting configs.\n */\nexport function sortData (dataObj, sortingDetails) {\n    let { schema, data } = dataObj;\n\n    sortingDetails = sortingDetails.filter(sDetial => !!fieldInSchema(schema, sDetial[0]));\n    if (sortingDetails.length === 0) { return; }\n\n    let groupSortingIdx = sortingDetails.findIndex(sDetial => sDetial[1] === null);\n    groupSortingIdx = groupSortingIdx !== -1 ? groupSortingIdx : sortingDetails.length;\n\n    const standardSortingDetails = sortingDetails.slice(0, groupSortingIdx);\n    const groupSortingDetails = sortingDetails.slice(groupSortingIdx);\n\n    applyStandardSort(data, schema, standardSortingDetails);\n    data = applyGroupSort(data, schema, groupSortingDetails, standardSortingDetails.map(detail => detail[0]));\n\n    dataObj.uids = data.map(row => row.pop());\n    dataObj.data = data;\n}\n","import DataModel from '../export';\nimport { extend2 } from '../utils';\nimport { rowDiffsetIterator } from './row-diffset-iterator';\nimport { isArrEqual } from '../utils/helper';\n/**\n * Performs the union operation between two dm instances.\n *\n * @param {dm} dm1 - The first dm instance.\n * @param {dm} dm2 - The second dm instance.\n * @return {dm} Returns the newly created dm after union operation.\n */\nexport function union (dm1, dm2) {\n    const hashTable = {};\n    const schema = [];\n    const schemaNameArr = [];\n    const data = [];\n    const dm1FieldStore = dm1.getFieldspace();\n    const dm2FieldStore = dm2.getFieldspace();\n    const dm1FieldStoreFieldObj = dm1FieldStore.fieldsObj();\n    const dm2FieldStoreFieldObj = dm2FieldStore.fieldsObj();\n    const name = `${dm1FieldStore.name} union ${dm2FieldStore.name}`;\n\n    // For union the columns should match otherwise return a clone of the dm1\n    if (!isArrEqual(dm1._colIdentifier.split(',').sort(), dm2._colIdentifier.split(',').sort())) {\n        return null;\n    }\n\n    // Prepare the schema\n    (dm1._colIdentifier.split(',')).forEach((fieldName) => {\n        const field = dm1FieldStoreFieldObj[fieldName];\n        schema.push(extend2({}, field.schema()));\n        schemaNameArr.push(field.schema().name);\n    });\n\n    /**\n     * The helper function to create the data.\n     *\n     * @param {dm} dm - The dm instance for which the data is inserted.\n     * @param {Object} fieldsObj - The fieldStore object format.\n     */\n    function prepareDataHelper (dm, fieldsObj) {\n        rowDiffsetIterator(dm._rowDiffset, (i) => {\n            const tuple = {};\n            let hashData = '';\n            schemaNameArr.forEach((schemaName) => {\n                const value = fieldsObj[schemaName].partialField.data[i];\n                hashData += `-${value}`;\n                tuple[schemaName] = value;\n            });\n            if (!hashTable[hashData]) {\n                data.push(tuple);\n                hashTable[hashData] = true;\n            }\n        });\n    }\n\n    // Prepare the data\n    prepareDataHelper(dm1, dm1FieldStoreFieldObj);\n    prepareDataHelper(dm2, dm2FieldStoreFieldObj);\n\n    return new DataModel(data, schema, { name });\n}\n","import { FilteringMode } from './enums';\nimport { getUniqueId } from './utils';\nimport {\n    updateFields,\n    cloneWithSelect,\n    cloneWithProject,\n    updateData,\n    getNormalizedProFields\n} from './helper';\nimport { crossProduct, difference, naturalJoinFilter, union } from './operator';\n\n/**\n * Relation provides the definitions of basic operators of relational algebra like *selection*, *projection*, *union*,\n * *difference* etc.\n *\n * It is extended by {@link DataModel} to inherit the functionalities of relational algebra concept.\n *\n * @class\n * @public\n * @module Relation\n * @namespace DataModel\n */\nclass Relation {\n\n    /**\n     * Creates a new Relation instance by providing underlying data and schema.\n     *\n     * @private\n     *\n     * @param {Object | string | Relation} data - The input tabular data in dsv or json format or\n     * an existing Relation instance object.\n     * @param {Array} schema - An array of data schema.\n     * @param {Object} [options] - The optional options.\n     */\n    constructor (...params) {\n        let source;\n\n        this._parent = null;\n        this._derivation = [];\n        this._ancestorDerivation = [];\n        this._children = [];\n\n        if (params.length === 1 && ((source = params[0]) instanceof Relation)) {\n            // parent datamodel was passed as part of source\n            this._colIdentifier = source._colIdentifier;\n            this._rowDiffset = source._rowDiffset;\n            this._dataFormat = source._dataFormat;\n            this._parent = source;\n            this._partialFieldspace = this._parent._partialFieldspace;\n            this._fieldStoreName = getUniqueId();\n            this.__calculateFieldspace().calculateFieldsConfig();\n        } else {\n            updateData(this, ...params);\n            this._fieldStoreName = this._partialFieldspace.name;\n            this.__calculateFieldspace().calculateFieldsConfig();\n            this._propagationNameSpace = {\n                mutableActions: {},\n                immutableActions: {}\n            };\n        }\n    }\n\n    /**\n     * Retrieves the {@link Schema | schema} details for every {@link Field | field} as an array.\n     *\n     * @public\n     *\n     * @return {Array.<Schema>} Array of fields schema.\n     *      ```\n     *      [\n     *          { name: 'Name', type: 'dimension' },\n     *          { name: 'Miles_per_Gallon', type: 'measure', numberFormat: (val) => `${val} miles / gallon` },\n     *          { name: 'Cylinder', type: 'dimension' },\n     *          { name: 'Displacement', type: 'measure', defAggFn: 'max' },\n     *          { name: 'HorsePower', type: 'measure', defAggFn: 'max' },\n     *          { name: 'Weight_in_lbs', type: 'measure', defAggFn: 'avg',  },\n     *          { name: 'Acceleration', type: 'measure', defAggFn: 'avg' },\n     *          { name: 'Year', type: 'dimension', subtype: 'datetime', format: '%Y' },\n     *          { name: 'Origin' }\n     *      ]\n     *      ```\n     */\n    getSchema () {\n        return this.getFieldspace().fields.map(d => d.schema());\n    }\n\n    /**\n     * Returns the name of the {@link DataModel} instance. If no name was specified during {@link DataModel}\n     * initialization, then it returns a auto-generated name.\n     *\n     * @public\n     *\n     * @return {string} Name of the DataModel instance.\n     */\n    getName() {\n        return this._fieldStoreName;\n    }\n\n    getFieldspace () {\n        return this._fieldspace;\n    }\n\n    __calculateFieldspace () {\n        this._fieldspace = updateFields([this._rowDiffset, this._colIdentifier],\n             this.getPartialFieldspace(), this._fieldStoreName);\n        return this;\n    }\n\n    getPartialFieldspace () {\n        return this._partialFieldspace;\n    }\n\n    /**\n     * Performs {@link link_of_cross_product | cross-product} between two {@link DataModel} instances and returns a\n     * new {@link DataModel} instance containing the results. This operation is also called theta join.\n     *\n     * Cross product takes two set and create one set where each value of one set is paired with each value of another\n     * set.\n     *\n     * This method takes an optional predicate which filters the generated result rows. If the predicate returns true\n     * the combined row is included in the resulatant table.\n     *\n     * @example\n     *  let originDM = dm.project(['Origin','Origin_Formal_Name']);\n     *  let carsDM = dm.project(['Name','Miles_per_Gallon','Origin'])\n     *\n     *  console.log(carsDM.join(originDM)));\n     *\n     *  console.log(carsDM.join(originDM,\n     *      obj => obj.[originDM.getName()].Origin === obj.[carsDM.getName()].Origin));\n     *\n     * @text\n     * This is chained version of `join` operator. `join` can also be used as\n     * {@link link_to_join_op | functional operator}.\n     *\n     * @public\n     *\n     * @param {DataModel} joinWith - The DataModel to be joined with the current instance DataModel.\n     * @param {SelectionPredicate} filterFn - The predicate function that will filter the result of the crossProduct.\n     *\n     * @return {DataModel} New DataModel instance created after joining.\n     */\n    join (joinWith, filterFn) {\n        return crossProduct(this, joinWith, filterFn);\n    }\n\n    /**\n     * {@link natural_join | Natural join} is a special kind of cross-product join where filtering of rows are performed\n     * internally by resolving common fields are from both table and the rows with common value are included.\n     *\n     * @example\n     *  let originDM = dm.project(['Origin','Origin_Formal_Name']);\n     *  let carsDM = dm.project(['Name','Miles_per_Gallon','Origin'])\n     *\n     *  console.log(carsDM.naturalJoin(originDM));\n     *\n     * @text\n     * This is chained version of `naturalJoin` operator. `naturalJoin` can also be used as\n     * {@link link_to_join_op | functional operator}.\n     *\n     * @public\n     *\n     * @param {DataModel} joinWith - The DataModel with which the current instance of DataModel on which the method is\n     *      called will be joined.\n     * @return {DataModel} New DataModel instance created after joining.\n     */\n    naturalJoin (joinWith) {\n        return crossProduct(this, joinWith, naturalJoinFilter(this, joinWith), true);\n    }\n\n    /**\n     * {@link link_to_union | Union} operation can be termed as vertical stacking of all rows from both the DataModel\n     * instances, provided that both of the {@link DataModel} instances should have same column names.\n     *\n     * @example\n     * console.log(EuropeanMakerDM.union(USAMakerDM));\n     *\n     * @text\n     * This is chained version of `naturalJoin` operator. `naturalJoin` can also be used as\n     * {@link link_to_join_op | functional operator}.\n     *\n     * @public\n     *\n     * @param {DataModel} unionWith - DataModel instance for which union has to be applied with the instance on which\n     *      the method is called\n     *\n     * @return {DataModel} New DataModel instance with the result of the operation\n     */\n    union (unionWith) {\n        return union(this, unionWith);\n    }\n\n    /**\n     * {@link link_to_difference | Difference } operation only include rows which are present in the datamodel on which\n     * it was called but not on the one passed as argument.\n     *\n     * @example\n     * console.log(highPowerDM.difference(highExpensiveDM));\n     *\n     * @text\n     * This is chained version of `naturalJoin` operator. `naturalJoin` can also be used as\n     * {@link link_to_join_op | functional operator}.\n     *\n     * @public\n     *\n     * @param {DataModel} differenceWith - DataModel instance for which difference has to be applied with the instance\n     *      on which the method is called\n     * @return {DataModel} New DataModel instance with the result of the operation\n     */\n    difference (differenceWith) {\n        return difference(this, differenceWith);\n    }\n\n    /**\n     * {@link link_to_selection | Selection} is a row filtering operation. It expects a predicate and an optional mode\n     * which control which all rows should be included in the resultant DataModel instance.\n     *\n     * {@link SelectionPredicate} is a function which returns a boolean value. For selection operation the selection\n     * function is called for each row of DataModel instance with the current row passed as argument.\n     *\n     * After executing {@link SelectionPredicate} the rows are labeled as either an entry of selection set or an entry\n     * of rejection set.\n     *\n     * {@link FilteringMode} operates on the selection and rejection set to determine which one would reflect in the\n     * resultant datamodel.\n     *\n     * @warning\n     * Selection and rejection set is only a logical idea for concept explanation purpose.\n     *\n     * @example\n     *  // with selection mode NORMAL:\n     *  const normDt = dt.select(fields => fields.Origin.value === \"USA\")\n     *  console.log(normDt));\n     *\n     * // with selection mode INVERSE:\n     * const inverDt = dt.select(fields => fields.Origin.value === \"USA\", { mode: DataModel.FilteringMode.INVERSE })\n     * console.log(inverDt);\n     *\n     * // with selection mode ALL:\n     * const dtArr = dt.select(fields => fields.Origin.value === \"USA\", { mode: DataModel.FilteringMode.ALL })\n     * // print the selected parts\n     * console.log(dtArr[0]);\n     * // print the inverted parts\n     * console.log(dtArr[1]);\n     *\n     * @text\n     * This is chained version of `select` operator. `select` can also be used as\n     * {@link link_to_join_op | functional operator}.\n     *\n     * @public\n     *\n     * @param {Function} selectFn - The predicate function which is called for each row with the current row.\n     * ```\n     *  function (row, i, cloneProvider, store)  { ... }\n     * ```\n     * @param {Object} config - The configuration object to control the inclusion exclusion of a row in resultant\n     * DataModel instance.\n     * @param {FilteringMode} [config.mode=FilteringMode.NORMAL] - The mode of the selection.\n     * @return {DataModel} Returns the new DataModel instance(s) after operation.\n     */\n    select (selectFn, config) {\n        const defConfig = {\n            mode: FilteringMode.NORMAL,\n            saveChild: true\n        };\n        config = Object.assign({}, defConfig, config);\n        config.mode = config.mode || defConfig.mode;\n\n        const cloneConfig = { saveChild: config.saveChild };\n        return cloneWithSelect(\n            this,\n            selectFn,\n            config,\n            cloneConfig\n        );\n    }\n\n    /**\n     * Retrieves a boolean value if the current {@link DataModel} instance has data.\n     *\n     * @example\n     * const schema = [\n     *    { name: 'CarName', type: 'dimension' },\n     *    { name: 'HorsePower', type: 'measure' },\n     *    { name: \"Origin\", type: 'dimension' }\n     * ];\n     * const data = [];\n     *\n     * const dt = new DataModel(data, schema);\n     * console.log(dt.isEmpty());\n     *\n     * @public\n     *\n     * @return {Boolean} True if the datamodel has no data, otherwise false.\n     */\n    isEmpty () {\n        return !this._rowDiffset.length || !this._colIdentifier.length;\n    }\n\n    /**\n     * Creates a clone from the current DataModel instance with child parent relationship.\n     *\n     * @private\n     * @param {boolean} [saveChild=true] - Whether the cloned instance would be recorded in the parent instance.\n     * @return {DataModel} - Returns the newly cloned DataModel instance.\n     */\n    clone (saveChild = true) {\n        const clonedDm = new this.constructor(this);\n        if (saveChild) {\n            clonedDm.setParent(this);\n        } else {\n            clonedDm.setParent(null);\n        }\n        return clonedDm;\n    }\n\n    /**\n     * {@link Projection} is filter column (field) operation. It expects list of fields' name and either include those\n     * or exclude those based on {@link FilteringMode} on the resultant variable.\n     *\n     * Projection expects array of fields name based on which it creates the selection and rejection set. All the field\n     * whose name is present in array goes in selection set and rest of the fields goes in rejection set.\n     *\n     * {@link FilteringMode} operates on the selection and rejection set to determine which one would reflect in the\n     * resulatant datamodel.\n     *\n     * @warning\n     * Selection and rejection set is only a logical idea for concept explanation purpose.\n     *\n     * @example\n     *  const dm = new DataModel(data, schema);\n     *\n     *  // with projection mode NORMAL:\n     *  const normDt = dt.project([\"Name\", \"HorsePower\"]);\n     *  console.log(normDt.getData());\n     *\n     *  // with projection mode INVERSE:\n     *  const inverDt = dt.project([\"Name\", \"HorsePower\"], { mode: DataModel.FilteringMode.INVERSE })\n     *  console.log(inverDt.getData());\n     *\n     *  // with selection mode ALL:\n     *  const dtArr = dt.project([\"Name\", \"HorsePower\"], { mode: DataModel.FilteringMode.ALL })\n     *  // print the normal parts\n     *  console.log(dtArr[0].getData());\n     *  // print the inverted parts\n     *  console.log(dtArr[1].getData());\n     *\n     * @text\n     * This is chained version of `select` operator. `select` can also be used as\n     * {@link link_to_join_op | functional operator}.\n     *\n     * @public\n     *\n     * @param {Array.<string | Regexp>} projField - An array of column names in string or regular expression.\n     * @param {Object} [config] - An optional config to control the creation of new DataModel\n     * @param {FilteringMode} [config.mode=FilteringMode.NORMAL] - Mode of the projection\n     *\n     * @return {DataModel} Returns the new DataModel instance after operation.\n     */\n    project (projField, config) {\n        const defConfig = {\n            mode: FilteringMode.NORMAL,\n            saveChild: true\n        };\n        config = Object.assign({}, defConfig, config);\n        const fieldConfig = this.getFieldsConfig();\n        const allFields = Object.keys(fieldConfig);\n        const { mode } = config;\n        const normalizedProjField = getNormalizedProFields(projField, allFields, fieldConfig);\n\n        let dataModel;\n\n        if (mode === FilteringMode.ALL) {\n            let projectionClone = cloneWithProject(this, normalizedProjField, {\n                mode: FilteringMode.NORMAL,\n                saveChild: config.saveChild\n            }, allFields);\n            let rejectionClone = cloneWithProject(this, normalizedProjField, {\n                mode: FilteringMode.INVERSE,\n                saveChild: config.saveChild\n            }, allFields);\n            dataModel = [projectionClone, rejectionClone];\n        } else {\n            let projectionClone = cloneWithProject(this, normalizedProjField, config, allFields);\n            dataModel = projectionClone;\n        }\n\n        return dataModel;\n    }\n\n    getFieldsConfig () {\n        return this._fieldConfig;\n    }\n\n    calculateFieldsConfig () {\n        this._fieldConfig = this._fieldspace.fields.reduce((acc, fieldObj, i) => {\n            acc[fieldObj.name()] = {\n                index: i,\n                def: fieldObj.schema(),\n            };\n            return acc;\n        }, {});\n        return this;\n    }\n\n\n    /**\n     * Frees up the resources associated with the current DataModel instance and breaks all the links instance has in\n     * the DAG.\n     *\n     * @public\n     */\n    dispose () {\n        this._parent && this._parent.removeChild(this);\n        this._parent = null;\n        this._children.forEach((child) => {\n            child._parent = null;\n        });\n        this._children = [];\n    }\n\n    /**\n     * Removes the specified child {@link DataModel} from the child list of the current {@link DataModel} instance.\n     *\n     * @example\n     * const schema = [\n     *    { name: 'Name', type: 'dimension' },\n     *    { name: 'HorsePower', type: 'measure' },\n     *    { name: \"Origin\", type: 'dimension' }\n     * ];\n     *\n     * const data = [\n     *    { Name: \"chevrolet chevelle malibu\", Horsepower: 130, Origin: \"USA\" },\n     *    { Name: \"citroen ds-21 pallas\", Horsepower: 115, Origin: \"Europe\" },\n     *    { Name: \"datsun pl510\", Horsepower: 88, Origin: \"Japan\" },\n     *    { Name: \"amc rebel sst\", Horsepower: 150, Origin: \"USA\"},\n     * ]\n     *\n     * const dt = new DataModel(data, schema);\n     *\n     * const dt2 = dt.select(fields => fields.Origin.value === \"USA\")\n     * dt.removeChild(dt2);\n     *\n     * @private\n     *\n     * @param {DataModel} child - Delegates the parent to remove this child.\n     */\n    removeChild (child) {\n        let idx = this._children.findIndex(sibling => sibling === child);\n        idx !== -1 ? this._children.splice(idx, 1) : true;\n    }\n\n    /**\n     * Sets the specified {@link DataModel} as a parent for the current {@link DataModel} instance.\n     *\n     * @param {DataModel} parent - The datamodel instance which will act as parent.\n     */\n    setParent (parent) {\n        this._parent && this._parent.removeChild(this);\n        this._parent = parent;\n        parent && parent._children.push(this);\n    }\n\n    /**\n     * Returns the parent {@link DataModel} instance.\n     *\n     * @example\n     * const schema = [\n     *    { name: 'Name', type: 'dimension' },\n     *    { name: 'HorsePower', type: 'measure' },\n     *    { name: \"Origin\", type: 'dimension' }\n     * ];\n     *\n     * const data = [\n     *    { Name: \"chevrolet chevelle malibu\", Horsepower: 130, Origin: \"USA\" },\n     *    { Name: \"citroen ds-21 pallas\", Horsepower: 115, Origin: \"Europe\" },\n     *    { Name: \"datsun pl510\", Horsepower: 88, Origin: \"Japan\" },\n     *    { Name: \"amc rebel sst\", Horsepower: 150, Origin: \"USA\"},\n     * ]\n     *\n     * const dt = new DataModel(data, schema);\n     *\n     * const dt2 = dt.select(fields => fields.Origin.value === \"USA\");\n     * const parentDm = dt2.getParent();\n     *\n     * @return {DataModel} Returns the parent DataModel instance.\n     */\n    getParent () {\n        return this._parent;\n    }\n\n    /**\n     * Returns the immediate child {@link DataModel} instances.\n     *\n     * @example\n     * const schema = [\n     *    { name: 'Name', type: 'dimension' },\n     *    { name: 'HorsePower', type: 'measure' },\n     *    { name: \"Origin\", type: 'dimension' }\n     * ];\n     *\n     * const data = [\n     *    { Name: \"chevrolet chevelle malibu\", Horsepower: 130, Origin: \"USA\" },\n     *    { Name: \"citroen ds-21 pallas\", Horsepower: 115, Origin: \"Europe\" },\n     *    { Name: \"datsun pl510\", Horsepower: 88, Origin: \"Japan\" },\n     *    { Name: \"amc rebel sst\", Horsepower: 150, Origin: \"USA\"},\n     * ]\n     *\n     * const dt = new DataModel(data, schema);\n     *\n     * const childDm1 = dt.select(fields => fields.Origin.value === \"USA\");\n     * const childDm2 = dt.select(fields => fields.Origin.value === \"Japan\");\n     * const childDm3 = dt.groupBy([\"Origin\"]);\n     *\n     * @return {DataModel[]} Returns the immediate child DataModel instances.\n     */\n    getChildren () {\n        return this._children;\n    }\n\n    /**\n     * Returns the in-between operation meta data while creating the current {@link DataModel} instance.\n     *\n     * @example\n     * const schema = [\n     *   { name: 'Name', type: 'dimension' },\n     *   { name: 'HorsePower', type: 'measure' },\n     *   { name: \"Origin\", type: 'dimension' }\n     * ];\n     *\n     * const data = [\n     *   { Name: \"chevrolet chevelle malibu\", Horsepower: 130, Origin: \"USA\" },\n     *   { Name: \"citroen ds-21 pallas\", Horsepower: 115, Origin: \"Europe\" },\n     *   { Name: \"datsun pl510\", Horsepower: 88, Origin: \"Japan\" },\n     *   { Name: \"amc rebel sst\", Horsepower: 150, Origin: \"USA\"},\n     * ]\n     *\n     * const dt = new DataModel(data, schema);\n     * const dt2 = dt.select(fields => fields.Origin.value === \"USA\");\n     * const dt3 = dt2.groupBy([\"Origin\"]);\n     * const derivations = dt3.getDerivations();\n     *\n     * @return {Any[]} Returns the derivation meta data.\n     */\n    getDerivations () {\n        return this._derivation;\n    }\n\n    /**\n     * Returns the in-between operation meta data happened from root {@link DataModel} to current instance.\n     *\n     * @example\n     * const schema = [\n     *   { name: 'Name', type: 'dimension' },\n     *   { name: 'HorsePower', type: 'measure' },\n     *   { name: \"Origin\", type: 'dimension' }\n     * ];\n     *\n     * const data = [\n     *   { Name: \"chevrolet chevelle malibu\", Horsepower: 130, Origin: \"USA\" },\n     *   { Name: \"citroen ds-21 pallas\", Horsepower: 115, Origin: \"Europe\" },\n     *   { Name: \"datsun pl510\", Horsepower: 88, Origin: \"Japan\" },\n     *   { Name: \"amc rebel sst\", Horsepower: 150, Origin: \"USA\"},\n     * ]\n     *\n     * const dt = new DataModel(data, schema);\n     * const dt2 = dt.select(fields => fields.Origin.value === \"USA\");\n     * const dt3 = dt2.groupBy([\"Origin\"]);\n     * const ancDerivations = dt3.getAncestorDerivations();\n     *\n     * @return {Any[]} Returns the previous derivation meta data.\n     */\n    getAncestorDerivations () {\n        return this._ancestorDerivation;\n    }\n}\n\nexport default Relation;\n","import { fnList } from '../operator/group-by-function';\n\nexport const { sum, avg, min, max, first, last, count, std: sd } = fnList;\n","/**\n * The utility function to calculate major column.\n *\n * @param {Object} store - The store object.\n * @return {Function} Returns the push function.\n */\nexport default (store) => {\n    let i = 0;\n    return (...fields) => {\n        fields.forEach((val, fieldIndex) => {\n            if (!(store[fieldIndex] instanceof Array)) {\n                store[fieldIndex] = Array.from({ length: i });\n            }\n            store[fieldIndex].push(val);\n        });\n        i++;\n    };\n};\n","/**\n * Creates a JS native date object from input\n *\n * @param {string | number | Date} date Input using which date object to be created\n * @return {Date} : JS native date object\n */\nfunction convertToNativeDate (date) {\n    if (date instanceof Date) {\n        return date;\n    }\n\n    return new Date(date);\n}\n/**\n * Apply padding before a number if its less than 1o. This is used when constant digit's number to be returned\n * between 0 - 99\n *\n * @param {number} n Input to be padded\n * @return {string} Padded number\n */\nfunction pad (n) {\n    return (n < 10) ? (`0${n}`) : n;\n}\n/*\n * DateFormatter utility to convert any date format to any other date format\n * DateFormatter parse a date time stamp specified by a user abiding by rules which are defined\n * by user in terms of token. It creates JS native date object from the user specified format.\n * That native date can also be displayed\n * in any specified format.\n * This utility class only takes care of format conversion only\n */\n\n/*\n * Escapes all the special character that are used in regular expression.\n * Like\n * RegExp.escape('sgfd-$') // Output: sgfd\\-\\$\n *\n * @param text {String} : text which is to be escaped\n */\nRegExp.escape = function (text) {\n    return text.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n};\n\n/**\n * DateTimeFormatter class to convert any user format of date time stamp to any other format\n * of date time stamp.\n *\n * @param {string} format Format of the date given. For the above date,\n * 'year: %Y, month: %b, day: %d'.\n * @class\n */\n/* istanbul ignore next */ function DateTimeFormatter (format) {\n    this.format = format;\n    this.dtParams = undefined;\n    this.nativeDate = undefined;\n}\n\n// The identifier of the tokens\nDateTimeFormatter.TOKEN_PREFIX = '%';\n\n// JS native Date constructor takes the date params (year, month, etc) in a certail sequence.\n// This defines the sequence of the date parameters in the constructor.\nDateTimeFormatter.DATETIME_PARAM_SEQUENCE = {\n    YEAR: 0,\n    MONTH: 1,\n    DAY: 2,\n    HOUR: 3,\n    MINUTE: 4,\n    SECOND: 5,\n    MILLISECOND: 6\n};\n\n/*\n * This is a default number parsing utility. It tries to parse a number in integer, if parsing is unsuccessful, it\n * gives back a default value.\n *\n * @param: defVal {Number} : Default no if the parsing to integer is not successful\n * @return {Function} : An closure function which is to be called by passing an the value which needs to be parsed.\n */\nDateTimeFormatter.defaultNumberParser = function (defVal) {\n    return function (val) {\n        let parsedVal;\n        if (isFinite(parsedVal = parseInt(val, 10))) {\n            return parsedVal;\n        }\n\n        return defVal;\n    };\n};\n\n/*\n * This is a default number range utility. It tries to find an element in the range. If not found it returns a\n * default no as an index.\n *\n * @param: range {Array} : The list which is to be serached\n * @param: defVal {Number} : Default no if the serach and find does not return anything\n * @return {Function} : An closure function which is to be called by passing an the value which needs to be found\n */\nDateTimeFormatter.defaultRangeParser = function (range, defVal) {\n    return (val) => {\n        let i;\n        let l;\n\n        if (!val) { return defVal; }\n\n        const nVal = val.toLowerCase();\n\n        for (i = 0, l = range.length; i < l; i++) {\n            if (range[i].toLowerCase() === nVal) {\n                return i;\n            }\n        }\n\n        if (i === undefined) {\n            return defVal;\n        }\n        return null;\n    };\n};\n\n/*\n * Defines the tokens which are supporter by the dateformatter. Using this definitation a value gets extracted from\n * the user specifed date string. This also formats the value for display purpose from native JS date.\n * The definition of each token contains the following named properties\n * {\n *     %token_name% : {\n *         name: name of the token, this is used in reverse lookup,\n *         extract: a function that returns the regular expression to extract that piece of information. All the\n *                  regex should be gouped by using ()\n *         parser: a function which receives value extracted by the above regex and parse it to get the date params\n *         formatter: a formatter function that takes milliseconds or JS Date object and format the param\n *                  represented by the token only.\n *     }\n * }\n *\n * @return {Object} : Definition of the all the supported tokens.\n */\nDateTimeFormatter.getTokenDefinitions = function () {\n    const daysDef = {\n        short: [\n            'Sun',\n            'Mon',\n            'Tue',\n            'Wed',\n            'Thu',\n            'Fri',\n            'Sat'\n        ],\n        long: [\n            'Sunday',\n            'Monday',\n            'Tuesday',\n            'Wednesday',\n            'Thursday',\n            'Friday',\n            'Saturday'\n        ]\n    };\n    const monthsDef = {\n        short: [\n            'Jan',\n            'Feb',\n            'Mar',\n            'Apr',\n            'May',\n            'Jun',\n            'Jul',\n            'Aug',\n            'Sep',\n            'Oct',\n            'Nov',\n            'Dec'\n        ],\n        long: [\n            'January',\n            'February',\n            'March',\n            'April',\n            'May',\n            'June',\n            'July',\n            'August',\n            'September',\n            'October',\n            'November',\n            'December'\n        ]\n    };\n\n    const definitions = {\n        H: {\n            // 24 hours format\n            name: 'H',\n            index: 3,\n            extract () { return '(\\\\d+)'; },\n            parser: DateTimeFormatter.defaultNumberParser(),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n\n                return d.getHours().toString();\n            }\n        },\n        l: {\n            // 12 hours format\n            name: 'l',\n            index: 3,\n            extract () { return '(\\\\d+)'; },\n            parser: DateTimeFormatter.defaultNumberParser(),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const hours = d.getHours() % 12;\n\n                return (hours === 0 ? 12 : hours).toString();\n            }\n        },\n        p: {\n            // AM or PM\n            name: 'p',\n            index: 3,\n            extract () { return '(AM|PM)'; },\n            parser: (val) => {\n                if (val) {\n                    return val.toLowerCase();\n                }\n                return null;\n            },\n            formatter: (val) => {\n                const d = convertToNativeDate(val);\n                const hours = d.getHours();\n\n                return (hours < 12 ? 'AM' : 'PM');\n            }\n        },\n        P: {\n            // am or pm\n            name: 'P',\n            index: 3,\n            extract () { return '(am|pm)'; },\n            parser: (val) => {\n                if (val) {\n                    return val.toLowerCase();\n                }\n                return null;\n            },\n            formatter: (val) => {\n                const d = convertToNativeDate(val);\n                const hours = d.getHours();\n\n                return (hours < 12 ? 'am' : 'pm');\n            }\n        },\n        M: {\n            // Two digit minutes 00 - 59\n            name: 'M',\n            index: 4,\n            extract () { return '(\\\\d+)'; },\n            parser: DateTimeFormatter.defaultNumberParser(),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const mins = d.getMinutes();\n\n                return pad(mins);\n            }\n        },\n        S: {\n            // Two digit seconds 00 - 59\n            name: 'S',\n            index: 5,\n            extract () { return '(\\\\d+)'; },\n            parser: DateTimeFormatter.defaultNumberParser(),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const seconds = d.getSeconds();\n\n                return pad(seconds);\n            }\n        },\n        K: {\n            // Milliseconds\n            name: 'K',\n            index: 6,\n            extract () { return '(\\\\d+)'; },\n            parser: DateTimeFormatter.defaultNumberParser(),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const ms = d.getMilliseconds();\n\n                return ms.toString();\n            }\n        },\n        a: {\n            // Short name of day, like Mon\n            name: 'a',\n            index: 2,\n            extract () { return `(${daysDef.short.join('|')})`; },\n            parser: DateTimeFormatter.defaultRangeParser(daysDef.short),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const day = d.getDay();\n\n                return (daysDef.short[day]).toString();\n            }\n        },\n        A: {\n            // Long name of day, like Monday\n            name: 'A',\n            index: 2,\n            extract () { return `(${daysDef.long.join('|')})`; },\n            parser: DateTimeFormatter.defaultRangeParser(daysDef.long),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const day = d.getDay();\n\n                return (daysDef.long[day]).toString();\n            }\n        },\n        e: {\n            // 8 of March, 11 of November\n            name: 'e',\n            index: 2,\n            extract () { return '(\\\\d+)'; },\n            parser: DateTimeFormatter.defaultNumberParser(),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const day = d.getDate();\n\n                return day.toString();\n            }\n        },\n        d: {\n            // 08 of March, 11 of November\n            name: 'd',\n            index: 2,\n            extract () { return '(\\\\d+)'; },\n            parser: DateTimeFormatter.defaultNumberParser(),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const day = d.getDate();\n\n                return pad(day);\n            }\n        },\n        b: {\n            // Short month, like Jan\n            name: 'b',\n            index: 1,\n            extract () { return `(${monthsDef.short.join('|')})`; },\n            parser: DateTimeFormatter.defaultRangeParser(monthsDef.short),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const month = d.getMonth();\n\n                return (monthsDef.short[month]).toString();\n            }\n        },\n        B: {\n            // Long month, like January\n            name: 'B',\n            index: 1,\n            extract () { return `(${monthsDef.long.join('|')})`; },\n            parser: DateTimeFormatter.defaultRangeParser(monthsDef.long),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const month = d.getMonth();\n\n                return (monthsDef.long[month]).toString();\n            }\n        },\n        m: {\n            // Two digit month of year like 01 for January\n            name: 'm',\n            index: 1,\n            extract () { return '(\\\\d+)'; },\n            parser (val) { return DateTimeFormatter.defaultNumberParser()(val) - 1; },\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const month = d.getMonth();\n\n                return pad(month + 1);\n            }\n        },\n        y: {\n            // Short year like 90 for 1990\n            name: 'y',\n            index: 0,\n            extract () { return '(\\\\d{2})'; },\n            parser (val) {\n                let result;\n                if (val) {\n                    const l = val.length;\n                    val = val.substring(l - 2, l);\n                }\n                let parsedVal = DateTimeFormatter.defaultNumberParser()(val);\n                let presentDate = new Date();\n                let presentYear = Math.trunc((presentDate.getFullYear()) / 100);\n\n                result = `${presentYear}${parsedVal}`;\n\n                if (convertToNativeDate(result).getFullYear() > presentDate.getFullYear()) {\n                    result = `${presentYear - 1}${parsedVal}`;\n                }\n                return convertToNativeDate(result).getFullYear();\n            },\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                let year = d.getFullYear().toString();\n                let l;\n\n                if (year) {\n                    l = year.length;\n                    year = year.substring(l - 2, l);\n                }\n\n                return year;\n            }\n        },\n        Y: {\n            // Long year like 1990\n            name: 'Y',\n            index: 0,\n            extract () { return '(\\\\d{4})'; },\n            parser: DateTimeFormatter.defaultNumberParser(),\n            formatter (val) {\n                const d = convertToNativeDate(val);\n                const year = d.getFullYear().toString();\n\n                return year;\n            }\n        }\n    };\n\n    return definitions;\n};\n\n/*\n * The tokens which works internally is not user friendly in terms of memorizing the names. This gives a formal\n * definition to the informal notations.\n *\n * @return {Object} : Formal definition of the tokens\n */\nDateTimeFormatter.getTokenFormalNames = function () {\n    const definitions = DateTimeFormatter.getTokenDefinitions();\n\n    return {\n        HOUR: definitions.H,\n        HOUR_12: definitions.l,\n        AMPM_UPPERCASE: definitions.p,\n        AMPM_LOWERCASE: definitions.P,\n        MINUTE: definitions.M,\n        SECOND: definitions.S,\n        SHORT_DAY: definitions.a,\n        LONG_DAY: definitions.A,\n        DAY_OF_MONTH: definitions.e,\n        DAY_OF_MONTH_CONSTANT_WIDTH: definitions.d,\n        SHORT_MONTH: definitions.b,\n        LONG_MONTH: definitions.B,\n        MONTH_OF_YEAR: definitions.m,\n        SHORT_YEAR: definitions.y,\n        LONG_YEAR: definitions.Y\n    };\n};\n\n/*\n * This defines the rules and declares dependencies that resolves a date parameter (year, month etc) from\n * the date time parameter array.\n *\n * @return {Object} : An object that contains dependencies and a resolver function. The dependencies values are fed\n *                  to the resolver function in that particular sequence only.\n */\nDateTimeFormatter.tokenResolver = function () {\n    const definitions = DateTimeFormatter.getTokenDefinitions();\n    const defaultResolver = (...args) => { // eslint-disable-line require-jsdoc\n        let i = 0;\n        let arg;\n        let targetParam;\n        const l = args.length;\n\n        for (; i < l; i++) {\n            arg = args[i];\n            if (args[i]) {\n                targetParam = arg;\n            }\n        }\n\n        if (!targetParam) { return null; }\n\n        return targetParam[0].parser(targetParam[1]);\n    };\n\n    return {\n        YEAR: [definitions.y, definitions.Y,\n            defaultResolver\n        ],\n        MONTH: [definitions.b, definitions.B, definitions.m,\n            defaultResolver\n        ],\n        DAY: [definitions.a, definitions.A, definitions.e, definitions.d,\n            defaultResolver\n        ],\n        HOUR: [definitions.H, definitions.l, definitions.p, definitions.P,\n            function (hourFormat24, hourFormat12, ampmLower, ampmUpper) {\n                let targetParam;\n                let amOrpm;\n                let isPM;\n                let val;\n\n                if (hourFormat12 && (amOrpm = (ampmLower || ampmUpper))) {\n                    if (amOrpm[0].parser(amOrpm[1]) === 'pm') {\n                        isPM = true;\n                    }\n\n                    targetParam = hourFormat12;\n                } else if (hourFormat12) {\n                    targetParam = hourFormat12;\n                } else {\n                    targetParam = hourFormat24;\n                }\n\n                if (!targetParam) { return null; }\n\n                val = targetParam[0].parser(targetParam[1]);\n                if (isPM) {\n                    val += 12;\n                }\n                return val;\n            }\n        ],\n        MINUTE: [definitions.M,\n            defaultResolver\n        ],\n        SECOND: [definitions.S,\n            defaultResolver\n        ]\n    };\n};\n\n/*\n * Finds token from the format rule specified by a user.\n * @param format {String} : The format of the input date specified by the user\n * @return {Array} : An array of objects which contains the available token and their occurence index in the format\n */\nDateTimeFormatter.findTokens = function (format) {\n    const tokenPrefix = DateTimeFormatter.TOKEN_PREFIX;\n    const definitions = DateTimeFormatter.getTokenDefinitions();\n    const tokenLiterals = Object.keys(definitions);\n    const occurrence = [];\n    let i;\n    let forwardChar;\n\n    while ((i = format.indexOf(tokenPrefix, i + 1)) >= 0) {\n        forwardChar = format[i + 1];\n        if (tokenLiterals.indexOf(forwardChar) === -1) { continue; }\n\n        occurrence.push({\n            index: i,\n            token: forwardChar\n        });\n    }\n\n    return occurrence;\n};\n\n/*\n * Format any JS date to a specified date given by user.\n *\n * @param date {Number | Date} : The date object which is to be formatted\n * @param format {String} : The format using which the date will be formatted for display\n */\nDateTimeFormatter.formatAs = function (date, format) {\n    const nDate = convertToNativeDate(date);\n    const occurrence = DateTimeFormatter.findTokens(format);\n    const definitions = DateTimeFormatter.getTokenDefinitions();\n    let formattedStr = String(format);\n    const tokenPrefix = DateTimeFormatter.TOKEN_PREFIX;\n    let token;\n    let formattedVal;\n    let i;\n    let l;\n\n    for (i = 0, l = occurrence.length; i < l; i++) {\n        token = occurrence[i].token;\n        formattedVal = definitions[token].formatter(nDate);\n        formattedStr = formattedStr.replace(new RegExp(tokenPrefix + token, 'g'), formattedVal);\n    }\n\n    return formattedStr;\n};\n\n/*\n * Parses the user specified date string to extract the date time params.\n *\n * @return {Array} : Value of date time params in an array [year, month, day, hour, minutes, seconds, milli]\n */\nDateTimeFormatter.prototype.parse = function (dateTimeStamp, options) {\n    const tokenResolver = DateTimeFormatter.tokenResolver();\n    const dtParams = this.extractTokenValue(dateTimeStamp);\n    const dtParamSeq = DateTimeFormatter.DATETIME_PARAM_SEQUENCE;\n    const noBreak = options && options.noBreak;\n    const dtParamArr = [];\n    const args = [];\n    let resolverKey;\n    let resolverParams;\n    let resolverFn;\n    let val;\n    let i;\n    let param;\n    let resolvedVal;\n    let l;\n    let result = [];\n\n    for (resolverKey in tokenResolver) {\n        if (!{}.hasOwnProperty.call(tokenResolver, resolverKey)) { continue; }\n\n        args.length = 0;\n        resolverParams = tokenResolver[resolverKey];\n        resolverFn = resolverParams.splice(resolverParams.length - 1, 1)[0];\n\n        for (i = 0, l = resolverParams.length; i < l; i++) {\n            param = resolverParams[i];\n            val = dtParams[param.name];\n\n            if (val === undefined) {\n                args.push(null);\n            } else {\n                args.push([param, val]);\n            }\n        }\n\n        resolvedVal = resolverFn.apply(this, args);\n\n        if ((resolvedVal === undefined || resolvedVal === null) && !noBreak) {\n            break;\n        }\n\n        dtParamArr[dtParamSeq[resolverKey]] = resolvedVal;\n    }\n\n    if (dtParamArr.length && this.checkIfOnlyYear(dtParamArr.length))\n     {\n        result.unshift(dtParamArr[0], 0, 1); }\n    else {\n        result.unshift(...dtParamArr);\n    }\n\n    return result;\n};\n\n/*\n * Extract the value of the token from user specified date time string.\n *\n * @return {Object} : An key value pair which contains the tokens as key and value as pair\n */\nDateTimeFormatter.prototype.extractTokenValue = function (dateTimeStamp) {\n    const format = this.format;\n    const definitions = DateTimeFormatter.getTokenDefinitions();\n    const tokenPrefix = DateTimeFormatter.TOKEN_PREFIX;\n    const occurrence = DateTimeFormatter.findTokens(format);\n    const tokenObj = {};\n\n    let lastOccurrenceIndex;\n    let occObj;\n    let occIndex;\n    let targetText;\n    let regexFormat;\n\n    let l;\n    let i;\n\n    regexFormat = String(format);\n\n    const tokenArr = occurrence.map(obj => obj.token);\n    const occurrenceLength = occurrence.length;\n    for (i = occurrenceLength - 1; i >= 0; i--) {\n        occIndex = occurrence[i].index;\n\n        if (occIndex + 1 === regexFormat.length - 1) {\n            lastOccurrenceIndex = occIndex;\n            continue;\n        }\n\n        if (lastOccurrenceIndex === undefined) {\n            lastOccurrenceIndex = regexFormat.length;\n        }\n\n        targetText = regexFormat.substring(occIndex + 2, lastOccurrenceIndex);\n        regexFormat = regexFormat.substring(0, occIndex + 2) +\n            RegExp.escape(targetText) +\n            regexFormat.substring(lastOccurrenceIndex, regexFormat.length);\n\n        lastOccurrenceIndex = occIndex;\n    }\n\n    for (i = 0; i < occurrenceLength; i++) {\n        occObj = occurrence[i];\n        regexFormat = regexFormat.replace(tokenPrefix + occObj.token, definitions[occObj.token].extract());\n    }\n\n    const extractValues = dateTimeStamp.match(new RegExp(regexFormat)) || [];\n    extractValues.shift();\n\n    for (i = 0, l = tokenArr.length; i < l; i++) {\n        tokenObj[tokenArr[i]] = extractValues[i];\n    }\n    return tokenObj;\n};\n\n/*\n * Give back the JS native date formed from  user specified date string\n *\n * @return {Date} : Native JS Date\n */\nDateTimeFormatter.prototype.getNativeDate = function (dateTimeStamp) {\n    let date = null;\n    if (Number.isFinite(dateTimeStamp)) {\n        date = new Date(dateTimeStamp);\n    } else if (!this.format && Date.parse(dateTimeStamp)) {\n        date = new Date(dateTimeStamp);\n    }\n    else {\n        const dtParams = this.dtParams = this.parse(dateTimeStamp);\n        if (dtParams.length) {\n            this.nativeDate = new Date(...dtParams);\n            date = this.nativeDate;\n        }\n    }\n    return date;\n};\n\nDateTimeFormatter.prototype.checkIfOnlyYear = function(len) {\n    return len === 1 && this.format.match(/y|Y/g).length;\n};\n\n/*\n * Represents JS native date to a user specified format.\n *\n * @param format {String} : The format according to which the date is to be represented\n * @return {String} : The formatted date string\n */\nDateTimeFormatter.prototype.formatAs = function (format, dateTimeStamp) {\n    let nativeDate;\n\n    if (dateTimeStamp) {\n        nativeDate = this.nativeDate = this.getNativeDate(dateTimeStamp);\n    } else if (!(nativeDate = this.nativeDate)) {\n        nativeDate = this.getNativeDate(dateTimeStamp);\n    }\n\n    return DateTimeFormatter.formatAs(nativeDate, format);\n};\n\nexport { DateTimeFormatter as default };\n","/**\n * Generates domain for measure field.\n *\n * @param {Array} data - The array of data.\n * @return {Array} Returns the measure domain.\n */\nexport default (data) => {\n    let min = Number.POSITIVE_INFINITY;\n    let max = Number.NEGATIVE_INFINITY;\n\n    data.forEach((d) => {\n        if (d < min) {\n            min = d;\n        }\n        if (d > max) {\n            max = d;\n        }\n    });\n\n    return [min, max];\n};\n","/* eslint-disable */\nconst OBJECTSTRING = 'object';\nconst objectToStrFn = Object.prototype.toString;\nconst objectToStr = '[object Object]';\nconst arrayToStr = '[object Array]';\n\nfunction checkCyclicRef(obj, parentArr) {\n    let i = parentArr.length;\n    let bIndex = -1;\n\n    while (i) {\n        if (obj === parentArr[i]) {\n            bIndex = i;\n            return bIndex;\n        }\n        i -= 1;\n    }\n\n    return bIndex;\n}\n\nfunction merge(obj1, obj2, skipUndef, tgtArr, srcArr) {\n    var item,\n        srcVal,\n        tgtVal,\n        str,\n        cRef;\n    // check whether obj2 is an array\n    // if array then iterate through it's index\n    // **** MOOTOOLS precution\n\n    if (!srcArr) {\n        tgtArr = [obj1];\n        srcArr = [obj2];\n    }\n    else {\n        tgtArr.push(obj1);\n        srcArr.push(obj2);\n    }\n\n    if (obj2 instanceof Array) {\n        for (item = 0; item < obj2.length; item += 1) {\n            try {\n                srcVal = obj1[item];\n                tgtVal = obj2[item];\n            }\n            catch (e) {\n                continue;\n            }\n\n            if (typeof tgtVal !== OBJECTSTRING) {\n                if (!(skipUndef && tgtVal === undefined)) {\n                    obj1[item] = tgtVal;\n                }\n            }\n            else {\n                if (srcVal === null || typeof srcVal !== OBJECTSTRING) {\n                    srcVal = obj1[item] = tgtVal instanceof Array ? [] : {};\n                }\n                cRef = checkCyclicRef(tgtVal, srcArr);\n                if (cRef !== -1) {\n                    srcVal = obj1[item] = tgtArr[cRef];\n                }\n                else {\n                    merge(srcVal, tgtVal, skipUndef, tgtArr, srcArr);\n                }\n            }\n        }\n    }\n    else {\n        for (item in obj2) {\n            try {\n                srcVal = obj1[item];\n                tgtVal = obj2[item];\n            }\n            catch (e) {\n                continue;\n            }\n\n            if (tgtVal !== null && typeof tgtVal === OBJECTSTRING) {\n                // Fix for issue BUG: FWXT-602\n                // IE < 9 Object.prototype.toString.call(null) gives\n                // '[object Object]' instead of '[object Null]'\n                // that's why null value becomes Object in IE < 9\n                str = objectToStrFn.call(tgtVal);\n                if (str === objectToStr) {\n                    if (srcVal === null || typeof srcVal !== OBJECTSTRING) {\n                        srcVal = obj1[item] = {};\n                    }\n                    cRef = checkCyclicRef(tgtVal, srcArr);\n                    if (cRef !== -1) {\n                        srcVal = obj1[item] = tgtArr[cRef];\n                    }\n                    else {\n                        merge(srcVal, tgtVal, skipUndef, tgtArr, srcArr);\n                    }\n                }\n                else if (str === arrayToStr) {\n                    if (srcVal === null || !(srcVal instanceof Array)) {\n                        srcVal = obj1[item] = [];\n                    }\n                    cRef = checkCyclicRef(tgtVal, srcArr);\n                    if (cRef !== -1) {\n                        srcVal = obj1[item] = tgtArr[cRef];\n                    }\n                    else {\n                        merge(srcVal, tgtVal, skipUndef, tgtArr, srcArr);\n                    }\n                }\n                else {\n                    obj1[item] = tgtVal;\n                }\n            }\n            else {\n                if (skipUndef && tgtVal === undefined) {\n                    continue;\n                }\n                obj1[item] = tgtVal;\n            }\n        }\n    }\n    return obj1;\n}\n\n\nfunction extend2 (obj1, obj2, skipUndef) {\n    //if none of the arguments are object then return back\n    if (typeof obj1 !== OBJECTSTRING && typeof obj2 !== OBJECTSTRING) {\n        return null;\n    }\n\n    if (typeof obj2 !== OBJECTSTRING || obj2 === null) {\n        return obj1;\n    }\n\n    if (typeof obj1 !== OBJECTSTRING) {\n        obj1 = obj2 instanceof Array ? [] : {};\n    }\n    merge(obj1, obj2, skipUndef);\n    return obj1;\n}\n\nexport { extend2 as default };\n","import { DataFormat } from '../enums';\n\n/**\n * Checks whether the value is an array.\n *\n * @param  {*} val - The value to be checked.\n * @return {boolean} Returns true if the value is an array otherwise returns false.\n */\nexport function isArray (val) {\n    return Array.isArray(val);\n}\n\n/**\n * Checks whether the value is an object.\n *\n * @param  {*} val - The value to be checked.\n * @return {boolean} Returns true if the value is an object otherwise returns false.\n */\nexport function isObject (val) {\n    return val === Object(val);\n}\n\n/**\n * Checks whether the value is a string value.\n *\n * @param  {*} val - The value to be checked.\n * @return {boolean} Returns true if the value is a string value otherwise returns false.\n */\nexport function isString (val) {\n    return typeof val === 'string';\n}\n\n/**\n * Checks whether the value is callable.\n *\n * @param {*} val - The value to be checked.\n * @return {boolean} Returns true if the value is callable otherwise returns false.\n */\nexport function isCallable (val) {\n    return typeof val === 'function';\n}\n\n/**\n * Returns the unique values from the input array.\n *\n * @param {Array} data - The input array.\n * @return {Array} Returns a new array of unique values.\n */\nexport function uniqueValues (data) {\n    return [...new Set(data)];\n}\n\nexport const getUniqueId = () => `id-${new Date().getTime()}${Math.round(Math.random() * 10000)}`;\n\n/**\n * Checks Whether two arrays have same content.\n *\n * @param {Array} arr1 - The first array.\n * @param {Array} arr2 - The 2nd array.\n * @return {boolean} Returns whether two array have same content.\n */\nexport function isArrEqual(arr1, arr2) {\n    if (!isArray(arr1) || !isArray(arr2)) {\n        return arr1 === arr2;\n    }\n\n    if (arr1.length !== arr2.length) {\n        return false;\n    }\n\n    for (let i = 0; i < arr1.length; i++) {\n        if (arr1[i] !== arr2[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * It is the default number format function for the measure field type.\n *\n * @param {any} val - The input value.\n * @return {number} Returns a number value.\n */\nexport function formatNumber(val) {\n    return val;\n}\n\n/**\n * Returns the detected data format.\n *\n * @param {any} data - The input data to be tested.\n * @return {string} Returns the data format name.\n */\nexport const detectDataFormat = (data) => {\n    if (isString(data)) {\n        return DataFormat.DSV_STR;\n    } else if (isArray(data) && isArray(data[0])) {\n        return DataFormat.DSV_ARR;\n    } else if (isArray(data) && (data.length === 0 || isObject(data[0]))) {\n        return DataFormat.FLAT_JSON;\n    }\n    return null;\n};\n","export { default as DateTimeFormatter } from './date-time-formatter';\nexport { default as columnMajor } from './column-major';\nexport { default as generateMeasureDomain } from './domain-generator';\nexport { default as extend2 } from './extend2';\nexport * from './helper';\n","import { defReducer, fnList } from '../operator';\n\n/**\n * A page level storage which stores, registers, unregisters reducers for all the datamodel instances. There is only one\n * reducer store available in a page. All the datamodel instances receive same instance of reducer store. DataModel\n * out of the box provides handful of {@link reducer | reducers} which can be used as reducer funciton.\n *\n * @public\n * @namespace DataModel\n */\nclass ReducerStore {\n    constructor () {\n        this.store = new Map();\n        this.store.set('defReducer', defReducer);\n\n        Object.entries(fnList).forEach((key) => {\n            this.store.set(key[0], key[1]);\n        });\n    }\n\n    /**\n     * Changes the `defaultReducer` globally. For all the fields which does not have `defAggFn` mentioned in schema, the\n     * value of `defaultReducer` is used for aggregation.\n     *\n     * @public\n     * @param {string} [reducer='sum'] - The name of the default reducer. It picks up the definition from store by doing\n     * name lookup. If no name is found then it takes `sum` as the default reducer.\n     * @return {ReducerStore} Returns instance of the singleton store in page.\n     */\n    defaultReducer (...params) {\n        if (!params.length) {\n            return this.store.get('defReducer');\n        }\n\n        let reducer = params[0];\n\n        if (typeof reducer === 'function') {\n            this.store.set('defReducer', reducer);\n        } else {\n            reducer = String(reducer);\n            if (Object.keys(fnList).indexOf(reducer) !== -1) {\n                this.store.set('defReducer', fnList[reducer]);\n            } else {\n                throw new Error(`Reducer ${reducer} not found in registry`);\n            }\n        }\n        return this;\n    }\n\n    /**\n     *\n     * Registers a {@link reducer | reducer}.\n     * A {@link reducer | reducer} has to be registered before it is used.\n     *\n     * @example\n     *  // find the mean squared value of a given set\n     *  const reducerStore = DataModel.Reducers();\n     *\n     *  reducers.register('meanSquared', (arr) => {\n     *      const squaredVal = arr.map(item => item * item);\n     *      let sum = 0;\n     *      for (let i = 0, l = squaredVal.length; i < l; i++) {\n     *          sum += squaredVal[i++];\n     *      }\n     *\n     *      return sum;\n     *  })\n     *\n     *  // datamodel (dm) is already prepared with cars.json\n     *  const dm1 = dm.groupBy(['origin'], {\n     *      accleration: 'meanSquared'\n     *  });\n     *\n     * @public\n     *\n     * @param {string} name formal name for a reducer. If the given name already exists in store it is overridden by new\n     *      definition.\n     * @param {Function} reducer definition of {@link reducer} function.\n     *\n     * @return {Function} function for unregistering the reducer.\n     */\n    register (name, reducer) {\n        if (typeof reducer !== 'function') {\n            throw new Error('Reducer should be a function');\n        }\n\n        name = String(name);\n        this.store.set(name, reducer);\n\n        return () => { this.__unregister(name); };\n    }\n\n    __unregister (name) {\n        if (this.store.has(name)) {\n            this.store.delete(name);\n        }\n    }\n\n    resolve (name) {\n        if (name instanceof Function) {\n            return name;\n        }\n        return this.store.get(name);\n    }\n}\n\nconst reducerStore = (function () {\n    let store = null;\n\n    function getStore () {\n        if (store === null) {\n            store = new ReducerStore();\n        }\n        return store;\n    }\n    return getStore();\n}());\n\nexport default reducerStore;\n","import { getNumberFormattedVal } from './helper';\n\n/**\n * The wrapper class on top of the primitive value of a field.\n *\n * @todo Need to have support for StringValue, NumberValue, DateTimeValue\n * and GeoValue. These types should expose predicate API mostly.\n */\nclass Value {\n\n  /**\n   * Creates new Value instance.\n   *\n   * @param {*} val - the primitive value from the field cell.\n   * @param {string | Field} field - The field from which the value belongs.\n   */\n    constructor (value, rawValue, field) {\n        const formattedValue = getNumberFormattedVal(field, value);\n\n        Object.defineProperties(this, {\n            _value: {\n                enumerable: false,\n                configurable: false,\n                writable: false,\n                value\n            },\n            _formattedValue: {\n                enumerable: false,\n                configurable: false,\n                writable: false,\n                value: formattedValue\n            },\n            _internalValue: {\n                enumerable: false,\n                configurable: false,\n                writable: false,\n                value: rawValue\n            }\n        });\n\n        this.field = field;\n    }\n\n  /**\n   * Returns the field value.\n   *\n   * @return {*} Returns the current value.\n   */\n    get value () {\n        return this._value;\n    }\n\n    /**\n     * Returns the parsed value of field\n     */\n    get formattedValue () {\n        return this._formattedValue;\n    }\n\n    /**\n     * Returns the internal value of field\n     */\n    get internalValue () {\n        return this._internalValue;\n    }\n\n  /**\n   * Converts to human readable string.\n   *\n   * @override\n   * @return {string} Returns a human readable string of the field value.\n   *\n   */\n    toString () {\n        return String(this.value);\n    }\n\n  /**\n   * Returns the value of the field.\n   *\n   * @override\n   * @return {*} Returns the field value.\n   */\n    valueOf () {\n        return this.value;\n    }\n}\n\nexport default Value;\n"],"sourceRoot":""}